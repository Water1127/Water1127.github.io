<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IntelliJ IDEA 个人设置]]></title>
    <url>%2F2020%2F01%2F22%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2FIDEA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[方法分割符 Show method separators 自动导包 动态添加明确的导入 Add unambiguous imports on the fly 动态优化导入(对于当前项目) Optimize imports on the fly(for current project) 单行多个标签页 Show tabs in one row 鼠标滑轮改变字体大小 Change font size(Zoom) with Ctrl+Mouse Wheel 鼠标悬浮提示 Show quick documentation on mouse move 隐藏文件 ignore：*.idea;out;*.iml; 关闭自动折叠 code folding]]></content>
      <categories>
        <category>&lt;b&gt;开发工具&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合]]></title>
    <url>%2F2019%2F10%2F05%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%880%2F</url>
    <content type="text"><![CDATA[SSM框架整合 SSM框架 Spring框架 SpringMVC框架 SpringMVC框架整合 MyBatis框架 MyBatis框架整合 SSM框架结构目录 java resources log4j.properties（日志文件） pom.xml（Maven项目配置文件） Maven项目配置文件 Spring框架 spring-beans spring-core spring-context spring-context-support spring-aop aspectjweaver spring-org spring-test spring-tx SpringMVC框架 spring-web spring-webmvc 前端 servlet-api jsp-api jstl MyBatis框架 mybatis mybatis-spring 数据库 mysql-connector-java c3p0 日志 log4j slf4j slf4j-log4j12 测试 junit pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 核心（包括spring-core,spring-beans,spring-aop,spring-expression） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将第三方库整合进 Spring 应用上下文 提供支持（如缓存 caching , 邮件mailing , 计划任务scheduling） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP（动态代理 注解） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring 事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JSP标准标签库（EL表达式、JSTL标签） --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis（SSM整合） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; log日志文件 记录日志 log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n Spring框架结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） test TestSpring.java（测试文件） resources applicationContext.xml（Spring配置文件） Spring配置文件 开启注解扫描 忽略表现层注解 applicationContext.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;/beans&gt;` JavaBean对象Accont.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125;` 持久层 MyBatis框架生成代理对象，我们不需要创建实现类 AccountDao.java123456789101112131415161718package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125;` 业务层AccountService.java123456789101112131415package cn.water.service;import cn.water.domain.Account;import java.util.List;public interface AccountService &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; AccountServiceImp.java1234567891011121314151617181920212223package cn.water.service;import cn.water.domain.Account;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层：查询所有用户"); return null; &#125; /** 添加用户 */ @Override public void add(Account account) &#123; System.out.println("业务层：添加用户"); &#125;&#125; 测试TestSpring.java123456789101112131415161718192021package cn.water.test;import cn.water.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void run01() &#123;// 加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");// 获取对象 AccountService as = (AccountService) ac.getBean("accountService");// 调用方法 as.findAll(); &#125;&#125;` 运行结果1业务层：查询所有用户 SpringMVC框架结构目录 java controller AccountController.java（表现层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 前端控制器 配置 前端控制器（DispatcherServlet） 配置 创建前端控制器时，加载配置文件（contextConfigLocation） 配置 服务器启动时，立即创建前端控制器（1） 配置 映射/作用范围（/） 过滤器 配置 过滤器（CharacterEncodingFilter） 配置 编码（UTF-8） 配置 映射/作用范围（/*） web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC配置文件 开启 注解扫描（context：component-scan） 只扫描表现层注解 配置 视图解析器（InternalResourceViewResolver） 配置 前端控制器（mvc：resource） 开启 SpringMVC注解支持（mvc：annotation-driven） springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启 注解扫描 --&gt; &lt;context:component-scan base-package="cn.water.controller"/&gt; &lt;!-- 配置 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 前端控制器 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 开启 SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 表现层AccountController.java 返回：list 12345678910111213141516171819package cn.water.controller;import cn.water.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping("accountController")public class AccountController &#123; @RequestMapping("findAll") public String findAll()&#123; System.out.println("表现层：查询所有用户信息"); return "list"; &#125;&#125; jsp页面index.jsp 执行表现层的方法，获得返回值“/WEB-INF/pages/list.jsp”，跳转页面 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; jsp页面 展示 list.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Spring 整合 SpringMVC结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 监听器 配置 监听器（ContextLoaderListener） 配置 服务器启动时，加载配置文件（contextConfigLocation） 前端控制器 过滤器 web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 监听器 --&gt; &lt;!-- 服务器启动时，加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 前端控制器 --&gt; &lt;!-- 服务器启动时，DispatcherServlet对象被创建，加载SpringMVC配置文件 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 表现层 通过依赖反转获取 业务层对象，并执行业务层的方法，到达Spring与SpringMVC的整合。 AccountController.java123456789101112131415161718192021222324package cn.water.controller;import cn.water.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("accountController")public class AccountController &#123; @Autowired private AccountService service; @RequestMapping("findAll") public String findAll()&#123; /* 表现层 */ System.out.println("表现层：查询所有用户信息"); /* 业务层 */ service.findAll(); return "list"; &#125;&#125; 执行结果点击 index.jsp 页面，执行表现层中的findAll()，和业务层的findAll()，最后跳转到 list.jsp 页面。 12表现层：查询所有用户信息业务层：查询所有用户 MyBatis框架数据库表1234567891011CREATE DATABASE ssm;USE ssm;CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), money DOUBLE(4,2));INSERT INTO account VALUES (NULL,&apos;cat&apos;,9.16),(NULL,&apos;dog&apos;,11.27); 结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） test TestMyBatis（测试类） resources SqlMapConfig.xml（数据库连接配置文件） 数据库连接配置文件方式一jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee314jdbc.username=rootjdbc.password=1234 SqlMapConfig.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 加载 连接数据库的信息 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定 映射文件位置 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 方式二SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///ssm"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入 映射配置文件 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层 采用注解的方式 AccountDao1234567891011121314151617181920package cn.water.dao;import cn.water.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ @Select("select * from account") public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ @Insert("insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)") public abstract void add(Account account);&#125; 测试类TestMyBatis123456789101112131415161718192021222324252627282930313233343536373839package cn.water.test;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; @Test public void run01() throws Exception &#123; /* 加载 配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 建造者对象，获取 工厂对象 */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂对象，获取 Session对象 */ SqlSession sqlSession = sqlSessionFactory.openSession(); /* 通过 Session对象，获取 代理对象 */ AccountDao mapper = sqlSession.getMapper(AccountDao.class); /* 调用 持久层 */ List&lt;Account&gt; all = mapper.findAll(); /* 遍历 */ for (Account account : all) &#123; System.out.println(account); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果12Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125; Spring 整合 MyBatis结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） Spring配置文件 开启注解扫描 忽略表现层注解 Spring 整合 MyBatis 配置 连接池（ComboPooledDataSource） 配置 SqlSessionFactoryBean 配置 持久层接口的包 Spring 声明式事务管理 配置 事务管理（DataSourceTransactionManager） 配置 事务通知（tx：advice） 配置 AOP增强（aop：config） applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring 整合 MyBatis --&gt; &lt;!-- 配置 连接池 --&gt; &lt;bean id="comboPooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 SqlSessionFactoryBean --&gt; &lt;bean id="sessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 持久层接口的包 --&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.water.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring 声明式事务管理 --&gt; &lt;!-- 配置 事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 查询方法：只读 --&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;!-- --&gt; &lt;tx:method name="*" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置 AOP增强 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.water.service.*SErviceImp.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 业务层 业务层调用持久层 AccountServiceImp.java123456789101112131415161718192021222324252627282930313233package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; @Autowired private AccountDao dao; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; /* 业务层 */ System.out.println("业务层：查询所有用户"); /* 持久层 */ return dao.findAll(); &#125; /** 添加用户 */ @Override public void addAccount(Account account) &#123; /* 业务层 */ System.out.println("业务层：添加用户"); /* 持久层 */ dao.addAccount(account); &#125;&#125; jsp页面index.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt; &lt;form action="accountController/addAccount" method="post"&gt; 姓名：&lt;input type="text" name="name"&gt; 金额：&lt;input type="text" name="money"&gt; &lt;input type="submit" value="保存"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp页面list.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt; &lt;h2&gt;$&#123;accounts&#125;&lt;/h2&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account"&gt; &lt;h3&gt;$&#123;account.id&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.name&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.money&#125;&lt;/h3&gt; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 运行结果页面展示1234567891011121314151617用户信息列表[Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;, Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;, Account&#123;id=3, name=&apos;rat&apos;, money=14.87&#125;, Account&#123;id=4, name=&apos;water&apos;, money=11.11&#125;]1cat9.162dog11.273rat14.874water11.11 控制台1234表现层：查询所有用户信息业务层：添加用户表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（6）——Spring整合MyBatis]]></title>
    <url>%2F2019%2F10%2F04%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%886%20MyBatis%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring 整合 MyBatis结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） Spring配置文件 开启注解扫描 忽略表现层注解 Spring 整合 MyBatis 配置 连接池（ComboPooledDataSource） 配置 SqlSessionFactoryBean 配置 持久层接口的包 Spring 声明式事务管理 配置 事务管理（DataSourceTransactionManager） 配置 事务通知（tx：advice） 配置 AOP增强（aop：config） applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring 整合 MyBatis --&gt; &lt;!-- 配置 连接池 --&gt; &lt;bean id="comboPooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 SqlSessionFactoryBean --&gt; &lt;bean id="sessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 持久层接口的包 --&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.water.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring 声明式事务管理 --&gt; &lt;!-- 配置 事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 查询方法：只读 --&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;!-- --&gt; &lt;tx:method name="*" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置 AOP增强 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.water.service.*SErviceImp.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 业务层 业务层调用持久层 AccountServiceImp.java123456789101112131415161718192021222324252627282930313233package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; @Autowired private AccountDao dao; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; /* 业务层 */ System.out.println("业务层：查询所有用户"); /* 持久层 */ return dao.findAll(); &#125; /** 添加用户 */ @Override public void addAccount(Account account) &#123; /* 业务层 */ System.out.println("业务层：添加用户"); /* 持久层 */ dao.addAccount(account); &#125;&#125; jsp页面index.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt; &lt;form action="accountController/addAccount" method="post"&gt; 姓名：&lt;input type="text" name="name"&gt; 金额：&lt;input type="text" name="money"&gt; &lt;input type="submit" value="保存"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp页面list.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt; &lt;h2&gt;$&#123;accounts&#125;&lt;/h2&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account"&gt; &lt;h3&gt;$&#123;account.id&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.name&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.money&#125;&lt;/h3&gt; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 运行结果页面展示1234567891011121314151617用户信息列表[Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;, Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;, Account&#123;id=3, name=&apos;rat&apos;, money=14.87&#125;, Account&#123;id=4, name=&apos;water&apos;, money=11.11&#125;]1cat9.162dog11.273rat14.874water11.11 控制台1234表现层：查询所有用户信息业务层：添加用户表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（5）——MyBatis框架环境搭建]]></title>
    <url>%2F2019%2F10%2F03%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%885%20MyBatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[MyBatis框架数据库表1234567891011CREATE DATABASE ssm;USE ssm;CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), money DOUBLE(4,2));INSERT INTO account VALUES (NULL,&apos;cat&apos;,9.16),(NULL,&apos;dog&apos;,11.27); 结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） test TestMyBatis（测试类） resources SqlMapConfig.xml（数据库连接配置文件） 数据库连接配置文件方式一jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee314jdbc.username=rootjdbc.password=1234 SqlMapConfig.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 加载 连接数据库的信息 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定 映射文件位置 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 方式二SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///ssm"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入 映射配置文件 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层 采用注解的方式 AccountDao1234567891011121314151617181920package cn.water.dao;import cn.water.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ @Select("select * from account") public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ @Insert("insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)") public abstract void add(Account account);&#125; 测试类TestMyBatis123456789101112131415161718192021222324252627282930313233343536373839package cn.water.test;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; @Test public void run01() throws Exception &#123; /* 加载 配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 建造者对象，获取 工厂对象 */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂对象，获取 Session对象 */ SqlSession sqlSession = sqlSessionFactory.openSession(); /* 通过 Session对象，获取 代理对象 */ AccountDao mapper = sqlSession.getMapper(AccountDao.class); /* 调用 持久层 */ List&lt;Account&gt; all = mapper.findAll(); /* 遍历 */ for (Account account : all) &#123; System.out.println(account); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果12Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（4）——Spring整合SpringMVC]]></title>
    <url>%2F2019%2F09%2F28%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%884%20SpringMVC%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring 整合 SpringMVC结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 监听器 配置 监听器（ContextLoaderListener） 配置 服务器启动时，加载配置文件（contextConfigLocation） 前端控制器 过滤器 web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 监听器 --&gt; &lt;!-- 服务器启动时，加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 前端控制器 --&gt; &lt;!-- 服务器启动时，DispatcherServlet对象被创建，加载SpringMVC配置文件 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 表现层 通过依赖反转获取 业务层对象，并执行业务层的方法，到达Spring与SpringMVC的整合。 AccountController.java123456789101112131415161718192021222324package cn.water.controller;import cn.water.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("accountController")public class AccountController &#123; @Autowired private AccountService service; @RequestMapping("findAll") public String findAll()&#123; /* 表现层 */ System.out.println("表现层：查询所有用户信息"); /* 业务层 */ service.findAll(); return "list"; &#125;&#125; 执行结果点击 index.jsp 页面，执行表现层中的findAll()，和业务层的findAll()，最后跳转到 list.jsp 页面。 12表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>SpringMVC</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（3）——SpringMVC框架环境搭建]]></title>
    <url>%2F2019%2F09%2F27%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%883%20SpringMVC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringMVC框架结构目录 java controller AccountController.java（表现层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 前端控制器 配置 前端控制器（DispatcherServlet） 配置 创建前端控制器时，加载配置文件（contextConfigLocation） 配置 服务器启动时，立即创建前端控制器（1） 配置 映射/作用范围（/） 过滤器 配置 过滤器（CharacterEncodingFilter） 配置 编码（UTF-8） 配置 映射/作用范围（/*） web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC配置文件 开启 注解扫描（context：component-scan） 只扫描表现层注解 配置 视图解析器（InternalResourceViewResolver） 配置 前端控制器（mvc：resource） 开启 SpringMVC注解支持（mvc：annotation-driven） springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启 注解扫描 --&gt; &lt;context:component-scan base-package="cn.water.controller"/&gt; &lt;!-- 配置 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 前端控制器 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 开启 SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 表现层AccountController.java 返回：list 12345678910111213141516171819package cn.water.controller;import cn.water.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping("accountController")public class AccountController &#123; @RequestMapping("findAll") public String findAll()&#123; System.out.println("表现层：查询所有用户信息"); return "list"; &#125;&#125; jsp页面index.jsp 执行表现层的方法，获得返回值“/WEB-INF/pages/list.jsp”，跳转页面 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; jsp页面 展示 list.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; #]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（2）——Spring框架环境搭建]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%882%20Spring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring框架结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） test TestSpring.java（测试文件） resources applicationContext.xml（Spring配置文件） Spring配置文件 开启注解扫描 忽略表现层注解 applicationContext.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;/beans&gt; JavaBean对象Accont.java12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 持久层 MyBatis框架生成代理对象，我们不需要创建实现类 AccountDao.java123456789101112131415package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; 业务层AccountService.java123456789101112131415package cn.water.service;import cn.water.domain.Account;import java.util.List;public interface AccountService &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; AccountServiceImp.java1234567891011121314151617181920212223package cn.water.service;import cn.water.domain.Account;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层：查询所有用户"); return null; &#125; /** 添加用户 */ @Override public void add(Account account) &#123; System.out.println("业务层：添加用户"); &#125;&#125; 测试TestSpring.java12345678910111213141516171819package cn.water.test;import cn.water.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void run01() &#123;// 加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");// 获取对象 AccountService as = (AccountService) ac.getBean("accountService");// 调用方法 as.findAll(); &#125;&#125; 运行结果1业务层：查询所有用户]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（1）——SSM框架环境搭建]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%881%20SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SSM框架整合结构目录 java resources log4j.properties（日志文件） pom.xml（Maven项目配置文件） Maven项目配置文件 Spring框架 spring-beans spring-core spring-context spring-context-support spring-aop aspectjweaver spring-org spring-test spring-tx SpringMVC框架 spring-web spring-webmvc 前端 servlet-api jsp-api jstl MyBatis框架 mybatis mybatis-spring 数据库 mysql-connector-java c3p0 日志 log4j slf4j slf4j-log4j12 测试 junit pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 核心（包括spring-core,spring-beans,spring-aop,spring-expression） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将第三方库整合进 Spring 应用上下文 提供支持（如缓存 caching , 邮件mailing , 计划任务scheduling） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP（动态代理 注解） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring 事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JSP标准标签库（EL表达式、JSTL标签） --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis（SSM整合） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; log日志文件 记录日志 log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring整合</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架07 —— 异常处理]]></title>
    <url>%2F2019%2F09%2F22%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%207%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目结构 java controller InterceptorController.java（Java文件） interceptor TestInterceptor01.java（JavaBean文件） TestInterceptor02.java（JavaBean文件） TestInterceptor03.java（JavaBean文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） error.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置拦截器（&lt;mvc:interceptors&gt;） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 执行代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section05_Interceptor&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section05_Interceptor Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section05_Interceptor&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/*"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor03"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;!-- 设置不拦截的方法 --&gt; &lt;!-- &lt;mvc:exclude-mapping path="/**"/&gt;--&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; InterceptorController.java12345678910111213141516171819202122232425package cn.water.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @author Water * @date 2019/10/3 - 20:51 */@Controller@RequestMapping("/Interceptor")public class InterceptorController &#123; @RequestMapping("/test01") public String test01()&#123; System.out.println("Controller01..."); return "success"; &#125; @RequestMapping("/test02") public String test02()&#123; System.out.println("Controller02..."); return "success"; &#125;&#125; TestInterceptor01.java123456789101112131415161718192021222324252627282930313233343536package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor01 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ /* true：放行。（执行下一个拦截器，或者执行Controller方法） * false：不放行。（通过Request和Response跳转） * */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125;&#125; TestInterceptor02.java123456789101112131415161718192021222324252627282930313233package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor02 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125;&#125; TestInterceptor03.java12345678910111213141516171819202122232425262728293031323334package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor03 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("--preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("--postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("--afterCompletion"); System.out.println("-----------------"); &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="Interceptor/test01"&gt;拦截器放行&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="Interceptor/test02"&gt;拦截器不放行&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;访问成功！！！&lt;/h1&gt; &lt;% System.out.println("success.jsp..."); %&gt;&lt;/body&gt;&lt;/html&gt; error.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;访问失败！！！&lt;/h2&gt; &lt;% System.out.println("error.jsp..."); %&gt;&lt;/body&gt;&lt;/html&gt; 拦截器——放行 配置拦截器 12345678&lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; Controller的方法 12345@RequestMapping("/test01")public String test01()&#123; System.out.println("Controller01..."); return "success";&#125; 运行结果 12345----preHandle...Controller01...----postHandle...success.jsp...----afterCompletion 拦截器——不放行 配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; Controller的方法 12345@RequestMapping("/test02")public String test02()&#123; System.out.println("Controller02..."); return "success";&#125; 运行结果 1error.jsp... 多个拦截器 配置拦截器 123456789101112131415161718192021222324&lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/*"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor03"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;!-- 设置不拦截的方法 --&gt; &lt;!-- &lt;mvc:exclude-mapping path="/**"/&gt;--&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器的方法 12345678910111213141516171819/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("--preHandle..."); return true;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("--postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("--afterCompletion"); System.out.println("-----------------");&#125; 放行 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125; 运行结果 123456789====preHandle...----preHandle...Controller01...----postHandle...====postHandle...success.jsp...----afterCompletion====afterCompletion=================== 不放行 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; 运行结果 1234====preHandle...error.jsp...====afterCompletion===================]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架06 —— 异常处理]]></title>
    <url>%2F2019%2F09%2F20%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%206%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目结构 java controller TestException.java（Java文件） exception ExceptionController.java（Java文件） TestExceptionResolver.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages error.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置异常处理器（TestExceptionResolver） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 执行代码 需求：在index.jsp页面，点击的超链接，跳转到error.jsp页面，并且在页面输出响应消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section04_Exception&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section04_Exception Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section04_Exception&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置异常处理器 --&gt; &lt;bean id="testExceptionResolver" class="cn.water.exception.TestExceptionResolver"&gt;&lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; ExceptionController.java1234567891011121314151617181920212223242526272829package cn.water.controller;import cn.water.exception.TestException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @author Water 自定义异常类 * @date 2019/10/3 - 19:47 */@Controller@RequestMapping("/exception")public class ExceptionController &#123; @RequestMapping("/test01") public String test01() throws TestException&#123; System.out.println("方法执行了"); try &#123; int error = 10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new TestException("出现TestException错误！"); &#125; return "success"; &#125;&#125; index.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="exception/test01/"&gt;异常处理&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; error.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;$&#123;errorMessage&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 异常处理 当Controller类出现异常时 123456789101112@RequestMapping("/test01") public String test01() throws TestException&#123; System.out.println("方法执行了"); try &#123; int error = 10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new TestException("出现TestException错误！"); &#125; return "success"; &#125; 自定义异常类 12345678910111213141516171819202122package cn.water.exception;public class TestException extends Exception &#123; /* 存储提示信息 */ private String message; /* Getter */ @Override public String getMessage() &#123; return message; &#125; /* Setter */ public void setMessage(String message) &#123; this.message = message; &#125; /* 构造方法（提供提示信息） */ public TestException(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器 123456789101112131415161718192021222324252627282930313233343536package cn.water.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water 自定义异常处理器 * @date 2019/10/3 - 20:01 */public class TestExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; /* 判断异常对象 */ TestException te = null; if (e instanceof TestException) &#123; te = (TestException)e; &#125;else &#123; te = new TestException("出现未知错误！"); &#125; /* 创建ModelAndView对象 */ ModelAndView mv = new ModelAndView(); /* 存储键值对 */ mv.addObject("errorMessage", te.getMessage()); /* 跳转到 error.jsp 页面 */ mv.setViewName("error"); /* 返回 */ return mv; &#125;&#125; 配置异常处理器 12 &lt;!-- 配置异常处理器 --&gt;&lt;bean id="testExceptionResolver" class="cn.water.exception.TestExceptionResolver"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架05 —— 文件上传]]></title>
    <url>%2F2019%2F09%2F15%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%205%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[项目结构（文件服务器） webapp uploads（图片存储位置） WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） 项目结构（应用服务器） java controller FileUploadController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api commons-fileupload commons-io jersey-core jersey-client web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） HttpServletRequest MultipartFile JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：通过服务器将图片上传至服务器端 在“应用服务器”中，上传图片。图片通过跨服务器操作，被存储到“文件服务器”中。 “文件服务器”只需要新建一个模板，并且配置一个tomcat服务器，在此需求中其配置文件不需要设置。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section03_FileUpload&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section03_FileUpload Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 跨服务器上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section03_FileUpload&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件解析器 --&gt; &lt;!-- 此id必须为multipartResolver --&gt; &lt;!-- 配置了文件解析器后，通过commons-fileupload组件的方法可以访问，无法上传。 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 配置上传文件字节数的最大值 --&gt; &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; FileUploadController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package cn.water.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;@Controller@RequestMapping("/fileUpload")public class FileUploadController &#123; /* 传统方式：通过 commons-fileupload组件 解析消息正文 */ @RequestMapping("/test01") public String testFileUpload(HttpServletRequest request,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 解析消息正文，获取上传文件项 */ DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List&lt;FileItem&gt; fileItems = upload.parseRequest(request); /* 判断是否为上传文件项 */ for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField())&#123; /* 表单项 */ &#125;else &#123; /* 上传文件项 */ /* 设置唯一的文件名称 */ String name = fileItem.getName(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ fileItem.write(new File(realPath,name)); /* 删除临时文件 */ fileItem.delete(); &#125; &#125; return "success"; &#125; /* SpringMVC传统方法：文件解析器来解析，我们只需要获取 MultipartFile对象 */ @RequestMapping("/test02") public String test02( HttpServletRequest request, MultipartFile picture,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 设置唯一的文件名称 */ String name = picture.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ picture.transferTo(new File(file,name)); return "success"; &#125; /* SpringMVC跨服务器上传 */ @RequestMapping("/test03") public String test03(MultipartFile picture,String picname) throws Exception &#123; /* 定义上传文件服务器的路径 */ String path = "http://localhost:9090/uploads/"; /* 设置唯一的文件名称 */ System.out.println(picture); String name = picture.getOriginalFilename();// String uuid = UUID.randomUUID().toString().replace("-", "");// name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(path); System.out.println(name); /* 创建客服端对象 */ Client client = Client.create(); /* 和图片服务器进行连接 */ WebResource resource = client.resource(path + name); /* 上传文件 */ resource.put(picture.getBytes()); return "success"; &#125;&#125; index.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;文件上传&lt;/h1&gt; &lt;hr&gt; &lt;h2&gt;传统方式：通过 commons-fileupload组件&lt;/h2&gt; &lt;form action="fileUpload/test01" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt; &lt;h2&gt;SpringMVC传统方法：文件解析器&lt;/h2&gt; &lt;form action="fileUpload/test02" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;%-- 和Controller中方法的MultipartFile参数的名称必须一致 --%&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt; &lt;h2&gt;SpringMVC跨服务器方法&lt;/h2&gt; &lt;form action="fileUpload/test03" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;%-- 和Controller中方法的MultipartFile参数的名称必须一致 --%&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;访问成功！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 传统方式 传统的文件上传方式通过 commons-fileupload组件 maven配置文件 12345678910&lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; Controller 123456789101112131415161718192021222324252627282930313233@RequestMapping("/test01") public String testFileUpload(HttpServletRequest request,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 解析消息正文，获取上传文件项 */ DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List&lt;FileItem&gt; fileItems = upload.parseRequest(request); /* 判断是否为上传文件项 */ for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField())&#123; /* 表单项 */ &#125;else &#123; /* 上传文件项 */ /* 设置唯一的文件名称 */ String name = fileItem.getName(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ fileItem.write(new File(realPath,name)); /* 删除临时文件 */ fileItem.delete(); &#125; &#125; return "success"; &#125; SpringMVC方式 文件解析器来解析，我们只需要获取 MultipartFile对象 SpringMVC配置文件 1234567&lt;!-- 文件解析器 --&gt; &lt;!-- 此id必须为multipartResolver --&gt; &lt;!-- 配置了文件解析器后，通过commons-fileupload组件的方法可以访问，无法上传。 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 配置上传文件字节数的最大值 --&gt; &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt;&lt;/bean&gt; Controller 12345678910111213141516171819@RequestMapping("/test02")public String test02( HttpServletRequest request, MultipartFile picture,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 设置唯一的文件名称 */ String name = picture.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ picture.transferTo(new File(file,name)); return "success";&#125; 跨服务器上传 Maven配置文件 12345678910&lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; SpringMVC配置文件 1234567891011&lt;!-- 跨服务器上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; Controller 1234567891011121314151617181920212223 @RequestMapping("/test03") public String test03(MultipartFile picture,String picname) throws Exception &#123; /* 定义上传文件服务器的路径 */ String path = "http://localhost:9090/uploads/"; /* 设置唯一的文件名称 */ System.out.println(picture); String name = picture.getOriginalFilename();// String uuid = UUID.randomUUID().toString().replace("-", "");// name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(path); System.out.println(name); /* 创建客服端对象 */ Client client = Client.create(); /* 和图片服务器进行连接 */ WebResource resource = client.resource(path + name); /* 上传文件 */ resource.put(picture.getBytes()); return "success"; &#125; tomcat配置文件 （D:\coding\Tomcat\apache-tomcat-8.5.45\conf\web.xml）123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架04 —— 响应数据类型]]></title>
    <url>%2F2019%2F09%2F10%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%204%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[项目结构 java controller ResponseController.java（Java文件） domain User.java（JavaBean文件） resources springmvc.xml（springmvc配置文件） webapp css images js jquery.min.js（js文档） WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） jquery.jsp（web页面） response.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api jackson-databind jackson-core jackson-annotations web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置前端控制器（&lt;mvc:resource &gt;） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） HttpServletRequest：获取Request、Session，用于请求转发、获取Request URI HttpServletResponse：获取Response，用于重定向、设置中文乱码 JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在response.jsp页面，点击的超链接，跳转到success.jsp页面，并且在页面输出响应消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section02_Response&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section02_Response Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Jackson：用于Ajax异步请求，将Json类型数据转化为JavaBean类型 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section02_Response&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 前端控制器（设置免拦截的静态资源） --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;!-- js --&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 样式 --&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; ResponseController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package cn.water.controller;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author Water * @date 2019/9/11 - 20:16 */@Controller@RequestMapping("/response")public class ResponseController &#123; /* 【返回值：String】 */ @RequestMapping("/testString") public String testString(Model model)&#123;// 获取用户对象 User user = new User(); user.setUsername("cat"); user.setPassword("111"); user.setAge(1);// 将用户对象添加至Request域中 model.addAttribute("user",user); return "success"; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid111") public void testVoid111(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 请求转发（不执行视图解析器） request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); return; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid222") public void testVoid222(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 重定向（不执行视图解析器，不能访问WEB-INF目录下页面） response.sendRedirect(request.getContextPath()+"/index.jsp"); return; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid333") public void testVoid333(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 设置中文乱码 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charaset=UTF-8");// 直接响应 response.getWriter().print("你好呀！"); return; &#125; /* 【返回值：ModelAndView】 */ @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response)&#123;// 获取对象 ModelAndView modelAndView = new ModelAndView();// 获取用户对象 User user = new User(); user.setUsername("dog"); user.setPassword("222"); user.setAge(2);// 将用户对象添加至Request域中 modelAndView.addObject("user",user);// 设置跳转页面（执行视图解析器） modelAndView.setViewName("success"); return modelAndView; &#125; /* 【关键字】 */ @RequestMapping("/testForward") public String testForward()&#123; System.out.println("forward"); return "forward:/WEB-INF/pages/success.jsp"; &#125; /* 【关键字】 */ @RequestMapping("/testRedirect") public String testRedirect(HttpServletRequest request)&#123; System.out.println("redirect"); String contextPath = request.getContextPath(); /* 原本我们是要加上项目路径，但是SpringMVC框架帮我们自动添加了，所以我们只需要填写文件名 */// return "redirect:"+contextPath+"/index.jsp"; return "redirect:/index.jsp"; &#125; /* 【Ajax异步请求】 */ @RequestMapping("/testAjax") public @ResponseBody User testAjax( @RequestBody User user)&#123; /* 获取网页发送的数据 */ System.out.println("用户对象："+user); /* 设置数据 */ user.setUsername("dog"); user.setPassword("222"); user.setAge(2); /* 将数据返回给网页 */ return user; &#125;&#125; User.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.domain;/** * @author Water * @date 2019/9/11 - 20:19 */public class User &#123; private String username; private String password; private Integer age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="response.jsp"&gt;响应消息页面&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="jquery.jsp"&gt;静态资源页面&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; response.jsp1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;%-- 引入js资源 --%&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; /* 绑定单击事件 */ $("#btn1").click(function () &#123; &lt;%-- 【发送Ajax请求】 --%&gt; $.ajax(&#123; url:"response/testAjax", /* 发送请求的地址 */ contentType:"application/json;charset=UTF-8", /* 发送信息至服务器时内容编码类型 */ data:'&#123;"username":"cat","password":"111","age":"1"&#125;', /* 发送到服务器的数据 */ dataType:"json", /* 预期服务器返回的数据类型 */ type:"post", /* 请求方式 */ success:function (data) &#123; document.write("&lt;h3&gt;"+data+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.username+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.password+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.age+"&lt;/h3&gt;"); &#125; /* 请求成功后的回调函数 */ &#125;) &#125;) /* 绑定单击事件 */ $("#btn2").click(function () &#123; &lt;%-- 【弹出提示信息】 --%&gt; alert("hello,Ajax."); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn2"&gt;弹出提示信息&lt;/button&gt; &lt;button id="btn1"&gt;发送Ajax请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jquery.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="response/testString"&gt;String&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid111"&gt;void：请求转发&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid222"&gt;void：重定向&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid333"&gt;void：直接响应&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testModelAndView"&gt;ModelAndView&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testForward"&gt;Forward&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testRedirect"&gt;Redirect&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功访问！！！&lt;/h1&gt; &lt;br&gt; &lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt; &lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;%-- requestScope可以省略 --%&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt; &lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 方法返回值：String 发起请求 1&lt;a href="response/testString"&gt;String&lt;/a&gt; 接收请求，发出响应 1234567891011 @RequestMapping("/testString") public String testString(Model model)&#123;// 获取用户对象 User user = new User(); user.setUsername("cat"); user.setPassword("111"); user.setAge(1);// 将用户对象添加至Request域中 model.addAttribute("user",user); return "success"; &#125; 响应页面 1234567&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：User&#123;username=&apos;cat&apos;, password=&apos;111&apos;, age=1&#125;获取用户名：cat获取密码：111获取年龄：1 方法返回值：void请求转发 发起请求 1&lt;a href="response/testVoid111"&gt;void：请求转发&lt;/a&gt; 接收请求，发起响应 123456 @RequestMapping("/testVoid111") public void testVoid111(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 请求转发（不执行视图解析器） request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); return; &#125; 响应结果 123456成功访问！！！获取Request域中的用户对象：获取用户名：获取密码：获取年龄： 重定向 发起请求 1&lt;a href="response/testVoid222"&gt;void：重定向&lt;/a&gt; 接收请求，发出响应 123456 @RequestMapping("/testVoid222") public void testVoid222(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;// 重定向（不执行视图解析器，不能访问WEB-INF目录下页面） response.sendRedirect(request.getContextPath()+"/index.jsp"); return; &#125; 响应结果 12响应消息页面静态资源页面 直接响应 发起请求 1&lt;a href="response/testVoid333"&gt;void：直接响应&lt;/a&gt; 接收请求 123456789 @RequestMapping("/testVoid333") public void testVoid333( HttpServletResponse response) throws IOException &#123;// 设置中文乱码 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charaset=UTF-8");// 直接响应 response.getWriter().print("你好呀！"); return; &#125; 响应结果 1你好呀！ ModelAndView 发起请求 1&lt;a href="response/testModelAndView"&gt;ModelAndView&lt;/a&gt; 接收请求，发出响应 123456789101112131415 @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response)&#123;// 获取对象 ModelAndView modelAndView = new ModelAndView();// 获取用户对象 User user = new User(); user.setUsername("dog"); user.setPassword("222"); user.setAge(2);// 将用户对象添加至Request域中 modelAndView.addObject("user",user);// 设置跳转页面（执行视图解析器） modelAndView.setViewName("success"); return modelAndView; &#125; 响应页面 1234567&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：User&#123;username=&apos;dog&apos;, password=&apos;222&apos;, age=2&#125;获取用户名：dog获取密码：222获取年龄：2 Spring框架关键字Forward 发起请求 1&lt;a href="response/testForward"&gt;Forward&lt;/a&gt; 接收请求，发出响应 12345@RequestMapping("/testForward")public String testForward()&#123; System.out.println("forward"); return "forward:/WEB-INF/pages/success.jsp";&#125; 响应页面 123456&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：获取用户名：获取密码：获取年龄： Redirect 发起请求 1&lt;a href="response/testRedirect"&gt;Redirect&lt;/a&gt; 接收请求，发出响应 12345678@RequestMapping("/testRedirect")public String testRedirect(HttpServletRequest request)&#123; System.out.println("redirect"); String contextPath = request.getContextPath(); /* 原本我们是要加上项目路径，但是SpringMVC框架帮我们自动添加了，所以我们只需要填写文件名 */ // return "redirect:"+contextPath+"/index.jsp"; return "redirect:/index.jsp";&#125; 响应结果 12响应消息页面静态资源页面 Ajax 异步请求 发起请求 123456789101112131415161718192021222324252627282930&lt;script&gt; $(function () &#123; /* 绑定单击事件 */ $("#btn1").click(function () &#123; &lt;%-- 【发送Ajax请求】 --%&gt; $.ajax(&#123; /* 发送请求的地址 */ url:"response/testAjax", /* 发送信息至服务器时内容编码类型 */ contentType:"application/json;charset=UTF-8", /* 发送到服务器的数据 */ data:'&#123;"username":"cat","password":"111","age":"1"&#125;', /* 预期服务器返回的数据类型 */ dataType:"json", /* 请求方式 */ type:"post", /* 请求成功后的回调函数 */ success:function (data) &#123; document.write("&lt;h3&gt;"+data+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.username+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.password+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.age+"&lt;/h3&gt;"); &#125; &#125;) &#125;) &#125;)&lt;/script&gt;&lt;body&gt; &lt;button id="btn1"&gt;发送Ajax请求&lt;/button&gt;&lt;/body&gt; 接收请求，发出响应 1234567891011@RequestMapping("/testAjax")public @ResponseBody User testAjax( @RequestBody User user)&#123; /* 获取网页发送的数据 */ System.out.println("用户对象："+user); /* 设置数据 */ user.setUsername("dog"); user.setPassword("222"); user.setAge(2); /* 将数据返回给网页 */ return user;&#125; 响应结果 1234[object Object]dog2222]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架03 —— 注解]]></title>
    <url>%2F2019%2F09%2F07%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%203%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[项目结构 java controller SessionController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） session.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） annotation.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 设置Session域的键值对（@SessionAttributes()） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） Model：用于存储键值对至Request域 ModelMap：用于获取Request域中的键值对 SessionStatus：用于清空Session域中的键值对 设置初始化方法（@ModelAttribute） 方法参数 获取请求参数（@RequestParam()） 二级目录：”/testRequestParam” 请求地址：”anno/testRequestParam?name=cat” 获取请求参数（@PathVariable()） 二级目录：”/testPathVariable/{name}” 请求地址：”anno/testPathVariable/cat” 获取请求体（@RequestBody） 获取请求头（@RequestHeader） 获取缓存（@CookieValue()） 获取底层Map集合的键值对（@ModelAttribute()） 设置Session域的键值对（@SessionAttributes()） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在annotation.jsp页面，点击的超链接，跳转到success.jsp页面，并且在控制台输出请求消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; AnnotationController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.water.controller;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.*;import org.springframework.web.bind.support.SessionStatus;import java.util.Map;/** * @author Water * @date 2019/9/10 - 10:48 */@Controller@RequestMapping("/anno")/* 将键值对存储到session域 */@SessionAttributes("message")public class AnnotationController &#123; /* 【获取请求参数】 */ @RequestMapping("/testRequestParam") public String testRequestParam(@RequestParam(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success"; &#125; /* 【获取请求参数】 */ @RequestMapping("/testPathVariable/&#123;name&#125;") public String testPathVariable(@PathVariable(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success"; &#125; /* 【获取请求体（GET请求方式没有请求体）】 */ @RequestMapping("/testRequestBody") public String testRequestBody(@RequestBody String body )&#123; System.out.println("请求体："+body); return "success"; &#125; /* 【获取请求头】 */ @RequestMapping("/testRequestHeader") public String testRequestHeader(@RequestHeader(value = "Accept") String header )&#123; System.out.println("请求头："+header); return "success"; &#125; /* 【Cookie】 */ @RequestMapping("/testCookieValue") public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue )&#123; System.out.println("Cookie："+cookieValue); return "success"; &#125; /* 【ModelAttribute】 */ /* 用于将表单提交的数据封装至JavaBean对象时，当时当数据不全时，使用ModelAttribute注释的方法将数据补全 */// [方法一]// @RequestMapping("/testModelAttribute")// public String testModelAttribute(User user)&#123;// System.out.println("testModelAttribute执行了...");// System.out.println(user);// return "success";// &#125;// @ModelAttribute /* 先执行 */// public User ModelAttributeMethod(String name)&#123;// System.out.println("ModelAttributeMethod执行了...");// User user = new User();// user.setName(name);// user.setAge("11");// return user;// &#125;// [方法二] @RequestMapping("/testModelAttribute") public String testModelAttribute(@ModelAttribute("user_name") User user)&#123; System.out.println("testModelAttribute执行了..."); System.out.println(user); return "success"; &#125; /* 将User对象存储进底层的Map集合中 */ @ModelAttribute /* 先执行 */ public void ModelAttributeMethod(String username, Map&lt;String,User&gt; map)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(username); user.setAge("11"); map.put("user_name",user); &#125; @RequestMapping("testSessionAttributes") public String testSessionAttributes(Model model)&#123; /* 将键值对存储到request域 */ model.addAttribute("message","Hello,Request Field!"); return "session"; &#125; @RequestMapping("getSessionAttributes") public String getSessionAttributes(ModelMap modelMap)&#123; /* 获取Session域中的值 */ Object message = modelMap.get("message"); System.out.println(message); return "session"; &#125; @RequestMapping("removeSessionAttributes") public String removeSessionAttributes(SessionStatus sessionStatus)&#123; /* 清空Session域中的值 */ sessionStatus.setComplete(); return "session"; &#125;&#125; index.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="controller/sayHello?username=cat"&gt;入门&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="parameters.jsp"&gt;参数绑定&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="annotation.jsp"&gt;注解&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; annotation.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%-- Created by IntelliJ IDEA. User: Water Date: 2019/9/19 Time: 14:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 请求参数 --%&gt; &lt;h3&gt;&lt;a href="anno/testRequestParam?name=cat&amp;name=dog&amp;name=rat"&gt;获取 请求参数（RequestParam）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 请求参数 --%&gt; &lt;%--&lt;a href="anno/testRequestParam?name=cat"&gt;请点击&lt;/a&gt;--%&gt; &lt;a href="anno/testPathVariable/cat"&gt;获取 请求参数（PathVariable）&lt;/a&gt; // "cat" &lt;br&gt; &lt;a href="anno/testPathVariable/cat&amp;dog"&gt;获取 请求参数（PathVariable）&lt;/a&gt; // "cat&amp;dog" &lt;hr&gt; &lt;%-- 请求体 --%&gt; &lt;form action="anno/testRequestBody" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; &lt;input type="submit" value="获取 请求体（RequestBody）"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 请求头 --%&gt; &lt;h3&gt;&lt;a href="anno/testRequestHeader"&gt;获取 请求头（RequestHeader）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 缓存 --%&gt; &lt;h3&gt;&lt;a href="anno/testCookieValue"&gt;获取 缓存（CookieValue）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- ModelAttribute --%&gt; &lt;form action="anno/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; &lt;input type="submit" value="ModelAttribute"&gt; &lt;/form&gt; &lt;hr&gt; &lt;a href="anno/testSessionAttributes"&gt;设置，并在浏览器查看Request域和Session域中的message值&lt;/a&gt;&lt;br&gt; &lt;a href="anno/getSessionAttributes"&gt;在控制台查看Session域中的message值&lt;/a&gt;&lt;br&gt; &lt;a href="anno/removeSessionAttributes"&gt;删除，并在浏览器查看Session域中的message值&lt;/a&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; session.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Request域：&lt;/h1&gt;$&#123;requestScope.message&#125;&lt;br&gt; &lt;h1&gt;Session域：&lt;/h1&gt;$&#123;sessionScope&#125;&lt;/body&gt;&lt;/html&gt; @RequestParam 请求参数 发出请求 1&lt;a href="anno/testRequestParam?name=cat&amp;name=dog&amp;name=rat"&gt;获取 请求参数（RequestParam）&lt;/a&gt; 接收请求 12345@RequestMapping("/testRequestParam")public String testRequestParam(@RequestParam(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success";&#125; 运行结果 1请求参数：cat,dog,rat @PathVariable 请求参数 发出请求 12&lt;a href="anno/testPathVariable/cat"&gt;获取 请求参数（PathVariable）&lt;/a&gt; &lt;br&gt;&lt;a href="anno/testPathVariable/cat&amp;dog"&gt;获取 请求参数（PathVariable）&lt;/a&gt; 接收请求 12345@RequestMapping("/testPathVariable/&#123;name&#125;")public String testPathVariable(@PathVariable(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success";&#125; 运行结果 12请求参数：cat请求参数：cat&amp;dog @RequestBody 请求体 发出请求 123456&lt;form action="anno/testRequestBody" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; &lt;input type="submit" value="获取 请求体（RequestBody）"&gt;&lt;/form&gt; 接收请求 123456/* 【GET请求方式没有请求体】 */@RequestMapping("/testRequestBody")public String testRequestBody(@RequestBody String body )&#123; System.out.println("请求体："+body); return "success";&#125; 运行结果 1请求体：username=cat&amp;password=111&amp;money=999 @RequestHeader 请求头 发出请求 1&lt;a href="anno/testRequestHeader"&gt;获取 请求头（RequestHeader）&lt;/a&gt; 接收请求 12345@RequestMapping("/testRequestHeader")public String testRequestHeader(@RequestHeader(value = "Accept") String header )&#123; System.out.println("请求头："+header); return "success";&#125; 运行结果 1请求头：text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 @CookieValue 缓存 发出请求 1&lt;a href="anno/testCookieValue"&gt;获取 缓存（CookieValue）&lt;/a&gt; 接收请求 12345@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue )&#123; System.out.println("Cookie："+cookieValue); return "success";&#125; 运行结果 1Cookie：93E4FB2388E1A6249DA4552C947FE2C2 @ModelAttribute 发出请求 1234&lt;form action="anno/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; &lt;input type="submit" value="ModelAttribute"&gt;&lt;/form&gt; 接收请求 12345678910111213141516@RequestMapping("/testModelAttribute") public String testModelAttribute(User user)&#123; System.out.println("testModelAttribute执行了..."); System.out.println(user); return "success";&#125;/* 直接返回User对象 */@ModelAttribute /* 先执行 */public User ModelAttributeMethod(String name)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(name); user.setAge("11"); return user;&#125; 运行结果 123ModelAttributeMethod执行了...testModelAttribute执行了...User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125; 方法二 接收请求123456789/* 将User对象存储进底层的Map集合中 */@ModelAttributepublic void ModelAttributeMethod(String username, Map&lt;String,User&gt; map)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(username); user.setAge("11"); map.put("user_name",user);&#125; 设置域 发出请求 1&lt;a href="anno/testSessionAttributes"&gt;设置，并在浏览器查看Request域和Session域中的message值&lt;/a&gt; 接收请求 123456@RequestMapping("testSessionAttributes")public String testSessionAttributes(Model model)&#123; /* 将键值对存储到request域 */ model.addAttribute("message","Hello,Request Field!"); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果12Request域：Hello,Request Field!Session域：&#123;message=Hello,Request Field!&#125; 查看域 发出请求 1&lt;a href="anno/getSessionAttributes"&gt;在控制台查看Session域中的message值&lt;/a&gt; 接收请求 1234567@RequestMapping("getSessionAttributes")public String getSessionAttributes(ModelMap modelMap)&#123; /* 获取Session域中的值 */ Object message = modelMap.get("message"); System.out.println(message); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果 12Request域：Hello,Request Field!Session域：&#123;message=Hello,Request Field!&#125; 运行结果 1Hello,Request Field! 删除域 发出请求 1&lt;a href="anno/removeSessionAttributes"&gt;删除，并在浏览器查看Session域中的message值&lt;/a&gt; 接收请求 123456@RequestMapping("removeSessionAttributes")public String removeSessionAttributes(SessionStatus sessionStatus)&#123; /* 清空Session域中的值 */ sessionStatus.setComplete(); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果12Request域：Session域：&#123;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架02 —— 参数绑定]]></title>
    <url>%2F2019%2F09%2F03%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%202%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[项目结构 java controller ParameterController.java（Java文件） utils StringToData（自定义类型转换文件） domain User（JavaBean本件） Account（JavaBean本件） CCollection（JavaBean本件） DDate（JavaBean本件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） parameters.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置类型转换器（ConversionServiceFactoryBean） 注册自定义类型转换器 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在parameters.jsp页面，点击的超链接，跳转到success.jsp页面，并且在控制台输出请求参数。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 类型转换器 --&gt; &lt;bean id="conversionServiceFactoryBean" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- Configure the set of custom converter objects that should be added --&gt; &lt;property name="converters"&gt; &lt;!-- Set集合 --&gt; &lt;set&gt; &lt;!-- 添加自定义实现类 --&gt; &lt;bean class="cn.water.utils.StringToDate"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"/&gt;&lt;/beans&gt; StringToDate.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.utils;import org.springframework.core.convert.converter.Converter;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Water * @date 2019/9/10 - 8:53 */public class StringToDate implements Converter&lt;String, Date&gt; &#123; /** * * @param source * @return */ @Override public Date convert(String source) &#123;// 判断输入数据是否为空 if (source == null)&#123; throw new RuntimeException("请您输入日期"); &#125; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");// 转换格式 try &#123; return dateFormat.parse(source); &#125; catch (Exception e) &#123; System.out.println("请您输入正确的日期格式（yyyy-MM-dd）"); throw new RuntimeException("请您输入正确的日期格式（yyyy-MM-dd）"); &#125; &#125;&#125; ParameterController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package cn.water.controller;import cn.water.domain.Account;import cn.water.domain.CCollection;import cn.water.domain.DDate;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.List;import java.util.Map;@Controller@RequestMapping("/parameter")public class parameterController &#123; /* 获取数据 */ @RequestMapping("/testParameter") public String testParameter(String cat,String dog,String rat)&#123; System.out.println("1、方法执行了"); System.out.println("2、获取参数："+cat+dog+rat); return "success"; &#125; /* 获取数据，并封装至JavaBean（User）中。 */ @RequestMapping("/testJavaBean") public String testJavaBean(User user)&#123; System.out.println(user.toString() ); return "success"; &#125; /* 获取数据，并封装至JavaBean中，且此JavaBean（Account）含有其他JavaBean对象（User）。 */ @RequestMapping("/testJavaBean222") public String testJavaBean2(Account account)&#123; System.out.println(account.toString() ); return "success"; &#125; /* 获取数据，并封装至JavaBean中，且此JavaBean（Account）含有List集合、Map集合。 */ @RequestMapping("/testCollection") public String testCollection(CCollection cCollection)&#123; System.out.println(cCollection); return "success"; &#125; /* 获取字符串数据，自动转换为日期类型数据（Spring框架自动转换器） */ @RequestMapping("/testDate") public String testDate(DDate date)&#123; System.out.println("Date:"+date); return "success"; &#125; /* 获取Servlet原生API */ @RequestMapping("/testServlet") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123;// Request对象 System.out.println("【Request】"+request);// Response对象 System.out.println("【Response】"+response);// Session对象 HttpSession session = request.getSession(); System.out.println("【Session】"+session);// ServletContext对象 ServletContext servletContext = session.getServletContext(); System.out.println("【ServletContext】"+servletContext); return "success"; &#125;&#125; index.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="controller/sayHello?username=cat"&gt;入门&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="parameters.jsp"&gt;参数绑定&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="annotation.jsp"&gt;注解&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; parameters.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 普通类型 --%&gt; &lt;h3&gt;&lt;a href="parameter/testParameter?cat=11&amp;dog=22&amp;rat=33"&gt;封装至 普通数据类型&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean --%&gt; &lt;form action="parameter/testJavaBean" method="post"&gt; &lt;%-- post请求方式中文会乱码，get请求方式不会 --%&gt; 姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有JavaBean --%&gt; &lt;form action="parameter/testJavaBean222" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; 用户姓名：&lt;input type="text" name="user.name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="user.age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有JavaBean"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有集合 --%&gt; &lt;form action="parameter/testCollection" method="post"&gt; &lt;%-- List&lt;User&gt; list[0]==User --%&gt; 用户姓名：&lt;input type="text" name="list[0].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="list[0].age" /&gt;&lt;br/&gt; &lt;%-- Map&lt;String,User&gt; 'one'==String --%&gt; 用户姓名：&lt;input type="text" name="map['one'].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="map['one'].age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有List集合和Map集合"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有Data类型 --%&gt; &lt;%-- 网页中input标签的Test属性的文本框中输入数据类型一定是字符串形式 --%&gt; &lt;%-- 默认配置下，String框架自动将请求的字符串格式自动转换为JavaBean中对应的格式，但是对于文本格式有所要求，例如日期 --%&gt; &lt;%-- 默认正确日期格式：2019/01/01 --%&gt; &lt;%-- 自定义正确日期格式：2019-01-01 --%&gt; &lt;form action="parameter/testDate" method="post"&gt; 日期：&lt;input type="text" name="date" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 日期类型"&gt; &lt;/form&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 获取请求数据封装至 普通数据类型普通数据类型 发送请求 1&lt;a href="parameter/testParameter?cat=11&amp;dog=22&amp;rat=33"&gt;封装至 普通数据类型&lt;/a&gt; 接收请求 123456@RequestMapping("/testParameter")public String testParameter(String cat,String dog,String rat)&#123; System.out.println("1、方法执行了"); System.out.println("2、获取参数："+cat+dog+rat); return "success";&#125; 运行结果 121、方法执行了2、获取参数：112233 封装至 JavaBean类型JavaBean类型 数据类型 123456789101112131415161718192021222324252627282930313233package cn.water.domain;import java.io.Serializable;public class User implements Serializable &#123; private String name; private String age; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 发送请求 123456&lt;form action="parameter/testJavaBean" method="post"&gt; &lt;%-- post请求方式中文会乱码，get请求方式不会 --%&gt; 姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testJavaBean")public String testJavaBean(User user)&#123; System.out.println(user.toString() ); return "success";&#125; 运行结果 1User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125; 含有JavaBean 数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private String username; private String password; private Double money; private User user; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String toString() &#123; return "Account&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", money=" + money + ", user=" + user + '&#125;'; &#125;&#125; 发送请求 12345678&lt;form action="parameter/testJavaBean222" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; 姓名：&lt;input type="text" name="user.name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="user.age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有JavaBean"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testJavaBean222")public String testJavaBean2(Account account)&#123; System.out.println(account.toString() ); return "success";&#125; 运行结果 1Account&#123;username=&apos;cat&apos;, password=&apos;123695&apos;, money=999.0, user=User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125;&#125; 含有List集合和Map集合 数据类型 1234567891011121314151617181920212223242526272829303132333435package cn.water.domain;import java.io.Serializable;import java.util.List;import java.util.Map;public class CCollection implements Serializable &#123; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; @Override public String toString() &#123; return "CCollection&#123;" + "list=" + list + ", map=" + map + '&#125;'; &#125; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125;&#125; 发送请求 123456789&lt;form action="parameter/testCollection" method="post"&gt; &lt;%-- List&lt;User&gt; list[0]==User --%&gt; 用户姓名：&lt;input type="text" name="list[0].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="list[0].age" /&gt;&lt;br/&gt; &lt;%-- Map&lt;String,User&gt; 'one'==String --%&gt; 用户姓名：&lt;input type="text" name="map['one'].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="map['one'].age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有List集合和Map集合"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testCollection")public String testCollection(CCollection cCollection)&#123; System.out.println(cCollection); return "success";&#125; 运行结果 1CCollection&#123;list=[User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125;], map=&#123;one=User&#123;name=&apos;dog&apos;, age=&apos;22&apos;&#125;&#125;&#125; 封装至 日期类型日期类型 数据类型 12345678910111213141516171819202122232425package cn.water.domain;import java.io.Serializable;import java.util.Date;public class DDate implements Serializable &#123; private Date date; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Override public String toString() &#123; return "DDate&#123;" + "date=" + date + '&#125;'; &#125;&#125; 自定义类型转换器 1234567891011121314151617181920212223242526272829package cn.water.utils;import org.springframework.core.convert.converter.Converter;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class StringToDate implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123;// 判断输入数据是否为空 if (source == null)&#123; throw new RuntimeException("请您输入日期"); &#125; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");// 转换格式 try &#123; return dateFormat.parse(source); &#125; catch (Exception e) &#123; throw new RuntimeException("请您输入正确的日期格式（yyyy-MM-dd）"); &#125; &#125;&#125; 发送请求 12345678&lt;%-- 网页中input标签的Test属性的文本框中输入数据类型一定是字符串形式 --%&gt;&lt;%-- 默认配置下，String框架自动将请求的字符串格式自动转换为JavaBean中对应的格式，但是对于文本格式有所要求，例如日期 --%&gt;&lt;%-- 正确日期格式：2019/01/01 --%&gt;&lt;%-- 错误日期格式：2019-01-01; 2019：01：01 --%&gt;&lt;form action="parameter/testDate" method="post"&gt; 日期：&lt;input type="text" name="date" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 日期类型"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testDate")public String testDate(DDate date)&#123; System.out.println("Date:"+date); return "success";&#125; 运行结果 12输入：2011-9-1 10:25:45结果：Date:DDate&#123;date=Thu Sep 01 10:25:45 CST 2011&#125; 获取Servlet原生APIRequestResponseSessionServletContext 发送请求 1&lt;a href="parameter/testServlet"&gt;请点击&lt;/a&gt; 接收请求 123456789101112131415 @RequestMapping("/testServlet") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123;// Request对象 System.out.println("【Request】"+request);// Response对象 System.out.println("【Response】"+response);// Session对象 HttpSession session = request.getSession(); System.out.println("【Session】"+session);// ServletContext对象 ServletContext servletContext = session.getServletContext(); System.out.println("【ServletContext】"+servletContext); return "success"; &#125; 运行结果 1234【Request】org.apache.catalina.connector.RequestFacade@736f0cc【Response】org.apache.catalina.connector.ResponseFacade@3755e816【Session】org.apache.catalina.session.StandardSessionFacade@56651c25【ServletContext】org.apache.catalina.core.ApplicationContextFacade@4dc6868]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架01 —— 入门案例]]></title>
    <url>%2F2019%2F09%2F01%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%201%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[项目结构 java controller HelloController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） JSP文件 超链接（href=”一级目录/二级目录”） 执行代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"/&gt;&lt;/beans&gt; HellowController.java12345678910111213141516171819package cn.water.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller /* 将此类添加进IoC核心容器 */@RequestMapping(path = "/controller",method = &#123;RequestMethod.GET&#125;,params = &#123;"username=cat"&#125;,headers = &#123;"Accept"&#125;) /* 设置一级目录 */ /* 设置允许访问的请求方法 */ /* 设置必需的参数和值 */ /* 设置必需的请求头 */public class HelloController &#123; @RequestMapping("/sayHello") /* 设置二级目录 */ public String sayHello()&#123; System.out.printf("Hello StringMVC"); return "success"; &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门&lt;/h3&gt; &lt;a href="controller/sayHello?username=cat"&gt;请点击&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架12 —— 事务管理案例]]></title>
    <url>%2F2019%2F08%2F26%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F13.Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[简介 本文将在 Spring 框架中，分别使用使用“XML”，“XML+注释”和“注解+Java”三种方式来演示数据库的转账操作。 项目环境数据库代码 创建数据库spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE spring;# 使用数据库USE spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); Maven依赖pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 &lt;dependencies&gt; &lt;!-- Spring 框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring JDBC框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 事务管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 【被 Spring JDBC 代替】 --&gt; &lt;!-- 数据库连接池 --&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;c3p0&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;c3p0&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;0.9.1.2&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- 【被 Spring JDBC 代替】 --&gt; &lt;!-- 操作数据库的工具包 --&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.4&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- Spring 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Spring配置文件12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;/beans&gt; 实体类Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Account &#123; /* 成员变量 */ private int id; private String name; private float money; /* 构造函数 */ public Account() &#123; &#125; public Account(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getMoney() &#123; return money; &#125; public void setMoney(float money) &#123; this.money = money; &#125; /* toString方法 */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 持久层接口AccountDao.java1234567891011121314public interface AccountDao &#123; /** 查询所有 */ List&lt;Account&gt; findAll(); /** 查询单个 */ Account findByID(int id); /** 添加 */ void add(Account account); /** 修改 */ void update(Account account); /** 删除 */ void delete(int id);&#125; 业务层接口AccountService.java1234567public interface AccountService &#123; /** 转账 */ void transfer(int sourceId, int targetId, float money);&#125; 测试类junit1234567891011121314151617181920212223242526import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import xml.service.AccountService;public class SpringTest &#123; /* 成员变量 */ private ApplicationContext app; private AccountService service; @Before public void init()&#123; app = new ClassPathXmlApplicationContext("xml/Beans.xml"); service = app.getBean("serviceImp",AccountService.class); &#125; /** 转账 */ @Test public void test01() &#123; service.transfer(1,2,10f); &#125;&#125; Spring整合junit1234567891011121314151617181920212223242526import java_anno.config.SpringConfiguration;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java_anno.service.AccountService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class SpringTest &#123; /* 成员变量 */ @Autowired private AccountService service; /** 查询所有 */ @Test public void test01() &#123; service.transfer(1,2,10f); &#125;&#125; 基于XML配置文件此部分分为三部分 目录结构：帮助了解整个项目的基本结构，以及完整详细的代码。 依赖注入：此部分是本文着重比较的地方，单独分为一部分。 CURD操作：与Spring框架的核心内容关系不大，可作为延展内容。 目录结构 src main java service AccountServiceImp.java（业务层实现类） dao AccountDaoImp.java（持久层实习类） resources Beans.xml（Spring配置文件） 持久层实现类 操作数据库 继承 JdbcDaoSupport 注入 DataSource AccountDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package xml.dao;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import xml.domain.Account;import java.util.List;public class AccountDaoImp extends JdbcDaoSupport implements AccountDao &#123; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return super.getJdbcTemplate().query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125; /** 查询单个 */ public Account findByID(int id) &#123; return super.getJdbcTemplate().queryForObject( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); &#125; /** 添加 */ public void add(Account account) &#123; super.getJdbcTemplate().update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; /** 修改 */ public void update(Account account) &#123; super.getJdbcTemplate().update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; /** 删除 */ public void delete(int id) &#123; super.getJdbcTemplate().update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125;&#125; 业务层实现类 调用持久层方法 基于xml的方式注入 AccountServiceImp.java1234567891011121314151617181920212223242526272829303132333435package xml.service;import org.springframework.stereotype.Component;import xml.dao.AccountDao;import xml.domain.Account;import javax.annotation.Resource;import java.util.List;public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ private AccountDao dao; /* 设值函数 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** 转账 */ public void transfer(int sourceId, int targetId, float money) &#123; Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money); dao.update(source);// int i = 10/0; target.setMoney(targetMoney + money); dao.update(target); &#125;&#125; 配置文件 依赖注入 开启事务管理 AOP TransactionManager Beans.xml12345678910111213141516171819202122232425262728293031323334353637 &lt;!-- DataSource --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt; &lt;!-- DaoImp --&gt; &lt;bean id="daoImp" class="xml.dao.AccountDaoImp"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- ServiceImp --&gt; &lt;bean id="serviceImp" class="xml.service.AccountServiceImp"&gt; &lt;property name="dao" ref="daoImp"/&gt; &lt;/bean&gt; &lt;!-- DataSourceTransactionManager --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- AOP --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="all" expression="execution(* xml.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="all"/&gt; &lt;/aop:config&gt; &lt;!-- tx --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 基于XML配置文件和注解目录结构 src main java service AccountServiceImp.java（业务层实现类） dao AccountDaoImp.java（持久层实习类） resources Beans.xml（Spring配置文件） 持久层实现类 操作数据库 注入 JdbcTemplate AccountDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package xml_anno.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import xml_anno.domain.Account;import java.util.List;@Repositorypublic class AccountDaoImp implements AccountDao &#123; /* 成员变量 */ @Autowired private JdbcTemplate jdbcTemplate; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return jdbcTemplate.query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125; /** 查询单个 */ public Account findByID(int id) &#123; return jdbcTemplate.queryForObject( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); &#125; /** 添加 */ public void add(Account account) &#123; jdbcTemplate.update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; /** 修改 */ public void update(Account account) &#123; jdbcTemplate.update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; /** 删除 */ public void delete(int id) &#123; jdbcTemplate.update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125;&#125; 业务层实现类 调用持久层方法 基于注解的方式注入 开启事务支持 基于注解的方式 AccountServiceImp.java1234567891011121314151617181920212223242526272829303132333435package xml_anno.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import xml_anno.domain.Account;import xml_anno.dao.AccountDao;@Service/** 事务支持（查询方法） */@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ @Autowired private AccountDao dao; /** 转账 */ /** 事务支持（增删改方法） */ @Transactional(propagation = Propagation.REQUIRED, readOnly = false) public void transfer(int sourceId, int targetId, float money) &#123; Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money); dao.update(source); int i = 10/0; target.setMoney(targetMoney + money); dao.update(target); &#125;&#125; 配置文件 依赖注入 开启注解扫描 Beans.xml12345678910111213141516 &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt;&lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="xml_anno"&gt;&lt;/context:component-scan&gt; 基于Java配置文件和注解目录结构 src main java service AccountServiceImp.java（业务层实现类） dao AccountDaoImp.java（持久层实习类） config SpringConfiguration.java（Java配置文件） JdbcConfig.java（Java配置文件） TransactionConfig.java（Java配置文件） 持久层实现类AccountDaoImp.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package java_anno.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;import xml_anno.dao.AccountDao;import xml_anno.domain.Account;import java.util.List;@Componentpublic class AccountDaoImp implements AccountDao &#123; /* 成员变量 */ @Autowired private JdbcTemplate jdbcTemplate; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return jdbcTemplate.query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125; /** 查询单个 */ public Account findByID(int id) &#123; return jdbcTemplate.queryForObject( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); &#125; /** 添加 */ public void add(Account account) &#123; jdbcTemplate.update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; /** 修改 */ public void update(Account account) &#123; jdbcTemplate.update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; /** 删除 */ public void delete(int id) &#123; jdbcTemplate.update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125;&#125; 业务层实现类AccountServiceImp.java123456789101112131415161718192021222324252627282930313233package java_anno.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import xml_anno.dao.AccountDao;import xml_anno.domain.Account;@Componentpublic class AccountServiceImp implements AccountService &#123; /* 成员变量 */ @Autowired private AccountDao dao; /** 转账 */ /** 事务支持（增删改方法） */ @Transactional(propagation = Propagation.REQUIRED, readOnly = false) public void transfer(int sourceId, int targetId, float money) &#123; xml_anno.domain.Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money); dao.update(source);// int i = 10/0; target.setMoney(targetMoney + money); dao.update(target); &#125;&#125; 数据库连接工具类jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root Spring配置文件SpringConfiguration.java1234567891011121314151617181920package java_anno.config;import org.springframework.context.annotation.*;import org.springframework.transaction.annotation.EnableTransactionManagement;/** 指定配置文件 */@Configuration/** 开启注解扫描 */@ComponentScan("java_anno")/** 指定property文件 */@PropertySource("classpath:java_anno/jdbcConfig.properties")/** 设置子文件 */@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)/** 开启事务管理器 */@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125; 数据库连接配置文件JdbcConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142package java_anno.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;import java.sql.Driver;public class JdbcConfig &#123; /** 数据库连接参数 */ @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** DataSource */ @Bean(name = "dataSource") public DataSource getDataSource()&#123; DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource(); driverManagerDataSource.setDriverClassName(driver); driverManagerDataSource.setUrl(url); driverManagerDataSource.setUsername(username); driverManagerDataSource.setPassword(password); return driverManagerDataSource; &#125; /** JdbcTemplate */ @Bean(name = "jdbc") public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125;&#125; 事务管理配置文件TransactionConfig.java12345678910111213141516171819package java_anno.config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.sql.DataSource;public class TransactionConfig &#123; /** TransactionManager */ @Bean(name = "transactionManager") public PlatformTransactionManager getTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架11 —— 事务管理]]></title>
    <url>%2F2019%2F08%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F12.Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务管理 一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS（ 关系数据库管理系统 ） 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 ACID： 原子性：事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。 一致性：这表示数据库的引用完整性的一致性，表中唯一的主键等。 隔离性：可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。 持久性：一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。 局部事物 vs. 全局事务局部事务是特定于一个单一的事务资源，如一个 JDBC 连接，而全局事务可以跨多个事务资源事务，如在一个分布式系统中的事务。 局部事务管理在一个集中的计算环境中是有用的，该计算环境中应用程序组件和资源位于一个单位点，而事务管理只涉及到一个运行在一个单一机器中的本地数据管理器。局部事务更容易实现。 全局事务管理需要在分布式计算环境中，所有的资源都分布在多个系统中。在这种情况下事务管理需要同时在局部和全局范围内进行。分布式或全局事务跨多个系统执行，它的执行需要全局事务管理系统和所有相关系统的局部数据管理人员之间的协调。 编程式 vs. 声明式 Spring 支持两种类型的事务管理: 编程式事务管理 ：这意味着你在编程的帮助下有管理事务。这给了你极大的灵活性，但却很难维护。 声明式事务管理 ：这意味着你从业务代码中分离事务管理。你仅仅使用注释或 XML 配置来管理事务。 声明式事务管理比编程式事务管理更可取，尽管它不如编程式事务管理灵活，但它允许你通过代码控制事务。但作为一种横切关注点，声明式事务管理可以使用 AOP 方法进行模块化。Spring 支持使用 Spring AOP 框架的声明式事务管理。 Spring 声明式事务管理声明式事务管理方法允许你在配置的帮助下而不是源代码硬编程来管理事务。这意味着你可以将事务管理从事务代码中隔离出来。你可以只使用注释或基于配置的 XML 来管理事务。 bean 配置会指定事务型方法。下面是与声明式事务相关的步骤： 我们使用标签，它创建一个事务处理的建议，同时，我们定义一个匹配所有方法的切入点，我们希望这些方法是事务型的并且会引用事务型的建议。 如果在事务型配置中包含了一个方法的名称，那么创建的建议在调用方法之前就会在事务中开始进行。 目标方法会在 try / catch 块中执行。 如果方法正常结束，AOP 建议会成功的提交事务，否则它执行回滚操作。]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架10 —— JDBCTemplate]]></title>
    <url>%2F2019%2F08%2F24%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F11.JDBCTemplate%2F</url>
    <content type="text"><![CDATA[概述 在我们使用普通的 JDBC 数据库时，操作步骤非常麻烦，我们需要写一些不必要的代码来处理异常，打开和关闭数据库连接等。 Spring JDBC 框架则会帮我们负责所有的低层细节，从开始打开连接，准备和执行 SQL 语句，处理异常，处理事务，到最后关闭连接。所以当从数据库中获取数据时，我们需要做的仅是定义连接参数，指定要执行的 SQL 语句，以及后续操作。 Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 JdbcTemplate 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。 JdbcTemplate 类 JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。 JdbcTemplate 类的实例是*线程安全* 配置的。所以我们可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。 使用 JdbcTemplate 类时常见的做法是我们在 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。 项目环境配置数据源 我们在 MySQL 数据库 spring 中创建一个数据库表 account。 1234567891011121314151617# 创建数据库CREATE DATABASE spring;# 使用数据库USE spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); Maven依赖123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring JDBC框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 四种连接方式目录结构src main java cn.water Account.java（实体类） resources Beans.xml（Spring配置文件） test cn.water.test SpringTest.java（测试类） 实体类Account.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.JDBC;import java.io.Serializable;public class Account implements Serializable &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ public Account() &#123; &#125; public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; /* toString */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 配置文件Beans.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类SpringTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package cn.water.JDBC;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import java.sql.*;import java.util.List;public class JDBCTest &#123; /** Connection对象和Statement对象 */ @Test public void test01() throws Exception &#123; /* 1、注册数据库驱动 */ Class.forName("com.mysql.jdbc.Driver"); /* 2、获取Connection对象 */ Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring", "root", "root"); /* 3、SQL语句 */ String sql = "SELECT * FROM account WHERE id = 1 "; /* 4、获取Statement对象 */ Statement statement = connection.createStatement(); /* 5、执行SQL语句，并接收结果集 */ ResultSet resultSet = statement.executeQuery(sql); /* 6、遍历 */ while (resultSet.next()) &#123; int id = resultSet.getInt(1); String name = resultSet.getString(2); float money = resultSet.getFloat(3); System.out.println("Account:"+id+" "+name+" "+money); &#125; &#125; /** Connection对象和PreparedStatement对象 */ @Test public void test02() throws Exception &#123; /* 1、注册 数据库驱动 */ Class.forName("com.mysql.jdbc.Driver"); /* 2、获取 Connection对象 */ Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring", "root", "root"); /* 3、SQL语句 */ String sql = "SELECT * FROM account WHERE id = ? "; /* 4、获取 PreparedStatement对象 */ PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,1); /* 5、执行SQL语句，并接收结果集 */ ResultSet resultSet = preparedStatement.executeQuery(); /* 6、遍历 */ while (resultSet.next()) &#123; int id = resultSet.getInt(1); String name = resultSet.getString(2); float money = resultSet.getFloat(3); System.out.println("Account:"+id+" "+name+" "+money); &#125; &#125; /** Spring JDBC */ @Test public void test03() &#123; /* 1、获取 DriverManagerDataSource对象 */ DriverManagerDataSource dataSource = new DriverManagerDataSource(); /* 2、设置 数据库连接参数 */ dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/spring"); dataSource.setUsername("root"); dataSource.setPassword("root"); /* 3、获取 JdbcTemplate对象 */ JdbcTemplate jdbcTemplate = new JdbcTemplate(); /* 4、设值 JdbcTemplate对象 */ jdbcTemplate.setDataSource(dataSource); /* 5、执行SQL语句，并接收结果集 */ List&lt;Account&gt; result = jdbcTemplate.query( "SELECT * FROM account WHERE id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1 ); /* 6、遍历 */ for (Account account : result) &#123; System.out.println(account); &#125; &#125; /** Spring JDBC + Spring IoC */ @Test public void test04() &#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("JDBC/Beans.xml"); /* 2、获取Bean对象 */ JdbcTemplate jdbcTemplate = app.getBean("jdbc", JdbcTemplate.class); /* 3、执行SQL语句，并接收结果集 */ List&lt;Account&gt; result = jdbcTemplate.query( "SELECT * FROM account WHERE id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1 ); /* 5、遍历 */ for (Account account : result) &#123; System.out.println(account); &#125; &#125;&#125; Statement测试类 注册数据库驱动：每次手动编写 设置数据库连接参数：每次手动编写 结果集遍历：麻烦 1234567891011121314151617/* 1、注册数据库驱动 */Class.forName("com.mysql.jdbc.Driver");/* 2、获取Connection对象 */Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring", "root", "root");/* 3、SQL语句 */String sql = "SELECT * FROM account WHERE id = 1 ";/* 4、获取Statement对象 */Statement statement = connection.createStatement();/* 5、执行SQL语句，并接收结果集 */ResultSet resultSet = statement.executeQuery(sql);/* 6、遍历 */while (resultSet.next()) &#123; int id = resultSet.getInt(1); String name = resultSet.getString(2); float money = resultSet.getFloat(3); System.out.println("Account:"+id+" "+name+" "+money);&#125; PreparedStatement测试类 注册数据库驱动：每次手动编写 设置数据库连接参数：每次手动编写 结果集遍历：麻烦 123456789101112131415161718/* 1、注册 数据库驱动 */Class.forName("com.mysql.jdbc.Driver");/* 2、获取 Connection对象 */Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring", "root", "root");/* 3、SQL语句 */String sql = "SELECT * FROM account WHERE id = ? ";/* 4、获取 PreparedStatement对象 */PreparedStatement preparedStatement = connection.prepareStatement(sql);preparedStatement.setInt(1,1);/* 5、执行SQL语句，并接收结果集 */ResultSet resultSet = preparedStatement.executeQuery();/* 6、遍历 */while (resultSet.next()) &#123; int id = resultSet.getInt(1); String name = resultSet.getString(2); float money = resultSet.getFloat(3); System.out.println("Account:"+id+" "+name+" "+money);&#125; JDBC实体类123456789101112public class Account implements Serializable &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ /* 设值函数 */ /* toString */&#125; 测试类 注册数据库驱动：每次手动编写 设置数据库连接参数：每次手动编写 结果集遍历：简单 123456789101112131415161718192021/* 1、获取 DriverManagerDataSource对象 */DriverManagerDataSource dataSource = new DriverManagerDataSource();/* 2、设置 数据库连接参数 */dataSource.setDriverClassName("com.mysql.jdbc.Driver");dataSource.setUrl("jdbc:mysql://localhost:3306/spring");dataSource.setUsername("root");dataSource.setPassword("root");/* 3、获取 JdbcTemplate对象 */JdbcTemplate jdbcTemplate = new JdbcTemplate();/* 4、设值 JdbcTemplate对象 */jdbcTemplate.setDataSource(dataSource);/* 5、执行SQL语句，并接收结果集 */List&lt;Account&gt; result = jdbcTemplate.query( "SELECT * FROM account WHERE id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1);/* 6、遍历 */for (Account account : result) &#123; System.out.println(account);&#125; JDBC 、IoC实体类123456789101112public class Account implements Serializable &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ /* 设值函数 */ /* toString */&#125; 配置文件 注册数据库驱动：配置文件一次编写 数据库连接参数：配置文件一次编写 结果集遍历：简单 123456789101112&lt;!-- DriverManagerDataSource --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt;&lt;!-- JdbcTemplate --&gt;&lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 测试类1234567891011121314/* 1、加载配置文件，初始化Bean对象 */ApplicationContext app = new ClassPathXmlApplicationContext("JDBC/Beans.xml");/* 2、获取Bean对象 */JdbcTemplate jdbcTemplate = app.getBean("jdbc", JdbcTemplate.class);/* 3、执行SQL语句，并接收结果集 */List&lt;Account&gt; result = jdbcTemplate.query( "SELECT * FROM account WHERE id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), 1);/* 5、遍历 */for (Account account : result) &#123; System.out.println(account);&#125; 三种获取方式 三种获取 JdbcTemplate 对象的方法 目录结构src main java cn.water dao AccountDao.java（持久层接口） AccountDaoImp01.java（持久层实现类） AccountDaoImp02.java（持久层实现类） AccountDaoImp03.java（持久层实现类） domain Account.java（实体类） resources Beans.xml（Spring配置文件） test cn.water.test JDBCTest.java（测试类） 实体类Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.JDBCCase.domain;public class Account &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ public Account() &#123; &#125; public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; /* toString */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 持久层AccontDao.java12345678910111213141516package cn.water.JDBCCase.dao;import cn.water.JDBCCase.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询所有 */ List&lt;Account&gt; findAll(); /** 查询单个 */ Account findById(Integer id);&#125; AccountDaoImp01.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.JDBCCase.dao;import cn.water.JDBCCase.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.util.List;public class AccountDaoImp01 implements AccountDao&#123; /* 成员变量 */ private DataSource dataSource; /* 设值函数 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return new JdbcTemplate(dataSource).query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) ); &#125; /** 查询单个 */ public Account findById(Integer id) &#123; return new JdbcTemplate(dataSource).queryForObject( "SELECT * FROM account WHERE id = ? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); &#125;&#125; AccountDaoImp02.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.JDBCCase.dao;import cn.water.JDBCCase.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.support.JdbcDaoSupport;import javax.sql.DataSource;import java.util.List;public class AccountDaoImp02 implements AccountDao&#123; /* 成员变量 */ private JdbcTemplate template; /* 设值函数 */ public void setTemplate(JdbcTemplate template) &#123; this.template = template; &#125; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return template.query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) ); &#125; /** 查询单个 */ public Account findById(Integer id) &#123; return template.queryForObject( "SELECT * FROM account WHERE id = ? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); &#125;&#125; AccountDaoImp03.java1234567891011121314151617181920212223242526272829package cn.water.JDBCCase.dao;import cn.water.JDBCCase.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import java.util.List;public class AccountDaoImp03 extends JdbcDaoSupport implements AccountDao&#123; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return super.getJdbcTemplate().query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) ); &#125; /** 查询单个 */ public Account findById(Integer id) &#123; return super.getJdbcTemplate().queryForObject( "SELECT * FROM account WHERE id = ? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); &#125;&#125; 配置文件Beans.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- DaoImp01 --&gt; &lt;bean id="dao01" class="cn.water.JDBCCase.dao.AccountDaoImp01"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- DaoImp01 --&gt; &lt;bean id="dao02" class="cn.water.JDBCCase.dao.AccountDaoImp02"&gt; &lt;property name="template" ref="jdbc"/&gt; &lt;/bean&gt; &lt;!-- DaoImp02 --&gt; &lt;bean id="dao03" class="cn.water.JDBCCase.dao.AccountDaoImp03"&gt; &lt;!-- 给父类 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类JDBCTest.java123456789101112131415161718192021222324252627282930313233package cn.water.JDBCCase;import cn.water.JDBCCase.dao.AccountDaoImp01;import cn.water.JDBCCase.dao.AccountDaoImp02;import cn.water.JDBCCase.domain.Account;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class JDBCTest &#123; @Test public void test01()&#123; ApplicationContext app = new ClassPathXmlApplicationContext("JDBCCase/Beans.xml"); AccountDaoImp01 dao = app.getBean("dao01", AccountDaoImp01.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125; System.out.println(dao.findById(1)); &#125; @Test public void test02()&#123; ApplicationContext app = new ClassPathXmlApplicationContext("JDBCCase/Beans.xml"); AccountDaoImp02 dao = app.getBean("dao02", AccountDaoImp02.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125; System.out.println(dao.findById(1)); &#125;&#125; 传递DataSource持久层实现类 传递 DataSource后，创建 JdbcTemplate对象，然后调用操作数据库的方法。 123456789101112131415/* 成员变量 */private DataSource dataSource;/* 设值函数 */public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource;&#125;/** 查询所有 */public List&lt;Account&gt; findAll() &#123; return new JdbcTemplate(dataSource).query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) );&#125; 配置文件123456789101112131415161718 &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt;&lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- DaoImp01 --&gt; &lt;bean id="dao01" class="cn.water.JDBCCase.dao.AccountDaoImp01"&gt; &lt;!-- 自己用 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 传递JdbcTemplate 直接传递JdbcTemplate对象，然后调用操作数据库的方法。 持久层实现类123456789101112131415161718192021222324/* 成员变量 */private JdbcTemplate template;/* 设值函数 */public void setTemplate(JdbcTemplate template) &#123; this.template = template;&#125;/** 查询所有 */public List&lt;Account&gt; findAll() &#123; return template.query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) );&#125;/** 查询单个 */public Account findById(Integer id) &#123; return template.queryForObject( "SELECT * FROM account WHERE id = ? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id );&#125; 配置文件1234567891011121314151617 &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- DaoImp02 --&gt; &lt;bean id="dao02" class="cn.water.JDBCCase.dao.AccountDaoImp02"&gt; &lt;property name="template" ref="jdbc"/&gt; &lt;/bean&gt; 继承父类传递DataSource继承 JdbcDaoSupport类，并向其传递 DataSource，然后调用父类方法，获取Connection对象，最后执行操作数据库的方法。 持久层实现类12345678910111213141516171819public class AccountDaoImp03 extends JdbcDaoSupport implements AccountDao&#123; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return super.getJdbcTemplate().query( "SELECT * FROM account ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) ); &#125; /** 查询单个 */ public Account findById(Integer id) &#123; return super.getJdbcTemplate().queryForObject( "SELECT * FROM account WHERE id = ? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); &#125;&#125; 配置文件123456789101112131415161718 &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- DaoImp03 --&gt; &lt;bean id="dao03" class="cn.water.JDBCCase.dao.AccountDaoImp03"&gt; &lt;!-- 给父类 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架09 —— 三种事务管理机制的转账案例]]></title>
    <url>%2F2019%2F08%2F23%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F10.%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[简介 本文的三个案例是为了更好的理解 Spring AOP 的机制，以及复习数据库事务管理。具体的功能是实现数据库的转账操作，核心知识主要分为三部分：数据库的连接、事务管理、依赖注入和功能测试。 案例一：直接在业务层添加代码，来进行事务管理 数据库的管理问题：通过Connection工具类来实现 事务管理：通过 Transaction 工具类，在 Service 业务层中实现 依赖注入：通过 xml配置文件 测试：通过Junit测试 案例二：通过代理模式增强代码，来进行事务管理 数据库的管理问题：通过Connection工具类来实现 事务管理：通过 Transaction 工具类，在 BeanFactory 代理类中实现。（获取增强过的业务层接口） 依赖注入：通过 xml配置文件 测试：通过 Junit 测试 案例三：通过SpringAOP，来进行事务管理 数据库的管理问题：通过Connection工具类来实现 事务管理：完全通过 Transaction 工具类实现（AOP，高内聚） 依赖注入：通过 xml配置文件 + 注解 测试：通过 Spring Junit 测试 项目环境数据库代码 创建数据库spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE spring;# 使用数据库USE spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); Maven依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;!-- Spring 框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 操作数据库的工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 业务层实现事务目录结构 src main java cn.water momain：用于存放实体类。 Account.java（实体类） dao：用于存放持久层的接口和实现类。（具体的CRUD操作代码） AccountDao.java（持久层接口） AccountDaoImp.java（持久层实现类） service：用于存放业务层的接口和实现类。 AccountService.java（业务层接口） AccountServiceImp.java（业务层接口） utils：用于存放工具类 ConnectionUtils.java（数据库连接工具类） TransactionManager.java（事务管理工具类） resources：用于存放配置文件 Beans.xml（Spring配置文件） test：用于测试。 cn.water.test SpringTest.java（测试类） 实体类 封装数据库查询操作的结果集 Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.domain;public class Account &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ public Account() &#123; &#125; public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; /* toString */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 持久层 实现具体的数据库操作代码 AccountDao.java12345678910111213141516package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询单个 */ Account findByID(int id); /** 修改 */ void update(Account account);&#125; AccountDaoImp.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.water.dao;import cn.water.domain.Account;import cn.water.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class AccountDaoImp implements AccountDao &#123; /* 成员方法 */ private QueryRunner queryRunner; private ConnectionUtils connectionUtils; /* 设值方法 */ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** 查询单个 */ public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 修改 */ public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 数据库连接工具类 获取当前线程上的Connection对象 ConnectionUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class ConnectionUtils &#123; /* 成员变量 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); private DataSource dataSource; /* 设值函数 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** 获取Connection对象 */ public Connection getThreadConnection()&#123; try &#123; /* 获取从当前线程上的Connection对象 */ Connection connection = threadLocal.get(); /* 如果当前线程没有绑定Connection */ if (connection==null) &#123; /* 从数据库连接池中，获取一个Connection对象 */ connection = dataSource.getConnection(); /* 并绑定至当前线程 */ threadLocal.set(connection); &#125; /* 返回此Connection对象 */ return connection; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** 将Connection和当前线程 解绑 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; 事务管理工具类 对当前线程上的 Connection对象 进行事务管理的具体方法 TransactionManager.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.water.utils;import java.sql.Connection;import java.sql.SQLException;public class TransactionManager &#123; /* 成员变量 */ private ConnectionUtils connectionUtils; private Connection connection; /* 设值函数 */ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** 开启事务 */ public void beginTransaction()&#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 提交事务 */ public void commit()&#123; try &#123; connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 回滚事务 */ public void rollback()&#123; try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 释放连接 */ public void release()&#123; try &#123; /* 返回至连接池 */ connectionUtils.getThreadConnection().close(); /* 将Connection对象与线程解绑 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 业务层（TM） 直接调用事务管理工具类的方法，实现事务管理 AccountService.java123456789101112package cn.water.service;import cn.water.domain.Account;public interface AccountService &#123; /** 转账 */ void transfer(int sourceId, int targetId, float money);&#125; AccountServiceImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import cn.water.utils.TransactionManager;import java.util.List;public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ private AccountDao dao; private TransactionManager txManager; /* 设值方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; public void setTxManager(TransactionManager txManager) &#123; this.txManager = txManager; &#125; /** 转账 */ public void transfer(int sourceId, int targetId, float money) &#123; try &#123; /* 开启事务 */ txManager.beginTransaction(); /* 执行操作 */ Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money);// int i = 10/0; target.setMoney(targetMoney + money); dao.update(source); dao.update(target); /* 提交事务 */ txManager.commit(); &#125; catch (Exception e) &#123; /* 回滚 */ txManager.rollback(); /* 抛出异常 */ throw new RuntimeException(); &#125; finally &#123; /* 释放连接 */ txManager.release(); &#125; &#125;&#125; 配置文件 ServiceImp（业务层） DaoImp DaoImp（持久层） QueryRunner QueryRunner（数据库操作类） DataSource TransactionManager（事务管理工具类） ConnectionUtils ConnectionUtils（数据库连接工具类） DataSource DataSource（数据库连接池） Beans.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- ConnectionUtils --&gt; &lt;bean id="connectionUtils" class="cn.water.utils.ConnectionUtils"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- TransactionManager --&gt; &lt;bean id="txManager" class="cn.water.utils.TransactionManager"&gt; &lt;property name="connectionUtils" ref="connectionUtils"/&gt; &lt;/bean&gt; &lt;!-- QueryRunner --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner"&gt; &lt;constructor-arg name="ds" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- Dao --&gt; &lt;bean id="daoImp" class="cn.water.dao.AccountDaoImp"&gt; &lt;property name="connectionUtils" ref="connectionUtils"/&gt; &lt;property name="queryRunner" ref="runner"/&gt; &lt;/bean&gt; &lt;!-- Service --&gt; &lt;bean id="serviceImp" class="cn.water.service.AccountServiceImp"&gt; &lt;property name="dao" ref="daoImp"/&gt; &lt;property name="txManager" ref="txManager"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类SpringTest.java12345678910111213141516171819202122package cn.water.test;import cn.water.service.AccountService;import cn.water.service.AccountServiceImp;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest &#123; @Test public void testTransfer()&#123; ApplicationContext app = new ClassPathXmlApplicationContext("Beans.xml"); AccountService service = app.getBean("serviceImp", AccountServiceImp.class); service.transfer(1,2,10f); &#125;&#125; 代理类实现事务目录结构 src main java cn.water momain：用于存放实体类。 Account.java（实体类） dao：用于存放持久层的接口和实现类。（具体的CRUD操作代码） AccountDao.java（持久层接口） AccountDaoImp.java（持久层实现类） service：用于存放业务层的接口和实现类。 AccountService.java（业务层接口） AccountServiceImp.java（业务层接口） utils：用于存放工具类 ConnectionUtils.java（数据库连接工具类） TransactionManager.java（事务管理工具类） factory：用于存放工厂类 BeanFactory.java（代理工厂类） resources：用于存放配置文件 Beans.xml（Spring配置文件） test：用于测试。 cn.water.test SpringTest.java（测试类） 实体类（不变） 封装数据库查询操作的结果集 Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.domain;public class Account &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ public Account() &#123; &#125; public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; /* toString */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 持久层 实现具体的数据库操作代码 引入 ConnectionUtils ，获取 Connection对象，在调用QueryRunner类的方法时传入。 我们不难看出，QueryRunner类和Connection对象的关系： 一、向QueryRunner类传入DataSource对象； 二、调用QueryRunner类的方法时传入Connection对象。 AccountDao.java12345678910111213141516package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询单个 */ Account findByID(int id); /** 修改 */ void update(Account account);&#125; AccountDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.dao;import cn.water.domain.Account;import cn.water.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class AccountDaoImp implements AccountDao &#123; /* 成员方法 */ private QueryRunner queryRunner; private ConnectionUtils connectionUtils; /* 设值方法 */ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** 查询单个 */ public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 修改 */ public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 数据库连接工具类（不变） 获取当前线程上的Connection对象（不变） ConnectionUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class ConnectionUtils &#123; /* 成员变量 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); private DataSource dataSource; /* 设值函数 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** 获取Connection对象 */ public Connection getThreadConnection()&#123; try &#123; /* 获取从当前线程上的Connection对象 */ Connection connection = threadLocal.get(); /* 如果当前线程没有绑定Connection */ if (connection==null) &#123; /* 从数据库连接池中，获取一个Connection对象 */ connection = dataSource.getConnection(); /* 并绑定至当前线程 */ threadLocal.set(connection); &#125; /* 返回此Connection对象 */ return connection; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** 将Connection和当前线程 解绑 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; 事务管理工具类（不变） 对当前线程上的 Connection对象 进行事务管理的具体方法 TransactionManager.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.water.utils;import java.sql.Connection;import java.sql.SQLException;public class TransactionManager &#123; /* 成员变量 */ private ConnectionUtils connectionUtils; /* 设值函数 */ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** 开启事务 */ public void beginTransaction()&#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 提交事务 */ public void commit()&#123; try &#123; connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 回滚事务 */ public void rollback()&#123; try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 释放连接 */ public void release()&#123; try &#123; /* 返回至连接池 */ connectionUtils.getThreadConnection().close(); /* 将Connection对象与线程解绑 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 业务层 直接调用事务管理工具类的方法，实现事务管理 AccountService.java123456789101112package cn.water.service;import cn.water.domain.Account;public interface AccountService &#123; /** 转账 */ void transfer(int sourceId, int targetId, float money);&#125; AccountServiceImp.java12345678910111213141516171819202122232425262728293031323334package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import java.util.List;public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ private AccountDao dao; /* 设值方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** 转账 */ public void transfer(int sourceId, int targetId, float money) &#123; Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money); dao.update(source);// int i = 10/0; target.setMoney(targetMoney + money); dao.update(target); &#125;&#125; 代理工厂类（TM） 代理模式：创建代理对象，并增强代码 工厂模式：返回一个代理对象。 ProxyFactory.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.water.factory;import cn.water.service.AccountService;import cn.water.utils.TransactionManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class BeanFactory &#123; /* 成员变量 */ private AccountService service; private TransactionManager txManager; /* 设值函数 */ public void setService(AccountService service) &#123; this.service = service; &#125; public void setTxManager(TransactionManager txManager) &#123; this.txManager = txManager; &#125; /** 获取代理对象 */ public AccountService getProxyService()&#123; return (AccountService) Proxy.newProxyInstance( /* 类加载器 */ service.getClass().getClassLoader(), /* 接口 */ service.getClass().getInterfaces(), /** InvocationHandler接口：事务管理 */ new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /* 查询方法不需要进行事务管理 */ if ("find".equals(method.getName()))&#123; return method.invoke(service,args); /* 增删改方法进行进行事务管理 */ &#125;else &#123; try &#123; /* 开启事务 */ txManager.beginTransaction(); /* 执行操作 */ Object result = method.invoke(service, args); /* 提交事务 */ txManager.commit(); /* 返回结果集 */ return result; &#125; catch (Exception e) &#123; /* 回滚 */ txManager.rollback(); /* 抛出异常 */ throw new RuntimeException(); &#125; finally &#123; /* 释放连接 */ txManager.release(); &#125; &#125; &#125; &#125; ); &#125;&#125; 配置文件 ProxyService（代理类） BeanFactory（代理工厂类） ServiceImp TransactionManager ServiceImp（业务层） DaoImp DaoImp（持久层） QueryRunner ConnectionUtils QueryRunner（数据库操作类） ConnectionUtils 能够为 DaoImp 提供 Connection对象，因此不必再为 QueryRunner 提供 DataSource 但要转而为 DaoImp 提供 ConnectionUtils TransactionManager（事务管理工具类） ConnectionUtils ConnectionUtils（数据库连接工具类） DataSource DataSource（数据库连接池） Beans.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- ConnectionUtils --&gt; &lt;bean id="connectionUtils" class="cn.water.utils.ConnectionUtils"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- TransactionManager --&gt; &lt;bean id="txManager" class="cn.water.utils.TransactionManager"&gt; &lt;property name="connectionUtils" ref="connectionUtils"/&gt; &lt;/bean&gt; &lt;!-- QueryRunner --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner"&gt;&lt;/bean&gt; &lt;!-- Dao --&gt; &lt;bean id="daoImp" class="cn.water.dao.AccountDaoImp"&gt; &lt;property name="connectionUtils" ref="connectionUtils"/&gt; &lt;property name="queryRunner" ref="runner"/&gt; &lt;/bean&gt; &lt;!-- Service --&gt; &lt;bean id="serviceImp" class="cn.water.service.AccountServiceImp"&gt; &lt;property name="dao" ref="daoImp"/&gt; &lt;/bean&gt; &lt;!-- BeanFactory --&gt; &lt;bean id="factory" class="cn.water.factory.BeanFactory"&gt; &lt;property name="service" ref="serviceImp"/&gt; &lt;property name="txManager" ref="txManager"/&gt; &lt;/bean&gt; &lt;!-- 代理service --&gt; &lt;bean id="proxyService" factory-bean="factory" factory-method="getProxyService"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 Spring框架整合junit SpringTest.java123456789101112131415161718192021222324252627package cn.water.test;import cn.water.domain.Account;import cn.water.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:Beans.xml")public class SpringTest &#123; /* 获取代理对象 */ @Resource(name = "proxyService") private AccountService service; @Test public void testTransfer()&#123; service.transfer(1,2,10f); &#125;&#125; 通知类实现事务（AOP）目录结构 src main java cn.water dao：用于存放持久层的接口和实现类。（具体的CRUD操作代码） AccountDao.java（持久层接口） AccountDaoImp.java（持久层实现类） momain：用于存放实体类。 Account.java（实体类） service：用于存放业务层的接口和实现类。 AccountService.java（业务层接口） AccountServiceImp.java（业务层接口） utils：用于存放工具类 ConnectionUtils.java（数据库连接工具类） TransactionManager.java（事务管理工具类） resources：用于存放配置文件 Beans.xml（Spring配置文件） test：用于测试。 cn.water.test SpringTest.java（测试类） 实体类（不变） 封装数据库查询操作的结果集 Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.domain;public class Account &#123; /* 成员变量 */ private Integer id; private String name; private Float money; /* 构造函数 */ public Account() &#123; &#125; public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; /* toString */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 持久层 实现具体的数据库操作代码 AccountDao.java12345678910111213141516package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询单个 */ Account findByID(int id); /** 修改 */ void update(Account account);&#125; AccountDaoImp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.water.dao;import cn.water.domain.Account;import cn.water.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.sql.Connection;import java.sql.SQLException;import java.util.List;@Component("daoImp")public class AccountDaoImp implements AccountDao &#123; /* 成员方法 */ @Resource(name = "runner") private QueryRunner queryRunner; @Resource(name = "connectionUtils") private ConnectionUtils connectionUtils; /** 查询单个 */ public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 修改 */ public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* Connection对象 */ connectionUtils.getThreadConnection(), /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 数据库连接工具类（不变） 获取当前线程上的Connection对象 ConnectionUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class ConnectionUtils &#123; /* 成员变量 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); private DataSource dataSource; /* 设值函数 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** 获取Connection对象 */ public Connection getThreadConnection()&#123; try &#123; /* 获取从当前线程上的Connection对象 */ Connection connection = threadLocal.get(); /* 如果当前线程没有绑定Connection */ if (connection==null) &#123; /* 从数据库连接池中，获取一个Connection对象 */ connection = dataSource.getConnection(); /* 并绑定至当前线程 */ threadLocal.set(connection); &#125; /* 返回此Connection对象 */ return connection; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** 将Connection和当前线程 解绑 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; 事务管理工具类（TM） 使用Spring框架的AOP机制，进行事务管理 TransactionManager.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.water.utils;import org.aspectj.lang.annotation.*;import javax.annotation.Resource;import java.sql.Connection;import java.sql.SQLException;@Aspectpublic class TransactionManager &#123; /* 成员变量 */ @Resource(name = "connectionUtils") private ConnectionUtils connectionUtils; /** 切入点 */ @Pointcut(value = "execution(* cn.water.utils.*.*(..))") public void all()&#123;&#125; /** 开启事务（前置通知） */ @Before("all()") public void beginTransaction()&#123; try &#123; connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 提交事务（后置通知） */ @AfterReturning("all()") public void commit()&#123; try &#123; connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 回滚事务（异常通知） */ @AfterThrowing("all()") public void rollback()&#123; try &#123; connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 释放连接（最终通知） */ @After("all()") public void release()&#123; try &#123; /* 返回至连接池 */ connectionUtils.getThreadConnection().close(); /* 将Connection对象与线程解绑 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 业务层 直接调用事务管理工具类的方法，实现事务管理 AccountService.java123456789101112package cn.water.service;import cn.water.domain.Account;public interface AccountService &#123; /** 转账 */ void transfer(int sourceId, int targetId, float money);&#125; AccountServiceImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import cn.water.utils.TransactionManager;import java.util.List;public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ private AccountDao dao; private TransactionManager txManager; /* 设值方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; public void setTxManager(TransactionManager txManager) &#123; this.txManager = txManager; &#125; /** 转账 */ public void transfer(int sourceId, int targetId, float money) &#123; try &#123; /* 开启事务 */ txManager.beginTransaction(); /* 执行操作 */ Account source = dao.findByID(sourceId); Account target = dao.findByID(targetId); Float sourceMoney = source.getMoney(); Float targetMoney = target.getMoney(); source.setMoney(sourceMoney - money);// int i = 10/0; target.setMoney(targetMoney + money); dao.update(source); dao.update(target); /* 提交事务 */ txManager.commit(); &#125; catch (Exception e) &#123; /* 回滚 */ txManager.rollback(); /* 抛出异常 */ throw new RuntimeException(); &#125; finally &#123; /* 释放连接 */ txManager.release(); &#125; &#125;&#125; 配置文件 QueryRunner（数据库操作类） DataSource（数据库连接池） 开启Spring注解扫描 开启SpringAOP注解支持 Beans.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- QueryRunner --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner"&gt;&lt;/bean&gt; &lt;!-- 开启Spring注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 开启SpringAOP注解支持 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试类SpringTest.java12345678910111213141516171819202122232425package cn.water.test;import cn.water.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:Beans.xml")public class SpringTest &#123; @Resource(name = "serviceImp") private AccountService service; @Test public void testTransfer()&#123; service.transfer(1,2,10f); &#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务管理</tag>
        <tag>Proxy</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架08 —— 面向切面编程（AOP）]]></title>
    <url>%2F2019%2F08%2F21%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F9.SpringAOP%2F</url>
    <content type="text"><![CDATA[简介 Spring 框架的关键组件是 面向切面的编程(AOP，Aspect Oriented Programming)，面向切面的编程需要把程序逻辑分解成不同的部分称为所谓的连接点。跨一个应用程序的多个点的功能被称为切入点，切入点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。 在 面向对象编程（OOP，Object Oriented Programming） 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对切入点解耦。AOP 是像编程语言的触发物，如 Perl，.NET，Java 或者其他。 Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。 AOP术语 在我们开始使用 AOP 工作之前，让我们熟悉一下 AOP 概念和术语。这些术语并不特定于 Spring，而是与 AOP 有关的。 项 描述 Aspect（切面） 由一系列切点、增强和引入组成的模块对象。 Join point（连接点） 程序执行期的一个点。 Pointcut（切入点） 一组通过表达式从连接点中被筛选出来的点。 Advice（通知） 切面在特定接入点的执行动作。 Introduction（引入） 为某个type声明额外的方法和字段。 Target object（目标对象） 一个被一个或者多个切面所通知的被代理对象。 Weaving（织入） 把切面连接到其它的对象上，并创建目标对象。 通知 Spring AOP 模块可以使用下面提到的五种通知工作： 通知 描述 前置通知（before） 在切入点方法执行之前，执行通知。 后置通知（after-returning） 在切入点方法执行之后，当方法正常执行时，执行通知。 异常通知（after-throwing） 在切入点方法执行之后，当方法抛出异常时，执行通知。 最终通知（after） 在切入点方法执行之后，不考虑其结果，执行通知。 环绕通知（around） 在建议方法调用之前和之后，执行通知。 目录结构 src main java anno Student.java（目标类） Logger.java（通知类） xml Student.java（目标类） Logger.java（通知类） resources anno Beans.xml（Spring配置文件） test anno SpringTest.java（测试类） xml SpringTest.java（测试类） 基于xmlStudent.java12345678910111213141516171819202122232425262728293031323334package OtherAdvice.xml;public class Student &#123; /* 成员变量 */ private Integer age; private String name; /** 抛出异常 */ public void printThrowException()&#123; System.out.println("出现异常..."); throw new IllegalArgumentException(); &#125; /* 设值函数 */ public Integer getAge() &#123; System.out.println(" age:"+age); return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; System.out.println(" name:"+name); return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Logger.java123456789101112131415161718192021222324package OtherAdvice.xml;public class Logger &#123; /** 前置通知 */ public void beforeAdvice()&#123; System.out.println("------"); System.out.println("~前置通知"); &#125; /** 后置通知 */ public void afterReturningAdvice(Object retVal)&#123; System.out.println("~后置通知:" + retVal.toString() ); &#125; /** 异常通知 */ public void afterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println("~异常通知： " + ex.toString()); &#125; /** 最终通知 */ public void afterAdvice()&#123; System.out.println("~最终通知"); &#125;&#125; Beans.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "&gt; &lt;!-- 通知类 --&gt; &lt;bean id="logging" class="OtherAdvice.xml.Logger"/&gt; &lt;!-- 目标类 --&gt; &lt;bean id="student" class="OtherAdvice.xml.Student"&gt; &lt;property name="name" value="cat"/&gt; &lt;property name="age" value="1"/&gt; &lt;/bean&gt; &lt;!-- Spring AOP框架 --&gt; &lt;aop:config&gt; &lt;!-- 切面（Aspect） --&gt; &lt;aop:aspect id="log" ref="logging"&gt; &lt;!-- 切入点（Pointcut） --&gt; &lt;aop:pointcut id="all" expression="execution(* OtherAdvice.xml.*.*(..))"/&gt; &lt;!-- 通知（Advice） --&gt; &lt;aop:before method="beforeAdvice" pointcut-ref="all" /&gt; &lt;aop:after-returning method="afterReturningAdvice" returning="retVal" pointcut-ref="all"/&gt; &lt;aop:after-throwing method="afterThrowingAdvice" throwing="ex" pointcut-ref="all"/&gt; &lt;aop:after method="afterAdvice" pointcut-ref="all"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; SpringTest.java12345678910111213141516171819202122package cn.water.test.OtherAdvice.xml;import OtherAdvice.xml.Student;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest &#123; @Test public void test()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("OtherAdvice/xml/Beans.xml"); /* 2、获取Bean对象 */ Student student = app.getBean("student", Student.class); /* 3、调用方法 */ student.getAge(); student.getName(); student.printThrowException(); &#125;&#125; 基于注解Student.java12345678910111213141516171819202122232425262728293031323334package OtherAdvice.anno;public class Student &#123; /* 成员变量 */ private Integer age; private String name; /** 抛出异常 */ public void printThrowException()&#123; System.out.println("出现异常..."); throw new IllegalArgumentException(); &#125; /* 设值函数 */ public Integer getAge() &#123; System.out.println(" age:"+age); return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; System.out.println(" name:"+name); return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Logger.java123456789101112131415161718192021222324252627282930313233343536373839package OtherAdvice.anno;import org.aspectj.lang.annotation.*;@Aspectpublic class Logger &#123; /** 切入点 */ @Pointcut(value = "execution(* OtherAdvice.anno.*.*(..))") public void all()&#123;&#125;; /** 前置通知 */ @Before("all()") public void beforeAdvice()&#123; System.out.println("------"); System.out.println("~前置通知"); &#125; /** 后置通知 */ @AfterReturning(pointcut = "all()", returning = "retVal") public void afterReturningAdvice(Object retVal)&#123; System.out.println("~后置通知:" + retVal.toString() ); &#125; /** 异常通知 */ @AfterThrowing(pointcut = "all()", throwing = "ex") public void afterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println("~异常通知： " + ex.toString()); &#125; /** 最终通知 */ @After("all()") public void afterAdvice()&#123; System.out.println("~最终通知"); &#125;&#125; Beans.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "&gt; &lt;!-- 通知类 --&gt; &lt;bean id="logging" class="OtherAdvice.anno.Logger"/&gt; &lt;!-- 目标类 --&gt; &lt;bean id="student" class="OtherAdvice.anno.Student"&gt; &lt;property name="name" value="cat"/&gt; &lt;property name="age" value="1"/&gt; &lt;/bean&gt; &lt;!-- 开启注解支持 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; SpringTest.java1234567891011121314151617181920212223package cn.water.test.OtherAdvice.anno;import OtherAdvice.anno.Student;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest &#123; @Test public void test()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("OtherAdvice/anno/Beans.xml"); /* 2、获取Bean对象 */ Student student = app.getBean("student", Student.class); /* 3、调用方法 */ student.getAge(); student.getName(); student.printThrowException(); &#125;&#125; 四大通知基于xml通知类1234567891011121314151617181920212223242526/** 环绕通知 */public Object roundAdvice(ProceedingJoinPoint joinPoint)&#123; Object result = null; try &#123; /** 前置通知 */ System.out.println("------"); System.out.println("~前置通知"); /* 获取切入点方法的参数列表 */ Object[] args = joinPoint.getArgs(); /* 调用切入点方法，获取返回值 */ result = joinPoint.proceed(args); /** 后置通知 */ System.out.println("~后置通知:" + result.toString()); /* 返回 */ return result; &#125; catch (Throwable throwable) &#123; /** 异常通知 */ System.out.println("~异常通知： " + throwable); throw new RuntimeException(); &#125; finally &#123; /** 最终通知 */ System.out.println("~最终通知"); &#125;&#125; 配置文件 添加AOP框架 aop:aspect：切面 aop:pointcut：切入点 aop:around：环绕方法 12345678910&lt;!-- Spring AOP框架 --&gt;&lt;aop:config&gt; &lt;!-- 切面（Aspect） --&gt; &lt;aop:aspect id="log" ref="logging"&gt; &lt;!-- 切入点（Pointcut） --&gt; &lt;aop:pointcut id="all" expression="execution(* AroundAdvice.xml.*.*(..))"/&gt; &lt;!-- 通知（Advice） --&gt; &lt;aop:around method="roundAdvice" pointcut-ref="all"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 运行结果123456789101112131415------~前置通知 age:1~后置通知:1~最终通知------~前置通知 name:cat~后置通知:cat~最终通知------~前置通知出现异常...~异常通知： java.lang.IllegalArgumentException~最终通知 基于注解通知类 添加注解 @Aspect：切面 @Pointcut：切入点 @Before：前置方法 @AfterReturning：后置方法 @AfterThrowing：异常方法 @After：最终方法 123456789101112131415161718192021222324252627282930313233@Aspectpublic class Logger &#123; /** 切入点 */ @Pointcut(value = "execution(* OtherAdvice.anno.*.*(..))") public void all()&#123;&#125;; /** 前置通知 */ @Before("all()") public void beforeAdvice()&#123; System.out.println("------"); System.out.println("~前置通知"); &#125; /** 后置通知 */ @AfterReturning(pointcut = "all()", returning = "retVal") public void afterReturningAdvice(Object retVal)&#123; System.out.println("~后置通知:" + retVal.toString() ); &#125; /** 异常通知 */ @AfterThrowing(pointcut = "all()", throwing = "ex") public void afterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println("~异常通知： " + ex.toString()); &#125; /** 最终通知 */ @After("all()") public void afterAdvice()&#123; System.out.println("~最终通知"); &#125;&#125; 配置文件 开启注解支持 1&lt;aop:aspectj-autoproxy/&gt; 运行结果 运行顺序有误！！！ 123456789101112131415------~前置通知 age:1~最终通知~后置通知:1------~前置通知 name:cat~最终通知~后置通知:cat------~前置通知出现异常...~最终通知~异常通知： java.lang.IllegalArgumentException 环绕通知基于xml通知类1234567891011121314151617/** 前置通知 */public void beforeAdvice()&#123; System.out.println("------"); System.out.println("~前置通知");&#125;/** 后置通知 */public void afterReturningAdvice(Object retVal)&#123; System.out.println("~后置通知:" + retVal.toString() );&#125;/** 异常通知 */public void afterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println("~异常通知： " + ex.toString());&#125;/** 最终通知 */public void afterAdvice()&#123; System.out.println("~最终通知");&#125; 配置文件 添加AOP框架 aop:aspect：切面 aop:pointcut：切入点 aop:before：前置方法 aop:afterReturning：后置方法 aop:afterThrowing：异常方法 aop:after：最终方法 12345678910111213&lt;!-- Spring AOP框架 --&gt;&lt;aop:config&gt; &lt;!-- 切面（Aspect） --&gt; &lt;aop:aspect id="log" ref="logging"&gt; &lt;!-- 切入点（Pointcut） --&gt; &lt;aop:pointcut id="all" expression="execution(* OtherAdvice.xml.*.*(..))"/&gt; &lt;!-- 通知（Advice） --&gt; &lt;aop:before method="beforeAdvice" pointcut-ref="all" /&gt; &lt;aop:after-returning method="afterReturningAdvice" returning="retVal" pointcut-ref="all"/&gt; &lt;aop:after-throwing method="afterThrowingAdvice" throwing="ex" pointcut-ref="all"/&gt; &lt;aop:after method="afterAdvice" pointcut-ref="all"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 运行结果123456789101112131415------~前置通知 age:1~后置通知:1~最终通知------~前置通知 name:cat~后置通知:cat~最终通知------~前置通知出现异常...~异常通知： java.lang.IllegalArgumentException~最终通知 基于注解通知类 添加注解 @Aspect：切面 @Pointcut：切入点 @Before：前置方法 @AfterReturning：后置方法 @AfterThrowing：异常方法 @After：最终方法 1234567891011121314151617181920212223242526272829303132333435@Aspectpublic class Logger &#123; /** 切入点 */ @Pointcut(value = "execution(* AroundAdvice.anno.*.*(..))") public void all()&#123;&#125;; /** 环绕通知 */ @Around("all()") public Object roundAdvice(ProceedingJoinPoint joinPoint)&#123; Object result = null; try &#123; /** 前置通知 */ System.out.println("------"); System.out.println("~前置通知"); /* 获取切入点方法的参数列表 */ Object[] args = joinPoint.getArgs(); /* 调用切入点方法，获取返回值 */ result = joinPoint.proceed(args); /** 后置通知 */ System.out.println("~后置通知:" + result.toString()); /* 返回 */ return result; &#125; catch (Throwable throwable) &#123; /** 异常通知 */ System.out.println("~异常通知： " + throwable); throw new RuntimeException(); &#125; finally &#123; /** 最终通知 */ System.out.println("~最终通知"); &#125; &#125;&#125; 配置文件 开启注解支持 1&lt;aop:aspectj-autoproxy/&gt; 运行结果123456789101112131415------~前置通知 age:1~后置通知:1~最终通知------~前置通知 name:cat~后置通知:cat~最终通知------~前置通知出现异常...~异常通知： java.lang.IllegalArgumentException~最终通知]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 —— Proxy 代理模式]]></title>
    <url>%2F2019%2F08%2F20%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F8.Proxy%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介 Proxy代理模式是一种结构型设计模式。通过代理模式可以实现程序之间的解耦，可以解决在直接访问对象时带来的程序之间耦合度增大的问题。 按照代理的创建时期，代理类分为两种： 静态代理：在编译期，手动创建代理类，而不是由编译器生成代理类。 动态代理：在运行期，运用反射机制动态而生成代理类。 JDK代理基于接口接口 CGlib代理基于继承 静态代理 优点 静态代理可以将目标类和目标方法封装起来，有隐蔽的作用。 缺点 静态代理类只能为特定的接口服务。 如想要为多个接口服务则需要建立很多个代理类。 目录结构 cn.water main java IProducer.java（接口） Producer.java（实现类） ProxyProducer.java（代理类） test staticTest.java（测试类） 接口IProducer.java1234567891011package cn.water.StaticProxy;public interface IProducer &#123; /** 销售 */ void saleProduct(float money); /** 售后 */ void afterService(float money);&#125; 实现类Producer.java1234567891011121314package cn.water.StaticProxy;public class Producer implements IProducer &#123; /** 销售 */ public void saleProduct(float money) &#123; System.out.println("生产者：通过[销售]，获得了"+money+"元"); &#125; /** 售后 */ public void afterService(float money) &#123; System.out.println("生产者：通过[售后]，获得了"+money+"元"); &#125;&#125; 代理类ProxyProducer.java123456789101112131415161718package cn.water.StaticProxy;public class ProxyProducer implements IProducer &#123; private Producer producer = new Producer(); /** 销售 */ public void saleProduct(float money) &#123; System.out.println("消费者：消费了"+money+"元"); producer.saleProduct(money * 0.2f); &#125; /** 售后 */ public void afterService(float money) &#123; System.out.println("消费者：消费了"+money+"元"); producer.afterService(2); &#125;&#125; 测试类staticTest.java1234567891011121314151617181920212223242526package cn.water.test;import cn.water.StaticProxy.IProducer;import cn.water.StaticProxy.Producer;import cn.water.StaticProxy.ProxyProducer;import org.junit.Test;public class staticTest &#123; @Test public void test()&#123; /** 成员变量 */ final Producer producer = new Producer(); /** 获取动态代理对象 */ IProducer proxy = new ProxyProducer() ; /** 调用方法 */ /* 销售方法经过加强，增强的方法被调用 */ proxy.saleProduct(999.12f); /* 销售方法经过加强，方法不被调用 */ proxy.afterService(99f); &#125;&#125; 动态代理（JDK） JDK动态代理基于 Java的反射机制 实现。 因为Java的反射机制基于接口，所以目标类一定要有接口。 基于JDK技术动态代理类技术核心：Proxy类 和 InvocationHandler接口。（java.lang.reflect） Proxy类中定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class... interfaces)，返回class实例代表一个class文件。生成的动态代理类继承Proxy类(重要特性) ，并实现公共接口。 InvocationHandler接口 是被动态代理类回调的接口，我们所有需要增加的处理逻辑都添加到 invoke方法里面。 匿名内部类参数必须为final类型 目录结构 cn.water IProducer.java（接口） Producer.java（实现类） test staticTest.java（测试类） 接口IProducer.java1234567891011package cn.water.DynamicProxy.jdk;public interface IProducer &#123; /** 销售 */ void saleProduct(float money); /** 售后 */ void afterService(float money);&#125; 实现类Producer.java1234567891011121314package cn.water.DynamicProxy.jdk;public class Producer implements IProducer &#123; /** 销售 */ public void saleProduct(float money) &#123; System.out.println("生产者：通过[销售]，获得了"+money+"元"); &#125; /** 售后 */ public void afterService(float money) &#123; System.out.println("生产者：通过[售后]，获得了"+money+"元"); &#125;&#125; 测试类staticTest.java Proxy.newProxyInstance方法 加载器 接口 InvocationHandler接口 invoke方法 method：代表方法 args：参数 匿名内部类只能访问方法内修饰符为final的参数 为了保持数据的一致性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.water.test;import cn.water.DynamicProxy.jdk.IProducer;import cn.water.DynamicProxy.jdk.Producer;import org.junit.Test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class jdkTest &#123; @Test public void test()&#123; /** 1、成员变量 */ final Producer producer = new Producer(); /** 2、获取动态代理对象 */ IProducer proxy = (IProducer) Proxy.newProxyInstance( /* 类加载器 */ producer.getClass().getClassLoader(), /* 实现类的接口 */ producer.getClass().getInterfaces(), /** 增强代码 */ new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; /* 方法参数 */ Float money = (Float) args[0]; /* 方法名 */ if ("saleProduct".equals(method.getName())) &#123; /* 调用方法 */ System.out.println("消费者：消费了"+money+"元"); result = method.invoke(producer, money * 0.2f); &#125; if ("afterService".equals(method.getName())) &#123; /* 调用方法 */ System.out.println("消费者：消费了"+money+"元"); result = method.invoke(producer, 5); &#125; /* 返回 */ return result; &#125; &#125; ); /** 3、调用方法 */ /* 销售方法经过加强，增强的方法被调用 */ proxy.saleProduct(999.12f); /* 销售方法经过加强，方法不被调用 */ proxy.afterService(999.12f); &#125;&#125; 动态代理（cglib）目录结构 cn.water Producer.java（类） test staticTest.java（测试类） 实现类Producer.java12345678910111213141516package cn.water.DynamicProxy.cglib;import cn.water.DynamicProxy.jdk.IProducer;public class Producer &#123; /** 销售 */ public void saleProduct(float money) &#123; System.out.println("生产者：通过[销售]，获得了"+money+"元"); &#125; /** 售后 */ public void afterService(float money) &#123; System.out.println("生产者：通过[售后]，获得了"+money+"元"); &#125;&#125; 测试类 Enhancer.create方法 字节码 MethodInterceptor接口 intercept方法 method：代表方法 args：参数 staticTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.water.test;import cn.water.DynamicProxy.cglib.Producer;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import org.junit.jupiter.api.Test;import java.lang.reflect.Method;public class cglibTest &#123; @Test public void test() &#123; /** 1、成员变量 */ final Producer producer = new Producer(); /** 2、获取动态代理对象 */ Producer cglibProducer = (Producer) Enhancer.create( /* 字节码 */ producer.getClass(), /* CallBack子类 */ new MethodInterceptor() &#123; /** 增强代码 */ public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object result = null; /* 方法参数 */ Float money = (Float) args[0]; /* 方法名 */ if ("saleProduct".equals(method.getName())) &#123; /* 调用方法 */ System.out.println("消费者：消费了"+money+"元"); result = method.invoke(producer, money * 0.2f); &#125; if ("afterService".equals(method.getName())) &#123; /* 调用方法 */ System.out.println("消费者：消费了"+money+"元"); result = method.invoke(producer, 5); &#125; /* 返回 */ return result; &#125; &#125;); /** 3、调用方法 */ /* 销售方法经过加强，增强的方法被调用 */ cglibProducer.saleProduct(999.12f); /* 销售方法经过加强，方法不被调用 */ cglibProducer.afterService(999.12f); &#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;设计模式&lt;/b&gt;</category>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架07 —— CRUD操作案例]]></title>
    <url>%2F2019%2F08%2F19%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F7.%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[简介 本文将在 Spring 框架中，分别使用使用“XML”，“XML+注解”和“注解”三种方式来实现数据库的CRUD操作。实现数据库的CRUD操作的功能属于另外一部分的知识点，三种方式的不同点主要在于如何注入依赖。 基于xml配置文件 依赖注入：xml配置文件 开启注解扫描：xml配置文件 基于xml配置文件和注解 依赖注入：注解 开启注解扫描：注解、xml配置文件 基于注解 依赖注入：注解 开启注解扫描：Java配置文件 项目环境数据库代码 创建数据库spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE spring;# 使用数据库USE spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); Maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;dependencies&gt; &lt;!-- Spring 框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 操作数据库的工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 基于xml配置文件 此部分分为三部分 目录结构：帮助了解整个项目的基本结构，以及完整详细的代码。 依赖注入：此部分是本文着重比较的地方，单独分为一部分。 CURD操作：与Spring框架的核心内容关系不大，可作为延展内容。 目录结构 src main java domain Account.java（实体类） service AccountService.java（业务层接口） AccountServiceImp.java（业务层实现类） dao AccountDao.java（持久层接口） AccountDaoImp.java（持久层实习类） resources Beans.xml（Spring配置文件） test SpringTest.java（测试类） 实体类 实体类根据数据库表中的字段来设置成员变量。 Account.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package xml.domain;public class Account &#123; /* 成员变量 */ private int id; private String name; private float money; /* 构造函数 */ public Account() &#123; &#125; public Account(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /* 设值函数 */ public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getMoney() &#123; return money; &#125; public void setMoney(float money) &#123; this.money = money; &#125; /* toString方法 */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 业务层 由于此案例是为了演示操作数据库的CRUD方法，所以业务层并没有实现具体功能，而只是注入了持久层接口，调用了持久层方法。 AccountService.java12345678910111213141516171819202122232425package xml.service;import xml.domain.Account;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:50 * @description 业务层接口 */public interface AccountService &#123; /** 查询所有 */ List&lt;Account&gt; findAll(); /** 查询单个 */ Account findByID(int id); /** 添加 */ void add(Account account); /** 修改 */ void update(Account account); /** 删除 */ void delete(int id);&#125; AccountServiceImp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package xml.service;import xml.dao.AccountDao;import xml.domain.Account;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:51 * @description 业务层实现类 */public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ private AccountDao dao; /* 设值方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /** 查询单个 */ public Account findByID(int id) &#123; return dao.findByID(id); &#125; /** 添加 */ public void add(Account account) &#123; dao.add(account); &#125; /** 修改 */ public void update(Account account) &#123; dao.update(account); &#125; /** 删除 */ public void delete(int id) &#123; dao.delete(id); &#125;&#125; 持久层AccountDao.java12345678910111213141516171819202122232425package xml.dao;import xml.domain.Account;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:50 * @description 持久层接口：实现数据库具体的CRUD操作 */public interface AccountDao &#123; /** 查询所有 */ List&lt;Account&gt; findAll(); /** 查询单个 */ Account findByID(int id); /** 添加 */ void add(Account account); /** 修改 */ void update(Account account); /** 删除 */ void delete(int id);&#125; AccountDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package xml.dao;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import xml.domain.Account;import java.sql.SQLException;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:52 * @description 持久层实现类：实现数据库具体的CRUD操作 */public class AccountDaoImp implements AccountDao &#123; /* 成员方法 */ private QueryRunner queryRunner; /* 设值方法 */ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 查询单个 */ public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 添加 */ public void add(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 修改 */ public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 删除 */ public void delete(int id) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 配置文件Beans.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- QueryRunner：注入DataSource --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- DaoImp：注入QueryRunner --&gt; &lt;bean id="daoImp" class="xml.dao.AccountDaoImp"&gt; &lt;property name="queryRunner" ref="runner"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ServiceImp：注入DaoImp --&gt; &lt;bean id="serviceImp" class="xml.service.AccountServiceImp"&gt; &lt;property name="dao" ref="daoImp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类SpringTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package test.xml;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import xml.domain.Account;import xml.service.AccountService;/** * @author Water * @date 2019/10/24 - 10:07 * @description */public class SpringTest &#123; /* 成员变量 */ private ApplicationContext app; private AccountService service; @Before public void init()&#123; app = new ClassPathXmlApplicationContext("xml/Beans.xml"); service = app.getBean("serviceImp",AccountService.class); &#125; /** 查询所有 */ @Test public void test01() &#123; for (Account account : service.findAll()) &#123; System.out.println(account); &#125; &#125; /** 查询单个 */ @Test public void test02() &#123; System.out.println(service.findByID(1)); &#125; /** 添加 */ @Test public void test03() &#123; service.add( new Account(4,"pig",39.11F) ); &#125; /** 修改 */ @Test public void test04() &#123; service.update( new Account(4,"pig",9999.11F) ); &#125; /** 删除 */ @Test public void test05() &#123; service.delete(4); &#125;&#125; 依赖注入基于xml的方式 ServiceImp Dao（设值函数） DaoImp QueryRunner（设值函数） QueryRunner DataSource（构造函数） 12345678910111213141516171819202122&lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- QueryRunner：注入DataSource --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- DaoImp：注入QueryRunner --&gt; &lt;bean id="daoImp" class="xml.dao.AccountDaoImp"&gt; &lt;property name="queryRunner" ref="runner"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ServiceImp：注入DaoImp --&gt; &lt;bean id="serviceImp" class="xml.service.AccountServiceImp"&gt; &lt;property name="dao" ref="daoImp"&gt;&lt;/property&gt; &lt;/bean&gt; CRUD操作查询所有用户持久层接口1List&lt;Account&gt; findAll(); 持久层实现类123456789101112public List&lt;Account&gt; findAll() &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125;&#125; 根据ID查询用户持久层接口1Account findByID(int id); 持久层实现类12345678910111213public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125;&#125; 添加用户持久层接口1void add(Account account); 持久层实现类1234567891011121314public void add(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 修改用户持久层接口1void update(Account account); 持久层实现类1234567891011121314public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 删除用户持久层接口1void delete(int id); 持久层实现类123456789101112public void delete(int id) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 基于xml配置文件和注解此部分分为两部分 目录结构：帮助了解整个项目的基本结构、如果想要阅读项目完整详细的代码，请阅读“基于xml配置文件”内容。此部分仅展示在“基于xml配置文件”基础上更新的详细代码。 依赖注入：此部分是本文着重比较的地方，单独分为一部分。 目录结构 src main java domain Account.java（实体类） service AccountService.java（业务层接口） AccountServiceImp.java（业务层实现类） dao AccountDao.java（持久层接口） AccountDaoImp.java（持久层实习类） resources Beans.xml（Spring配置文件） test SpringTest.java（测试类） 业务层 实现类AccountServiceImp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package xml_anno.service;import org.springframework.stereotype.Component;import xml_anno.dao.AccountDao;import xml_anno.domain.Account;import javax.annotation.Resource;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:51 * @description 业务层实现类 */@Component("serviceImp")public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ @Resource(name = "daoImp") private AccountDao dao; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /** 查询单个 */ public Account findByID(int id) &#123; return dao.findByID(id); &#125; /** 添加 */ public void add(Account account) &#123; dao.add(account); &#125; /** 修改 */ public void update(Account account) &#123; dao.update(account); &#125; /** 删除 */ public void delete(int id) &#123; dao.delete(id); &#125;&#125; 持久层 实现类AccountDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package xml_anno.dao;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.stereotype.Component;import xml_anno.domain.Account;import javax.annotation.Resource;import java.sql.SQLException;import java.util.List;/** * @author Water * @date 2019/10/24 - 8:52 * @description 持久层实现类：实现数据库具体的CRUD操作 */@Component("daoImp")public class AccountDaoImp implements AccountDao &#123; /* 成员方法 */ @Resource(name = "runner") private QueryRunner queryRunner; /** 查询所有 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account ", /* 结果集 */ new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 查询单个 */ public Account findByID(int id) &#123; try &#123; /* QueryRunner.query */ return queryRunner.query( /* SQL语句 */ "SELECT * FROM account WHERE id = ? ", /* 结果集 */ new BeanHandler&lt;Account&gt;(Account.class), id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** 添加 */ public void add(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ "INSERT INTO account VALUES(?,?,?)", /* 参数 */ account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 修改 */ public void update(Account account) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " UPDATE account SET name=?,money=? WHERE id=? ", /* 参数 */ account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** 删除 */ public void delete(int id) &#123; try &#123; /* QueryRunner.update */ queryRunner.update( /* SQL语句 */ " DELETE FROM account WHERE id=? ", /* 参数 */ id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 配置文件Beans.xml12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="xml_anno"&gt;&lt;/context:component-scan&gt; &lt;!-- DataSource --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- QueryRunner：注入DataSource --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类SpringTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package test.xml_anno;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import xml_anno.domain.Account;import xml_anno.service.AccountService;/** * @author Water * @date 2019/10/24 - 10:07 * @description */public class SpringTest &#123; /* 成员变量 */ private ApplicationContext app; private AccountService service; @Before public void init()&#123; app = new ClassPathXmlApplicationContext("xml_anno/Beans.xml"); service = app.getBean("serviceImp",AccountService.class); &#125; /** 查询所有 */ @Test public void test01() &#123; for (Account account : service.findAll()) &#123; System.out.println(account); &#125; &#125; /** 查询单个 */ @Test public void test02() &#123; System.out.println(service.findByID(1)); &#125; /** 添加 */ @Test public void test03() &#123; service.add( new Account(4,"pig",39.11F) ); &#125; /** 修改 */ @Test public void test04() &#123; service.update( new Account(4,"pig",9999.11F) ); &#125; /** 删除 */ @Test public void test05() &#123; service.delete(4); &#125;&#125; 依赖注入基于注解的方式 ServiceImp Dao（设值函数） DaoImp QueryRunner（设值函数） ServiceImp12345678@Component("serviceImp")public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ @Resource(name = "daoImp") private AccountDao dao;&#125; DaoImp1234567@Component("daoImp")public class AccountDaoImp implements AccountDao &#123; @Resource(name = "runner") private QueryRunner queryRunner;&#125; 基于xml的方式 开启注解支持 QueryRunner DataSource（构造函数） 123456789101112131415 &lt;!-- 开启注解扫描 --&gt;&lt;context:component-scan base-package="xml_anno"&gt;&lt;/context:component-scan&gt;&lt;!-- DataSource --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;=&lt;/bean&gt;&lt;!-- QueryRunner：注入DataSource --&gt;&lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 基于注解 目录结构：帮助了解整个项目的基本结构、如果想要阅读项目完整详细的代码，请阅读“基于xml配置文件”内容。此部分仅展示在“基于xml配置文件和注解”基础上更新的详细代码。 依赖注入：此部分是本文着重比较的地方，单独分为一部分。 目录结构 src main java config SpringConfiguration.java（Java配置文件） domain Account.java（实体类） service AccountService.java（业务层接口） AccountServiceImp.java（业务层实现类） dao AccountDao.java（持久层接口） AccountDaoImp.java（持久层实习类） resources jdbcConfiguration.properties（数据库连接参数） test SpringTest.java（测试类） Java配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package java_anno.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbutils.QueryRunner;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.*;import javax.sql.DataSource;import java.beans.PropertyVetoException;/** * @author Water * @date 2019/10/24 - 11:57 * @description 基于纯注解方式的Java配置文件 *//** 指定配置文件 */@Configuration/** 开启注解扫描 */@ComponentScan("java_anno")/** 指定property文件 */@PropertySource("classpath:java_anno/jdbcConfig.properties")public class SpringConfiguration &#123; /* 定义容器 */ @Bean("runner") /* 作用范围 */ @Scope("prototype") /* 返回值类型：容器类型 | 方法名称：无所谓 | 参数：类成员 | @Qualifier注解：指定容器id */ public QueryRunner getQueryRunner( @Qualifier("dataSource")DataSource getDS)&#123; /* 返回值：容器 */ return new QueryRunner(getDS); &#125; /** 数据库连接参数 */ @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /* 定义容器 */ @Bean("dataSource") /* 返回值类型：容器类型 | 方法名称：无所谓 | 参数：类成员 */ public DataSource getDataSource()&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); try &#123; dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return dataSource; &#125;&#125; 数据库连接文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=root 依赖注入基于注解 ServiceImp Dao（设值函数） DaoImp QueryRunner（设值函数） QueryRunner DataSource（构造函数） ServiceImp12345678@Component("serviceImp")public class AccountServiceImp implements AccountService &#123; /* 成员变量 */ @Resource(name = "daoImp") private AccountDao dao;&#125; DaoImp1234567@Component("daoImp")public class AccountDaoImp implements AccountDao &#123; @Resource(name = "runner") private QueryRunner queryRunner;&#125; QueryRunner123456789/* 定义容器 */@Bean("runner")/* 作用范围 */@Scope("prototype")/* 返回值类型：容器类型 | 方法名称：无所谓 | 参数：类成员 | @Qualifier注解：指定容器id */public QueryRunner getQueryRunner( @Qualifier("dataSource")DataSource getDS)&#123; /* 返回值：容器 */ return new QueryRunner(getDS);&#125; DataSource1234567891011121314151617181920212223242526/** 数据库连接参数 */@Value("$&#123;jdbc.driver&#125;")private String driver;@Value("$&#123;jdbc.url&#125;")private String url;@Value("$&#123;jdbc.username&#125;")private String username;@Value("$&#123;jdbc.password&#125;")private String password;/* 定义容器 */@Bean("dataSource")/* 返回值类型：容器类型 | 方法名称：无所谓 | 参数：类成员 */public DataSource getDataSource()&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); try &#123; dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return dataSource;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DI</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架06 —— 基于注解的配置方式]]></title>
    <url>%2F2019%2F08%2F17%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F6.%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介 之前我们学习了基于xml文件的配置方法，今天我们学习基于注解的配置方法。 目录结构 src main java cn.water POJO.java TextEditor.java SpellCheck.java resources Beans.xml test java cn.water.test SpringTest.java 开启注解扫描 在使用基于注解的注入依赖之前，我们需要在 Spring 配置文件中指定需要 Spring 去自动扫描出注解配置的文件的包。一旦 被配置后，你就可以开始注解你的代码，表明 Spring 会自动连接值到属性，方法和构造函数。 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 定义容器 让我们来看看几个重要的注解，并且了解它们是如何工作的。 @Component 注解：用于定义一个Bean对象。 Value属性：用于指定 Bean对象的唯一标识。 默认为当前类名，首字母小写。 另外，和 @Component 注解功能相同的注解还有另外三个，除了定义 Spring Bean 的功能之外，它们主要用于标识三层构架： @Controller：表现层 @Service：业务层 @Repository：持久层 实体类12345@Component("pojo")public class POJO &#123;&#125; 作用范围 @scope注解：用于指定Bean对象的作用范围。 Value属性：singleton单例（默认）、prototype多例 单例实体类123456@Component("pojo")@Scope("singleton")public class POJO &#123;&#125; 多例实体类123456@Component("pojo")@Scope("prototype")public class POJO &#123;&#125; 生命周期实体类 @PreDestroy：用于指定Bean对象的销毁方法。 @PostConstruct：用于指定Bean对象的初始化方法。 12345678910111213141516@Component("pojo")public class POJO &#123; /* 初始化方法 */ @PostConstruct public void init() &#123; System.out.println("POJO类：初始化成功！"); &#125; /* 销毁方法 */ @PreDestroy public void destroy() &#123; System.out.println("POJO类：销毁成功！"); &#125;&#125; 生命周期/作用范围 立即加载 非常符合 单例模式 的特点，ApplicationContext 就属于立即加载。 所以一旦我们创建 ApplicationContext 容器，就会立即加载所有的POJO对象，即使我们还没有获取对象；而一旦我们注销 ApplicationContext 容器，POJO对象就被销毁了。 而 多例模式 更符合 延迟加载，也就是 BeanFactory 容器。 如果在多例模式在，使用 ApplicationContext 容器的话，那么 ApplicationContext 容器 的特点就会失效，并且改成 BeanFactory 容器的特点。就是说，只有我们从容器中获取POJO对象时，POJO对象才会被创建；而且只有POJO对象被销毁时，销毁方法才会执行。 实体类POJO01.java1234567891011121314151617@Component("pojo01")@Scope("singleton")public class POJO01 &#123; /* 初始化方法 */ @PostConstruct public void init() &#123; System.out.println("POJO类：初始化成功！"); &#125; /* 销毁方法 */ @PreDestroy public void destroy() &#123; System.out.println("POJO类：销毁成功！"); &#125;&#125; POJO02.java1234567891011121314151617@Component("pojo02")@Scope("prototype")public class POJO02 &#123; /* 初始化方法 */ @PostConstruct public void init() &#123; System.out.println("POJO类：初始化成功！"); &#125; /* 销毁方法 */ @PreDestroy public void destroy() &#123; System.out.println("POJO类：销毁成功！"); &#125;&#125; 测试类单例 ApplicationContext容器创建时，Bean对象初始化。 ApplicationContext容器销毁时，Bean对象销毁。 12345678@Testpublic void test01() &#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("Scope_LifeCycle/Beans.xml"); /* 2、注销容器 */ ((ClassPathXmlApplicationContext)app).close();&#125; 多例 从容器中获取Bean对象时，Bean对象初始化。 Bean对象被Java回收器机制销毁时销毁。 123456789@Testpublic void test02() &#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("Scope_LifeCycle/Beans.xml"); /* 2、获取Bean对象 */ POJO02 pojo02 = app.getBean("pojo02", POJO02.class); /* 3、注销容器 */ ((ClassPathXmlApplicationContext)app).close();&#125; 运行结果单例 POJO（单例）初始化 POJO（单例）销毁 12POJO类：初始化成功！POJO类：销毁成功！ 多例 POJO（单例）初始化 POJO（多例）初始化 POJO（单例）销毁 123POJO类：初始化成功！POJO类：初始化成功！POJO类：销毁成功！ 依赖注入@Resource 注解 基于注解的依赖注入，不需要构造方法或者Setter方法。 工作原理： Bean对象 Key：@Component 注释 Value属性值 pojo Value：被 @Component 注释的类 POJO POJO对象 对应Key：@Resource注释的 name属性值 pojo SpellCheck12345@Component("check")public class SpellCheck &#123;&#125; TextEditor @Resource注解 name属性：依赖注入 1234567@Component("editor")public class TextEditor &#123; @Resource(name = "check") private SpellCheck spellCheck;&#125; @Autowired 注解 自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为bean的id。 在 @Autowired 注解中，Spring 框架先对应Bean的Value而不是Key。 工作原理： Bean对象 Key：@Component 注释 Value属性值 pojo Value：被 @Component 注释的类 POJO POJO对象 对应Value：被 @Autowired 注释的类成员的类型 POJO SpellCheck12345@Component("check")public class SpellCheck &#123;&#125; TextEditor @Autowired注解：自动注入依赖 1234567@Component("editor")public class TextEditor &#123; @Autowired private SpellCheck spellCheck;&#125; @Qualifier 注解 @Qualifier：和@Autowired一起使用，解决无法注入相同的数据类型不同变量的问题。 在类成员上，和@Autowired一起使用。 在方法上，可以单独使用。 工作原理： Bean对象 Key：@Component 注释 Value属性值 pojo Value：被 @Component 注释的类 POJO POJO对象 对应Value：被 @Autowired 注释的类成员的类型 POJO 对应Key：@Qualifier注释 value属性的值 pojo SpellCheck12345@Component("check")public class SpellCheck &#123;&#125; TextEditor @Autowired注解：自动注入依赖 @Qualifier注解：指定被注入的Bean对象的id 12345678910111213141516171819202122@Component("editor")public class TextEditor &#123; /* 成员变量 */ @Autowired @Qualifier("check") private SpellCheck spellCheck01; @Autowired @Qualifier("check") private SpellCheck spellCheck02; /* Getter：测试是否注入成功 */ public SpellCheck getSpellCheck01() &#123; return spellCheck01; &#125; public SpellCheck getSpellCheck02() &#123; return spellCheck02; &#125;&#125; @Value 注解 自动按照类型注入，它可以使用spring中SqEL表达式。 SpellCheck12345678910@Component("check")public class SpellCheck &#123; @Value("#&#123;'Cat'&#125;") public String name; @Value("#&#123;1&#125;") public int id;&#125; TextEditor @Value注解：指定被注入的Bean对象的id 1234567891011121314151617181920212223@Component("editor")public class TextEditor &#123; /* 成员变量 */ @Value("#&#123;'Cat'&#125;") private String s; @Value("#&#123;999&#125;") private int i; @Value("#&#123;12.13&#125;") private float f; @Value("#&#123;check&#125;") private SpellCheck spellCheck; @Value("#&#123;check.name&#125;") private String username; @Value("#&#123;check.id&#125;") private int userid;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架05 —— 自动装配]]></title>
    <url>%2F2019%2F08%2F16%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F5.%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring Beans 自动装配 我们已经学会如何使用&lt;bean&gt;元素来声明 bean 和通过使用 XML 配置文件中的&lt;constructor-arg&gt;和&lt;property&gt;元素来注入 。而Spring 容器还可以在不使用&lt;constructor-arg&gt;和&lt;property&gt; 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。 自动装配模式 下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用&lt;bean&gt;元素的 autowire 属性为一个 bean 定义指定自动装配模式。 no 默认设置，它意味着没有自动装配，表示我们需要使用显式的bean引用来注入依赖。 byName 由属性名自动装配。 Spring 先匹配POJO类的类成员名称与配置文件中&lt;bean&gt;标签的id属性，如果名称相同，则匹配类型；类型相同，则配对成功。 byType 由属性数据类型自动装配。 Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 constructor 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 autodetect Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。 自动装配的局限性 当自动装配始终在同一个项目中使用时，它的效果最好。如果通常不使用自动装配，它可能会使开发人员混淆的使用它来连接只有一个或两个 bean 定义。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。 重写的可能性 你可以使用总是重写自动装配的 &lt;constructor-arg&gt;和 &lt;property&gt; 设置来指定依赖关系。 原始数据类型 你不能自动装配所谓的简单类型包括基本类型，字符串和类。 混乱的本质 自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。 Spring 自动装配 ‘byName’ 这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 auto-wire 属性设置为 byName。然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为自动装配 byName，并且它包含 spellChecker 属性（即，它有一个 setSpellChecker(…) 方法），那么 Spring 就会查找定义名为 spellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用 &lt;property&gt; 标签连接其余的属性。下面的例子将说明这个概念。 （1）TextEditor 12345678910111213141516171819202122package cn.water.spring_autowire.byName;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* Setter方法 */ public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; /* Getter方法 */ public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker 1234567891011121314package cn.water.spring_autowire.byName;public class SpellChecker &#123; /* 构造函数 */ public SpellChecker()&#123; System.out.println("SpellChecker constructor" ); &#125; /* 成员方法 */ public void checkSpelling() &#123; System.out.println("checkSpelling..." ); &#125;&#125; （3）Beans.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- TextEditor --&gt; &lt;bean id="textEditor" class="cn.water.spring_autowire.byName.TextEditor" autowire="byName"&gt; &lt;/bean&gt; &lt;!-- SpellChecker id属性：类成员名称 --&gt; &lt;bean id="spellChecker" class="cn.water.spring_autowire.byName.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 12345678910111213141516package cn.water.spring_autowire.byName;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext context = new ClassPathXmlApplicationContext("spring_autowire/byName/Beans.xml"); /* 2.获取对象 */ TextEditor editor = (TextEditor) context.getBean("textEditor"); /* 3.调用方法 */ editor.spellCheck(); &#125;&#125; （5）结果 12SpellChecker constructorcheckSpelling... Spring 自动装配 ‘byType’ 这种模式由属性类型指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire 属性设置为 byType。然后，如果它的 type 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为自动装配 byType*，并且它包含 *SpellChecker 类型的 spellChecker 属性，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用&lt;property&gt; 标签连接其余属性。下面的例子将说明这个概念，你会发现和上面的例子没有什么区别，除了 XML 配置文件已经被改变。 （1）TextEditor 1234567891011121314151617package cn.water.spring_autowire.byType;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* Setter方法 */ public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker（3）Beans.xml 1234567891011&lt;!-- TextEditor --&gt;&lt;bean id="textEditor" class="cn.water.spring_autowire.byType.TextEditor" autowire="byType"&gt;&lt;/bean&gt;&lt;!-- SpellChecker id属性：类型名称 --&gt;&lt;bean id="SpellChecker" class="cn.water.spring_autowire.byType.SpellChecker"&gt;&lt;/bean&gt; （4）测试类（5）结果 12SpellChecker constructorcheckSpelling... Spring 由构造函数自动装配 这种模式与 byType 非常相似，但它应用于构造器参数。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire属性设置为 constructor。然后，它尝试把它的构造函数的参数与配置文件中 beans 名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些 bean，否则，它会抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为通过构造函数*自动装配，而且它有一个带有 *SpellChecker 类型的参数之一的构造函数，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并用它来设置构造函数的参数。你仍然可以使用 &lt;constructor-arg&gt; 标签连接其余属性。下面的例子将说明这个概念。 （1）TextEditor 将Setter方法变为构造方法 1234567891011121314151617package cn.water.spring_autowire.byName;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* 构造方法 */ public TextEditor( SpellChecker spellChecker ) &#123; this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker （3）Beans.xml 除了autowire属性改成constructor之外，其他完全一样。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- TextEditor --&gt; &lt;bean id="textEditor" class="cn.water.spring_autowire.byName.TextEditor" autowire="constructor"&gt; &lt;/bean&gt; &lt;!-- SpellChecker --&gt; &lt;bean id="SpellChecker" class="cn.water.spring_autowire.byName.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 （5）结果 12SpellChecker constructorcheckSpelling...]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架04 —— 依赖注入（DI）]]></title>
    <url>%2F2019%2F08%2F15%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F4.%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[依赖注入 Spring框架的核心功能之一就是通过依赖注入（Dependency Injection）的方式来管理Bean之间的依赖关系。 每个基于应用程序的 java 多多少少都会使用几个对象，最后与这些对象一起工作来呈现出终端用户所看到的工作的应用程序。依赖注入有助于把这些类粘合在一起，同时保持他们独立。 全面控制 假设你现在正在编写一个文本编辑器（TextEditor）的应用程序，并且想要添加拼写检查（SpellCheck）的功能。那么你就需要在TextEditor类中使用SpellCheck类。 标准代码看起来是这样的：123456789public class TextEditor &#123; private SpellCheck spellCheck; public TextEditor() &#123; spellCheck = new SpellCheck(); &#125; &#125; 控制反转 而在 Spring 框架中，我们需要做的则是创建一个 TextEditor 和 spellCheck 之间的依赖关系。 在控制反转的场景中，我们反而会做这样的事情：12345678public class TextEditor &#123; private SpellCheck spellCheck; public TextEditor(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; &#125;&#125; 结论 在 Spring 框架的控制下，TextEditor 不需要担心 spellCheck 的实现。spellCheck 将会独立实现，并且在 TextEditor 实例化的时候将提供给 TextEditor。 我们从 TextEditor 中删除了全面控制，并且把它保存到其他地方（即 XML 配置文件），且依赖关系通过类构造函数被注入到 TextEditor 类中。因此，控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。 对象不查找它的依赖关系，也不知道依赖关系的位置或类，而这一切都由 Spring 框架控制的。 目录结构 src main java.cn.water collection JavaCollection.java（实体类） constructor SpellCheck.java（实体类） TextEditor.java（实体类） User.java（实体类） inner SpellCheck.java（实体类） TextEditor.java（实体类） User.java（实体类） setter SpellCheck.java（实体类） TextEditor.java（实体类） User.java（实体类） resources collection Beans.xml（Spring配置文件） constructor Beans.xml（Spring配置文件） inner Beans.xml（Spring配置文件） setter Beans.xml（Spring配置文件） test java.cn.water.test collection SpringTest.java（测试类） constructor SpringTest.java（测试类） inner SpringTest.java（测试类） setter SpringTest.java（测试类） pom.xml（Maven配置文件） Maven配置文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section03_DI&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- Spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 实体类collectionJavaCollection.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.water.collection;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;/** * @author Water * @date 2019/10/23 - 15:14 * @description 封装四种集合的实体类 */public class JavaCollection &#123; /* 成员方法 */ private List list; private Set set; private Map map; private Properties properties; /* Setter */ public void setList(List list) &#123; this.list = list; &#125; public void setSet(Set set) &#123; this.set = set; &#125; public void setMap(Map map) &#123; this.map = map; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; System.out.println(this); &#125; @Override public String toString() &#123; return "JavaCollection&#123;" + "list=" + list + ", set=" + set + ", map=" + map + ", properties=" + properties + '&#125;'; &#125;&#125; constructorSpellCheck.java123456789101112131415package cn.water.constructor;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于构造函数注入实体类 */public class SpellCheck &#123; /* 无参构造函数 */ public SpellCheck() &#123; System.out.println("SpellCheck：通过无参构造函数，成功实例化！"); &#125;&#125; TextEditor.java123456789101112131415161718package cn.water.constructor;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于构造函数注入实体类 */public class TextEditor &#123; /* 成员变量 */ private SpellCheck spellCheck; /* 带参构造函数 */ public TextEditor(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过带参构造函数，成功实例化！"); &#125;&#125; User.java12345678910111213141516171819202122232425262728293031package cn.water.constructor;/** * @author Water * @date 2019/10/23 - 13:44 * @description 基于构造函数注入基本数据类型 */public class User &#123; /* 成员变量 */ private int id; private String name; private float money; /* 带参构造函数 */ public User(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; System.out.println(this); &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; innerSpellCheck.java123456789package cn.water.inner;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于InnerBeans注入实体类 */public class SpellCheck &#123;&#125; TextEditor.java12345678910111213141516171819202122232425262728package cn.water.inner;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于InnerBeans注入实体类 */public class TextEditor &#123; /* 成员变量 */ private SpellCheck spellCheck; /* Setter */ public void setSpellCheck(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过Setter（InnerBean），成功实例化！"); &#125; public TextEditor() &#123; &#125; /* 带参构造函数 */ public TextEditor(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过带参构造函数（InnerBean），成功实例化！"); &#125;&#125; User.java12345678910111213141516171819202122232425262728293031package cn.water.inner;/** * @author Water * @date 2019/10/23 - 13:44 * @description 基于构造函数注入基本数据类型 */public class User &#123; /* 成员变量 */ private int id; private String name; private float money; /* 带参构造函数 */ public User(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; System.out.println(this); &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; setterSpellCheck.java123456789101112131415package cn.water.setter;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于设值函数注入实体类 */public class SpellCheck &#123; /* 无参构造函数 */ public SpellCheck() &#123; System.out.println("SpellCheck：通过无参构造函数，成功实例化！"); &#125;&#125; TextEditor.java12345678910111213141516171819package cn.water.setter;/** * @author Water * @date 2019/10/23 - 12:46 * @description 基于设值注入实体类 */public class TextEditor &#123; /* 成员变量 */ private SpellCheck spellCheck; /* Setter */ public void setSpellCheck(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过Setter，成功实例化！"); &#125;&#125; User.java12345678910111213141516171819202122232425262728293031323334353637package cn.water.setter;/** * @author Water * @date 2019/10/23 - 13:44 * @description 基于设值注入基本数据类型 */public class User &#123; /* 成员变量 */ private int id; private String name; private float money; /* Setter */ public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setMoney(float money) &#123; this.money = money; System.out.println(this); &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; 配置文件collection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 实体类：设置函数 --&gt; &lt;bean id="collection" class="cn.water.collection.JavaCollection"&gt; &lt;!-- List集合 --&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;A&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set集合 --&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;B&lt;/value&gt; &lt;value&gt;C&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="1" value="A"&gt;&lt;/entry&gt; &lt;entry key="2" value="A"&gt;&lt;/entry&gt; &lt;entry key="3" value="A"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="one"&gt;A&lt;/prop&gt; &lt;prop key="two"&gt;A&lt;/prop&gt; &lt;prop key="three"&gt;A&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; constructor1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- 注入实体类 --&gt; &lt;!-- 目标类：带参构造函数 --&gt; &lt;bean id="editor" class="cn.water.constructor.TextEditor" &gt; &lt;constructor-arg ref="check"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 实体类：无参构造函数 --&gt; &lt;bean id="check" class="cn.water.constructor.SpellCheck"&gt;&lt;/bean&gt;&lt;!-- 注入基本数据类型 --&gt; &lt;!-- 目标类：带参构造函数 --&gt; &lt;bean id="user01" class="cn.water.constructor.User"&gt; &lt;constructor-arg name="id" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="cat"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="money" value="999.12"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 目标类：带参构造函数 --&gt; &lt;bean id="user02" class="cn.water.constructor.User"&gt; &lt;constructor-arg index="0" value="2"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="dog"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="2" value="1212.12"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; inner1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- 注入实体类 --&gt; &lt;!-- 目标类：设值函数 --&gt; &lt;bean id="editor01" class="cn.water.inner.TextEditor" &gt; &lt;property name="spellCheck"&gt; &lt;!-- InnerBean --&gt; &lt;bean class="cn.water.inner.SpellCheck"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 目标类：带参函数 --&gt; &lt;bean id="editor02" class="cn.water.inner.TextEditor" &gt; &lt;constructor-arg name="spellCheck"&gt; &lt;!-- InnerBean --&gt; &lt;bean class="cn.water.inner.SpellCheck"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; setter123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;&lt;!-- 注入实体类 --&gt; &lt;!-- 目标类：设值函数 --&gt; &lt;bean id="editor01" class="cn.water.setter.TextEditor" &gt; &lt;property name="spellCheck" ref="check01"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 实体类：无参构造函数 --&gt; &lt;bean id="check01" class="cn.water.setter.SpellCheck"&gt;&lt;/bean&gt; &lt;!-- p:namespace --&gt; &lt;bean id="editor02" class="cn.water.setter.TextEditor" p:spellCheck-ref="check02"&gt;&lt;/bean&gt; &lt;bean id="check02" class="cn.water.setter.SpellCheck"&gt;&lt;/bean&gt;&lt;!-- 注入基本数据类型 --&gt; &lt;!-- 目标类：带参构造函数 --&gt; &lt;bean id="user" class="cn.water.setter.User"&gt; &lt;property name="id" value="1"&gt;&lt;/property&gt; &lt;property name="name" value="cat"&gt;&lt;/property&gt; &lt;property name="money" value="99.12"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类collection12345678910111213141516171819202122package cn.water.test.collection;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 8:39 * @description 基于设值函数的 集合注入 */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("constructor/Beans.xml"); &#125;&#125; constructor12345678910111213141516171819202122package cn.water.test.constructor;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 8:39 * @description 基于构造函数 的依赖注入 */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("collection/Beans.xml"); &#125;&#125; inner12345678910111213141516171819202122package cn.water.test.inner;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 8:39 * @description 基于构造函数和设值函数的依赖注入，使用InnerBean */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("inner/Beans.xml"); &#125;&#125; setter123456789101112131415161718192021package cn.water.test.setter;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 8:39 * @description 基于设值函数 的依赖注入 */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmApplicationContext("setter/Beans.xml"); &#125;&#125; 基于构造函数注入 当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。 接下来，我们将依然通过 TextEditor 和 spellCheck 的示例来理解 Spring 基于构造函数的依赖注入。本例中，我们首先在XML配置中，对 TextEditor 的构造参数中注入 spellCheck。这样一来，一旦我们实例化 TextEditor ，Spring 就会在 TextEditor 的带参构造函数中传入其参数 spellCheck 。 优点：在获取Bean对象时，必须注入构造参数，否则对象无法创建成功。 缺点：改变了Bean对象实例化的方式，我们在创建的对象时，用不到的数据，也必须提供。 实体类TextEditor 成员变量（spellCheck） 带参构造函数（依赖注入） 12345678910111213package cn.water.Constructor;public class TextEditor &#123; /* 成员变量 */ private SpellCheck spellCheck; /* 带参构造函数 */ public TextEditor(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过带参构造函数，成功实例化！"); &#125;&#125; spellCheck 无参构造函数（依赖注入） 12345678910package cn.water.Constructor;public class SpellCheck &#123; /* 无参构造函数 */ public SpellCheck() &#123; System.out.println("SpellCheck：通过无参构造函数，成功实例化！"); &#125;&#125; 配置文件 bean标签 constructor-arg 标签 12345&lt;bean id="editor" class="cn.water.Constructor.TextEditor" &gt; &lt;constructor-arg ref="check"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="check" class="cn.water.Constructor.SpellCheck"&gt;&lt;/bean&gt; 基本数据类型User 成员变量（基本数据类型） 带参构造函数（依赖注入） 123456789101112131415161718package cn.water.Constructor;public class User &#123; /* 成员变量 */ private int id; private String name; private float money; /* 带参构造函数 */ public User(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; System.out.println(this); &#125;&#125; 配置文件 bean标签 constructor-arg标签 name属性 12345&lt;bean id="user" class="cn.water.Constructor.User"&gt; &lt;constructor-arg name="id" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="cat"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="money" value="999.12"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; bean标签 constructor-arg标签 index属性 12345&lt;bean id="user" class="cn.water.Constructor.User"&gt; &lt;constructor-arg index="0" value="2"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="dog"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="2" value="1212.12"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 基于设值函数注入 当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数Setter，基于设值函数的 DI 就完成了。 你应该注意定义在基于构造函数注入和基于设值函数注入中的 Beans.xml 文件的区别。 唯一的区别就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数注入中，我们使用的是〈bean〉标签中的〈property〉元素。 第二个你需要注意的点是，如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。 优点：Bean对象实例化的方式不变，可以直接使用默认构造函数。 缺点：不能保证所有的类成员都被注入了，即使是必须有值的成员。 实体类TextEditor 成员变量（spellCheck） 设置函数（依赖注入） 1234567891011121314package cn.water.Setter;public class TextEditor &#123; /* 成员变量 */ private SpellCheck spellCheck; /* Setter */ public void setSpellCheck(SpellCheck spellCheck) &#123; this.spellCheck = spellCheck; System.out.println("TextEditor：通过Setter，成功实例化！"); &#125;&#125; spellCheck 无参构造函数（依赖注入） 12345678910package cn.water.Constructor;public class SpellCheck &#123; /* 无参构造函数 */ public SpellCheck() &#123; System.out.println("SpellCheck：通过无参构造函数，成功实例化！"); &#125;&#125; 配置文件 bean标签 property 标签 12345&lt;bean id="editor" class="cn.water.Setter.TextEditor"&gt; &lt;property name="spellCheck" ref="check"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="check" class="cn.water.Setter.SpellCheck"&gt;&lt;/bean&gt; 基本数据类型User 成员变量（基本数据类型） 设值函数（依赖注入） 123456789101112131415161718package cn.water.Constructor;public class User &#123; /* 成员变量 */ private int id; private String name; private float money; /* 带参构造函数 */ public User(int id, String name, float money) &#123; this.id = id; this.name = name; this.money = money; System.out.println(this); &#125;&#125; 配置文件 bean标签 property 标签 name属性 12345&lt;bean id="user" class="cn.water.Setter.User"&gt; &lt;property name="id" value="1"&gt;&lt;/property&gt; &lt;property name="name" value="cat"&gt;&lt;/property&gt; &lt;property name="money" value="999.12"&gt;&lt;/property&gt;&lt;/bean&gt; p-namespace标准 XML 配置文件1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="editor" class="cn.water.Setter.TextEditor"&gt; &lt;property name="spellCheck" ref="check"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="check" class="cn.water.Setter.SpellCheck"&gt;&lt;/bean&gt; &lt;/beans&gt; 使用 p-namespace 的 XML 配置文件 导入第四行另外的命名空间 bean标签 p:spellCheck-ref属性 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="editor" class="cn.water.setter.TextEditor" p:spellCheck-ref="check"&gt;&lt;/bean&gt; &lt;bean id="check" class="cn.water.setter.SpellCheck"&gt;&lt;/bean&gt; &lt;/beans&gt; InnerBeans 正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，Inner Beans 是在其他 bean 的范围内定义的 bean。inner beans 不需要写 id属性，因为它无法被其他Bean对象访问。 基于构造函数注入Beans123456&lt;!-- 目标类：带参构造函数 --&gt;&lt;bean id="editor" class="cn.water.Constructor.TextEditor" &gt; &lt;constructor-arg ref="check"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 实体类：无参构造函数 --&gt;&lt;bean id="check" class="cn.water.Constructor.SpellCheck"&gt;&lt;/bean&gt; InnerBeans1234567&lt;!-- 目标类：带参函数 --&gt;&lt;bean id="editor" class="cn.water.Inner.TextEditor" &gt; &lt;constructor-arg name="spellCheck"&gt; &lt;!-- InnerBean --&gt; &lt;bean class="cn.water.Inner.SpellCheck"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 基于设值函数注入Beans123456&lt;!-- 目标类：Setter --&gt;&lt;bean id="editor" class="cn.water.Setter.TextEditor"&gt; &lt;property name="spellCheck" ref="check"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 实体类 --&gt;&lt;bean id="check" class="cn.water.Setter.SpellCheck"&gt;&lt;/bean&gt; InnerBeans1234567&lt;!-- 目标类：设值函数 --&gt;&lt;bean id="editor" class="cn.water.Inner.TextEditor" &gt; &lt;property name="spellCheck"&gt; &lt;!-- InnerBean --&gt; &lt;bean class="cn.water.Inner.SpellCheck"/&gt; &lt;/property&gt;&lt;/bean&gt; 注入集合实体类 成员变量 List 集合 Set 集合 Map 集合 property 设值构造函数（依赖注入） 12345678910111213141516171819202122232425262728293031323334package cn.water.collection;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class JavaCollection &#123; /* 成员方法 */ private List list; private Set set; private Map map; private Properties properties; /* Setter */ public void setList(List list) &#123; this.list = list; &#125; public void setSet(Set set) &#123; this.set = set; &#125; public void setMap(Map map) &#123; this.map = map; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; System.out.println(this); &#125;&#125; 配置文件 bean标签 List集合 property标签 list标签 value标签 Set集合 property标签 set标签 value标签 Map集合 property标签 map标签 entry标签 property property标签 props标签 prop标签 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 实体类：设置函数 --&gt; &lt;bean id="collection" class="cn.water.collection.JavaCollection"&gt; &lt;!-- List集合 --&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;A&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set集合 --&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;B&lt;/value&gt; &lt;value&gt;C&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="1" value="A"&gt;&lt;/entry&gt; &lt;entry key="2" value="A"&gt;&lt;/entry&gt; &lt;entry key="3" value="A"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="one"&gt;A&lt;/prop&gt; &lt;prop key="two"&gt;A&lt;/prop&gt; &lt;prop key="three"&gt;A&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 注入 null/空字符 如果你需要传递一个空字符串作为值，那么你可以传递它，如下所示： 相当于 Java 代码：POJO.setEmail(“”) 123&lt;bean id="..." class="cn.water.POJO"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt; 如果你需要传递一个 NULL 值，那么你可以传递它，如下所示： 相当于 Java 代码：POJO.setEmail(null) 123&lt;bean id="..." class="cn.water.POJO"&gt; &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DI</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架03 —— Bean对象的配置方式]]></title>
    <url>%2F2019%2F08%2F14%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F3.Bean%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介 Spring Bean对象 Bean对象 是构成应用程序的支柱。 Bean对象 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。 Bean对象 是由用 Spring IoC 容器提供的配置元数据创建的。 把配置元数据提供给 Spring IoC 容器的方法： 基于 XML 的配置文件 基于注解的配置 基于 Java 的配置 属性构成每个 Bean对象 定义的一组属性： 属性 描述 class 强制属性，用来指定创建 bean 的类。 name / id 唯一的 bean 标识符。 scope 指定 bean 对象的作用域 constructor-arg 注入依赖关系（无参构造） properties 注入依赖关系 destroy-method 初始化方法 init-method 销毁方法 目录结构 src main java.cn.water POJO.java（实体类） POJOFactory.java（工厂类） resources LifeCycle Beans.xml（Spring配置文件） NewInstance Beans.xml（Spring配置文件） Scope Beans.xml（Spring配置文件） test java.cn.water.test LifeCycle SpringTest.java（测试类） NewInstance SpringTest.java（测试类） Scope SpringTest.java（测试类） pom.xml（Maven配置文件） Maven配置文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section02_Bean&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- Spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 实体类POJO.java1234567891011121314151617181920212223242526272829package cn.water;/** * @author Water * @date 2019/10/22 - 17:26 * @description 实体类 */public class POJO &#123; /* 成员变量 */ private String message; /* 成员方法：初始化 */ public void init()&#123; System.out.println("POJO类：初始化成功！"); &#125; /* 成员方法：销毁 */ public void destroy()&#123; System.out.println("POJO类：销毁成功！"); &#125; /* 构造方法 */ public POJO() &#123; System.out.println("POJO类：实例化成功！"); &#125;&#125; 工厂类POJOFactory.java1234567891011121314151617181920package cn.water;/** * @author Water * @date 2019/10/23 - 10:36 * @description 工厂类 */public class POJOFactory &#123; /* 成员方法 */ public POJO getPOJO() &#123; return new POJO(); &#125; /* 静态方法 */ public static POJO havePOJO()&#123; return new POJO(); &#125;&#125; 配置文件LifeCycle1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="pojo" class="cn.water.POJO" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt; &lt;/beans&gt; NewInstance1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 无参构造 --&gt; &lt;bean id="pojo01" class="cn.water.POJO"&gt;&lt;/bean&gt; &lt;!-- 工厂类 成员方法 --&gt; &lt;bean id="factory" class="cn.water.POJOFactory"&gt;&lt;/bean&gt; &lt;bean id="pojo02" class="cn.water.POJO" factory-bean="factory" factory-method="getPOJO"&gt;&lt;/bean&gt; &lt;!-- 工厂类 静态方法 --&gt; &lt;bean id="pojo03" class="cn.water.POJOFactory" factory-method="havePOJO"&gt;&lt;/bean&gt; &lt;/beans&gt; Scope1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 单例 --&gt; &lt;bean id="pojo01" class="cn.water.POJO" scope="singleton"&gt;&lt;/bean&gt; &lt;!-- 多例 --&gt; &lt;bean id="pojo02" class="cn.water.POJO" scope="prototype"&gt;&lt;/bean&gt; &lt;/beans&gt; 测试类LifeCycle12345678910111213141516171819202122232425262728293031package cn.water.test.LifeCycle;import cn.water.POJO;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.beans.Beans;/** * @author Water * @date 2019/10/23 - 10:10 * @description 测试Spring框架 Bean对象的生命周期 */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ AbstractApplicationContext abstractApp = new ClassPathXmlApplicationContext("LifeCycle/Beans.xml"); /* -- init-method 方法执行 --- */ /* 2、获取Bean对象 */ POJO pojo = abstractApp.getBean("pojo", POJO.class); /* 3、注销容器 */ abstractApp.registerShutdownHook(); /* -- destroy-method 方法执行 --- */ &#125;&#125; NewInstance1234567891011121314151617181920212223package cn.water.test.NewInstance;import cn.water.POJO;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 10:10 * @description 测试Spring框架 Bean对象的实例化 */public class SpringTest &#123; @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("NewInstance/Beans.xml"); &#125;&#125; Scope12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.water.test.Scope;import cn.water.POJO;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.ClassPathResource;/** * @author Water * @date 2019/10/23 - 8:39 * @description 测试Spring框架 Bean对象的作用域 */public class SpringTest &#123; /** 单例模式（默认） */ @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("Scope/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo1 = app.getBean("pojo01", POJO.class); POJO pojo2 = app.getBean("pojo01", POJO.class); POJO pojo3 = app.getBean("pojo01", POJO.class); /* 3、输出 */ System.out.println(pojo1); System.out.println(pojo2); System.out.println(pojo3); &#125; /* 多例模式 */ @Test public void test02()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("Scope/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo1 = app.getBean("pojo02", POJO.class); POJO pojo2 = app.getBean("pojo02", POJO.class); POJO pojo3 = app.getBean("pojo02", POJO.class); /* 3、输出 */ System.out.println(pojo1); System.out.println(pojo2); System.out.println(pojo3); &#125;&#125; 作用域 当在 Spring 中定义一个 bean 时，你可以指定该 bean 的作用域。 例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。 同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。 作用域 描述 singleton 仅存在一个Bean实例，Bean以单例方式存在（默认值） prototype 每次从容器中调用Bean时，都返回一个新的实例，（即每次调用getBean()时，相当于执行newXxxBean()） request 每次HTTP请求都会创建一个新的Bean（仅适用于WebApplicationContext环境） singleton 同一个HTTP Session共享一个Bean不同Session使用不同的Bean（仅适用于WebApplicationContext环境） global-session 一般用于Portlet应用环境（仅适用于WebApplicationContext环境） 目录结构 src main java.cn.water POJO.java（实体类） resources Beans.xml（Spring配置文件） test java.cn.water.test SpringTest.java（测试类） 实体类12345678package cn.water;public class POJO &#123; /* 成员变量 */ private String message;&#125; 配置文件 单例 bean标签 Scope属性：singleton 12&lt;!-- 单例 --&gt;&lt;bean id="pojo01" class="cn.water.POJO" scope="singleton"&gt;&lt;/bean&gt; 多例 bean标签 Scope属性：prototype 12&lt;!-- 多例 --&gt;&lt;bean id="pojo02" class="cn.water.POJO" scope="prototype"&gt;&lt;/bean&gt; 测试类 单例 12345678910111213@Testpublic void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("LifeCycle/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo1 = app.getBean("pojo01", POJO.class); POJO pojo2 = app.getBean("pojo01", POJO.class); POJO pojo3 = app.getBean("pojo01", POJO.class); /* 3、输出 */ System.out.println(pojo1); System.out.println(pojo2); System.out.println(pojo3);&#125; 多例12345678910111213@Test public void test02()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("LifeCycle/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo1 = app.getBean("pojo02", POJO.class); POJO pojo2 = app.getBean("pojo02", POJO.class); POJO pojo3 = app.getBean("pojo02", POJO.class); /* 3、输出 */ System.out.println(pojo1); System.out.println(pojo2); System.out.println(pojo3); &#125; 运行结果 单例 123cn.water.POJO@6321e813cn.water.POJO@6321e813cn.water.POJO@6321e813 多例 123cn.water.POJO@6321e813cn.water.POJO@79be0360cn.water.POJO@22a67b4 生命周期 理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。 为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。 Bean的生命周期可以表达为： Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 目录结构 src main java.cn.water POJO.java（实体类） resources Beans.xml（Spring配置文件） test java.cn.water.test SpringTest.java（测试类） 实体类 在实体类中，添加两个成员方法 初始化方法 销毁方法 123456789101112131415161718package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* 成员方法：初始化 */ public void init()&#123; System.out.println("POJO类：初始化成功！"); &#125; /* 成员方法：销毁 */ public void destroy()&#123; System.out.println("POJO类：销毁成功！"); &#125;&#125; 配置文件 初始化方法 bean标签 init-method属性：方法名 销毁方法 bean标签 destroy-method属性：方法名 1&lt;bean id="pojo" class="cn.water.POJO" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt; 测试类1234567891011121314151617@Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ AbstractApplicationContext abstractApp = new ClassPathXmlApplicationContext("LifeCycle/Beans.xml"); /* -- init-method 方法执行 --- */ /* 2、获取Bean对象 */ POJO pojo = abstractApp.getBean("pojo", POJO.class); /* 3、注销容器 */ abstractApp.registerShutdownHook(); /* -- destroy-method 方法执行 --- */ &#125; 运行结果1234POJO类：初始化成功！POJO类：销毁成功！ 实例化默认无参构造实体类123456789101112package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* 构造方法 */ public POJO() &#123; System.out.println("POJO类：实例化成功！"); &#125;&#125; 配置文件 默认根据 无参构造函数 来创建Bean对象。 实体类 全类名 1&lt;bean id="constructor_based" class="cn.water.POJO"&gt;&lt;/bean&gt; 工厂类 成员方法实体类123456789101112package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* 构造方法 */ public POJO() &#123; System.out.println("POJO类：实例化成功！"); &#125;&#125; 工厂类12345678910package cn.water;public class POJOFactory &#123; /* 成员方法 */ public POJO getPOJO() &#123; return new POJO(); &#125;&#125; 配置文件 首先，根据 无参构造函数 来创建工厂类对象。 工厂类 全类名 然后，根据 工厂类的成员方法 来创建实体类对象。 实体类 全类名 工厂类 id 工厂类 成员方法名 12&lt;bean id="factory" class="cn.water.POJOFactory"&gt;&lt;/bean&gt;&lt;bean id="factory_Method_based" class="cn.water.POJO" factory-bean="factory" factory-method="getPOJO"&gt;&lt;/bean&gt; 工厂类 静态方法实体类123456789101112package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* 构造方法 */ public POJO() &#123; System.out.println("POJO类：实例化成功！"); &#125;&#125; 工厂类12345678910package cn.water;public class POJOFactory &#123; /* 静态方法 */ public static POJO havePOJO()&#123; return new POJO(); &#125;&#125; 配置文件 直接根据 工厂类静态方法 来创建Bean对象。 工厂类 全类名 工厂类 静态方法名 1&lt;bean id="pojo03" class="cn.water.POJOFactory" factory-method="havePOJO"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架02 —— 控制反转（IoC）]]></title>
    <url>%2F2019%2F08%2F13%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F2.%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[简介 本文分为四部分 第一部分：介绍 内聚和耦合 的概念。 第二部分：介绍Spring框架中的 IoC控制反转 机制。 第三部分：介绍 ApplicationContext 和 BeanFactory 。 第四部分：比较 ApplicationContext 和 BeanFactory 。 内聚和耦合在介绍Spring IoC容器之前，我们先要了解一下软件设计好坏的评判标准：耦合和内聚。 耦合 耦合性(Coupling)是对模块间关联程度的度量。 耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差。 高耦合 手机和充电线是高耦合，为什么呢？ 打个比方，苹果手机和安卓手机必须使用本机适配的充电线，而且在安卓手机中甚至还分为USB接口和Type-C接口。如果我使用苹果充电接口给安卓手机充电，那么苹果充电线无法正常输电，安卓手机也无法正常充电了。（忽略其他影响） 由此可见，手机和充电接口之间的依赖关系紧密，独立性差，所以属于高耦合。 低耦合 充电接口和充电接口是低耦合。 打个比方，不论是苹果充电接口还是安卓充电接口，都可以使用苹果充电接头，也都可以使用安卓充电接头。（忽略其他影响） 由此可见，充电接口和充电接头之间的依赖关系松散，独立性高，所以属于低耦合。 内聚 内聚（Cohesion）是一个模块内部各成分间关联程度的度量。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。 低内聚 职责混乱是低内聚。 打个比方，开发人员除了开发项目，还要参与需求分析；测试人员除了测试项目，还要参与开发。这表示每一个内聚模块都没有做好自己分内的事，因为如果每个内聚模块都做好了自己该做的事情，别的模块是不会有插手的余地的。 高内聚 各司其职是高内聚。 打个比方，软件开发人员完成项目开发，测试人员完成项目测试。这表示每一个内聚模块都做好了自己分内的事情，不需要别的内聚模块来插手，也不需要去别的内裤模块插手。 控制反转 IoC（Inversion of Control） 为什么要使用控制反转呢？ 我们在前面已经了解到“高内聚低耦合”是评判软件设计好坏的标准，以及“内聚”和“耦合”的定义。那么我们学习的 Spring 框架是否能帮助我们更好的设计出“高内聚低耦合”的软件呢？答案显然是肯定的。 但是，Spring 框架使得程序“低耦合”的特点更加突出。因为在 Spring 框架中，由于控制反转 IoC（Inversion of Control）的机制，软件之间的依赖关系由 Spring 框架帮我们管理，这样做有效的降低了对象之间的耦合性。 控制反转是什么呢？ 控制反转 IoC（Inversion of Control）就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做。 换句话说，就是指new实例工作不再由程序员来做，而是交给Spring容器来做。new实例工作的控制权不再由程序员掌控。 我们通过依赖注入，来实现控制反转。 依赖注入 DI（Dependency Injection） Spring 最被认同的技术是控制反转的依赖注入，依赖注入是一种设计模式。 控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。 当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入有助于将这些类粘合在一起，并且在同一时间让它们保持独立。 到底什么是依赖注入？让我 们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B，表示类 B 将通过 IoC 被注入到类 A 中。 依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法。 目录结构 src main java.cn.water POJO.java（实体类） resources ApplicationContext Beans.xml（Spring配置文件） BeanFactory Beans.xml（Spring配置文件） test java.cn.water.test ApplicationContext SpringTest.java（测试类） BeanFactory SpringTest.java（测试类） pom.xml（Maven配置文件） Maven配置文件12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Ioc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- Spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 实体类POJO.java123456789101112131415161718192021package cn.water;public class POJO &#123; /* 静态代码块 */ static&#123; System.out.println("POJO类被加载了！！！"); &#125; /* 成员变量 */ private String message; /* Getter、Setter */ public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 配置文件ApplicationContext1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="pojo" class="cn.water.POJO"&gt; &lt;property name="message" value="ApplicationContext：恭喜发财！"/&gt; &lt;/bean&gt; &lt;/beans&gt; BeanFactory1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="pojo" class="cn.water.POJO"&gt; &lt;property name="message" value="BeanFactory：恭喜发财！"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类ApplicationContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.water.test.ApplicationContext;import cn.water.POJO;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;/** * @author Water * @date 2019/10/23 - 8:38 * @description ApplicationContext接口 * 1、ClassPathXmlApplicationContext实现类 * 2、FileSystemXmlApplicationContext实现类 * 3、立即加载（适用于单例模式） */public class SpringTest &#123; /** 实现类：ClassPathXmlApplicationContext */ @Test public void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("ApplicationContext/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo = app.getBean("pojo", POJO.class); /* 3、调用方法 */ String message = pojo.getMessage(); /* 4、输出 */ System.out.println(message); &#125; /** 实现类：FileSystemXmlApplicationContext */ @Test public void test02()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new FileSystemXmlApplicationContext("D:\\coding\\IDEASpace\\spring\\spring\\section01_Ioc\\src\\main\\resources\\ApplicationContext\\Beans.xml"); /* 2、获取Bean对象 */ POJO pojo = app.getBean("pojo", POJO.class); /* 3、调用方法 */ String message = pojo.getMessage(); /* 4、输出 */ System.out.println(message); &#125; /** 立即加载 */ @Test public void test03()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("ApplicationContext/Beans.xml"); &#125;&#125; BeanFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.water.test.BeanFactory;import cn.water.POJO;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;/** * @author Water * @date 2019/10/23 - 8:39 * @description BeanFactory接口 * 1、XmlBeanFactory实现类 * 2、延迟加载（适用于多例模式） */public class SpringTest &#123; /** XmlBeanFactory实现类 */ @Test public void test01()&#123; /* 1、加载配置文件 */ ClassPathResource resource = new ClassPathResource("BeanFactory/Beans.xml"); /* 2、初始化Bean对象 */ BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); /* 3、获取Bean对象 */ POJO pojo = (POJO) factory.getBean("pojo"); /* 4、执行方法 */ String message = pojo.getMessage(); /* 5、输出 */ System.out.println(message); &#125; /** 延迟加载 */ @Test public void test02()&#123; /* 1、加载配置文件 */ ClassPathResource resource = new ClassPathResource("BeanFactory/Beans.xml"); /* 2、初始化Bean对象 */ BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); /* 3、获取Bean对象 */ POJO pojo = (POJO) factory.getBean("pojo"); /* 此时加载 */ &#125;&#125; BeanFactory 接口 它是最简单的容器，给 DI 提供了基本的支持。 它用org.springframework.beans.factory.BeanFactory 接口来定义。（beans） 目录结构 src main java.cn.water POJO.java（实体类） resources Beans.xml（Spring配置文件） test java.cn.water.test SpringTest.java（测试类） 实体类POJO.java12345678910111213141516package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* Getter、Setter */ public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 配置文件Beans.xml bean 标签：表示一个Bean容器 id 属性：Bean容器的唯一标识符 class 属性：POJO类的全类名 property 标签：表示Bean容器的类成员 name 属性：Bean容器的类成员的唯一标识符 value 属性：Bean容器的类成员的值 123&lt;bean id="pojo" class="cn.water.POJO"&gt; &lt;property name="message" value="BeanFactory：恭喜发财！"/&gt;&lt;/bean&gt; 测试类SpringTest.java12345678910111213@Testpublic void test01()&#123; /* 1、加载配置文件 */ ClassPathResource resource = new ClassPathResource("BeanFactory/Beans.xml"); /* 2、初始化Bean对象 */ BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); /* 3、获取Bean对象 */ POJO pojo = (POJO) factory.getBean("pojo"); /* 4、执行方法 */ String message = pojo.getMessage(); /* 5、输出 */ System.out.println(message);&#125; 输出结果1BeanFactory：恭喜发财！ ApplicationContext 接口 ApplicationContext 是 BeanFactory 的子接口，也被称为 Spring 上下文。 ApplicationContext 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。 由 org.springframework.context.ApplicationContext 接口定义。 目录结构 src main java.cn.water POJO.java（实体类） resources Beans.xml（Spring配置文件） test java.cn.water.test SpringTest.java（测试类） 实体类POJO.java12345678910111213141516package cn.water;public class POJO &#123; /* 成员变量 */ private String message; /* Getter、Setter */ public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 配置文件Beans.xml123&lt;bean id="pojo" class="cn.water.POJO"&gt; &lt;property name="message" value="ApplicationContext：恭喜发财！"/&gt;&lt;/bean&gt; 测试类SpringTest.java ClassPathXmlApplicationContext 实现类 该容器从 XML 文件中加载已被定义的 bean。 在这里，你需要提供 CLASSPATH 环境变量。 ApplicationContext/Beans.xml 123456789101112@Testpublic void test01()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("ApplicationContext/Beans.xml"); /* 2、获取Bean对象 */ POJO pojo = app.getBean("pojo", POJO.class); /* 3、调用方法 */ String message = pojo.getMessage(); /* 4、输出 */ System.out.println(message);&#125; FileSystemXmlApplicationContext 实现类 该容器从 XML 文件中加载已被定义的 bean。 在这里，你需要提供给构造器 XML 文件的完整路径。 C:\\src\\main\\resources\\ApplicationContext\\Bean.xml C:/src/main/resources/ApplicationContext/Bean.xml1234567891011@Testpublic void test02()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new FileSystemXmlApplicationContext("D:\\coding\\IDEASpace\\spring\\spring\\section01_Ioc\\src\\main\\resources\\ApplicationContext\\Beans.xml"); /* 2、获取Bean对象 */ POJO pojo = app.getBean("pojo", POJO.class); /* 3、调用方法 */ String message = pojo.getMessage(); /* 4、输出 */ System.out.println(message);&#125; 输出结果1ApplicationContext：恭喜发财！ 区别 ApplicationContext 在构建核心容器时，创建对象采用 立即加载 的方式。一读取完配置文件，立马创建配置的对象。 由于只在读取配置文件时创建对象，所以 适用于单例模式。 BeanFactory 在构建核心容器时，创建对象采用 延迟加载 的方式。什么时候根据id获取对象了，什么时候创建配置的对象。 由于每次获取对象时，都会创建对象，所以 适用于多例模式。 ApplicationContext实体类POJO.java 加入 静态代码块，用于识别 POJO类 是何时被加载的。 123456789101112131415161718192021package cn.water;public class POJO &#123; /* 静态代码块 */ static&#123; System.out.println("POJO类被加载了！！！"); &#125; /* 成员变量 */ private String message; /* Getter、Setter */ public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 配置文件Beans.xml1&lt;bean id="pojo" class="cn.water.POJO"&gt;&lt;/bean&gt; 测试类SpringTest.java12345@Testpublic void test03()&#123; /* 1、加载配置文件，初始化Bean对象 */ ApplicationContext app = new ClassPathXmlApplicationContext("ApplicationContext/Beans.xml");&#125; 输出结果1POJO类被加载了！！！ BeanFactory实体类POJO.java 加入 静态代码块，用于识别 POJO类 是何时被加载的。 123456789101112131415161718192021package cn.water;public class POJO &#123; /* 静态代码块 */ static&#123; System.out.println("POJO类被加载了！！！"); &#125; /* 成员变量 */ private String message; /* Getter、Setter */ public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; Spring配置文件Beans.xml1&lt;bean id="pojo" class="cn.water.POJO"&gt;&lt;/bean&gt; 测试类SpringTest.java123456789@Testpublic void test02()&#123; /* 1、加载配置文件 */ ClassPathResource resource = new ClassPathResource("BeanFactory/Beans.xml"); /* 2、初始化Bean对象 */ BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); /* 3、获取Bean对象 */ POJO pojo = (POJO) factory.getBean("pojo"); /* 此时加载 */&#125; 输出结果1POJO类被加载了！！！]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架01 —— 概述]]></title>
    <url>%2F2019%2F08%2F12%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2F1.%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概述 Spring是分层的企业级full-stack轻量级开源框架，以IoC和AOP为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，并整合了开源世界中众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 控制反转 IoC（Inversion of Control ） 控制反转 就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。 换句话说，就是指new实例工作不再由程序员来做，而是交给Spring容器来做。new实例工作的控制权不再由程序员掌控。 面向方面的程序设计 AOP（Aspect-Oriented Programming） Spring 框架的一个关键组件是面向方面的程序设计（AOP）框架。 一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。 在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。 Spring 框架的 AOP 模块提供了面向方面的程序设计实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦出来。 体系结构 Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。 下面的部分对在 Spring 框架中所有可用的模块给出了详细的介绍。 核心容器 模块 Core 模块 提供了框架的基本组成部分。 控制反转（IoC） 依赖注入（DI） Beans 模块 提供 BeanFactory，工厂模式的经典实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。 BeanFactory 接口 Context 模块 建立在由core和 beans 模块的基础之上，它是访问定义和配置任何对象的媒介。 ApplicationContext 接口 SpEL模块（Spring Expression Language） 提供了强大的表达式语言，用于在运行时查询和操作对象图。 EL 表达式 数据访问/集成 模块 JDBC 模块（Java Data Base Connectivity） 提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。 ORM 模块（Object Relational Mapping） 提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。 OXM 模块（Object XML Mapping） 提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 JMS 模块（Java Message Service） 包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。 Transactions 模块 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。 注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细。 Web 模块 Web 模块 提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。 Web-MVC 模块 为web应用提供了模型视图控制（MVC）和REST Web服务的实现。 SpringMVC框架 Web-Socket 模块 为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块 提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。其他 其他模块 AOP 模块 提供了面向方面的编程实现。 方法拦截器 切点 Aspects 模块 提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块 在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。 Messaging 模块 为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。 Testing 模块 支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架14 —— 缓存机制（基于注解）]]></title>
    <url>%2F2019%2F08%2F10%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F14%E6%B3%A8%E8%A7%A3%20%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[目录结构src main java cn.water.dao UserDao.java（持久层接口） cn.water.domain User.java（实体类） resources SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） test java.cn.water MybatisTest.java（测试类） MyBatis配置文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root SqlMapConfig.xml 开启 二级缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置参数 --&gt; &lt;settings&gt; &lt;!-- 开启 二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 实体类User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.domain;import java.io.Serializable;import java.util.Date;/** * @author Water * @date 2019/10/12 - 7:51 * @description */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口UserDao.java 注解支持：@CacheNamespace(blocking = true) 12345678910111213141516package cn.water.dao;import cn.water.domain.User;/** * @author Water * @date 2019/10/12 - 7:51 * @description */@CacheNamespace(blocking = true)public interface UserDao &#123; @Select("SELECT * FROM user WHERE id = #&#123;userId&#125;") User findById(Integer userId);&#125; 测试类MyBatisT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.water;import cn.water.dao.UserDao;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * @author Water * @date 2019/10/12 - 7:56 * @description */public class MybatisTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSessionFactory factory; private SqlSession session; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(true);/* 设置自动提交 */ &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /** 一级缓存：同一个 SqlSession */ @Test public void test01()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); User user02 = dao.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02)); //true &#125; /** 一级缓存：不同 SqlSession */ @Test public void test02()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); /* commit()（执行插入、更新、删除）、close() */ session.close(); session = factory.openSession(); UserDao dao02 = session.getMapper(UserDao.class); User user02 = dao02.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02));//false &#125;&#125; 开启二级缓存（缓存） 二级缓存的使用步骤： 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的持久层接口支持二级缓存（在UserDao.java中配置）]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架13 —— 实现多表查询的延迟加载操作（基于注解）]]></title>
    <url>%2F2019%2F08%2F10%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F13.%E6%B3%A8%E8%A7%A3%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[简介MyBatis中多表之间的关系 本次案例主要以最为简单的用户（User）、账户（Account）、角色（Role）的模型来分析Mybatis多表关系。 用户为User 表，账户为Account表。 一对多关系 一个用户（User）可以开设多个账户（Account） 从查询 用户信息（User） 出发，关联查询 账户信息（Account）属于一对多查询 一对一关系（多对一） 多个账户（Account）可以对应一个用户（User） 单个账户（Account）只能属于一个用户（User） 从查询 账户信息（Account） 出发，关联查询 用户信息（User）属于一对一查询 多对多关系 一个用户（User）可以拥有多个角色（Role） 一个角色（Role）可以赋予多个用户（User） 多对多关系其实我们看成是双向的一对多关系。 目录结构 src main java cn.water.dao UserDao.java（一对多 持久层接口） AccountDao.java（一对一 持久层接口） cn.water.domain User.java（一对多 实体类） Account.java（一对一 实体类） resources cn.water.dao User.xml（一对多 映射配置文件） Account.xml（一对一 映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） test java.cn.water MybatisTest.java（测试类） MyBatis主配置文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root SqlMapConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置参数 --&gt; &lt;settings&gt; &lt;!-- 开启 延迟加载 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 实体类Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.water.domain;import java.io.Serializable;/** * @author Water * @date 2019/10/13 - 15:10 * @description */public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; private User user; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + ", user=" + user + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package cn.water.domain;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author Water * @date 2019/10/13 - 15:10 * @description */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", accounts=" + accounts + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 持久层接口AccountDao.java123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.dao;import cn.water.domain.Account;import org.apache.ibatis.annotations.One;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.mapping.FetchType;import java.util.List;/** * @author Water * @date 2019/10/13 - 15:11 * @description 一对一查询 延迟查询 */public interface AccountDao &#123; /* 一对一查询：查询所有账户信息和对应的用户信息 */ @Select("SELECT * FROM account") @Results(id = "accountMap", value = &#123; @Result(id = true,column = "id",property = "id"), @Result(column = "uid",property = "uid"), @Result(column = "money",property = "money"), /* 传递值：uid，变量名：user */ @Result(column = "uid", property = "user", one = @One(select = "cn.water.dao.UserDao.findById", fetchType = FetchType.LAZY ) ) &#125;) List&lt;Account&gt; findAll(); /* 一对多查询：根据id，查询账户信息 */ @Select("SELECT * FROM account WHERE uid = #&#123;id&#125;") Account findByUid(Integer id);&#125; UserDao.java1234567891011121314151617181920212223242526272829303132333435363738394041package cn.water.dao;import cn.water.domain.User;import org.apache.ibatis.annotations.Many;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.mapping.FetchType;import java.util.List;/** * @author Water * @date 2019/10/13 - 15:11 * @description 一对多查询 延迟查询 */public interface UserDao &#123; /* 一对一查询：按照id，查询用户信息 */ @Select("SELECT * FROM user WHERE id = #&#123;id&#125;") User findById(); /* 一对多查询：查询所有的用户信息和对应的账户信息 */ @Select("SELECT * FROM user") @Results(id = "userMap",value = &#123; @Result(id = true,column = "id",property = "id"), @Result(column = "username",property = "username"), @Result(column = "birthday",property = "birthday"), @Result(column = "sex",property = "sex"), @Result(column = "address",property = "address"), /* 传递值：uid，变量名：accounts */ @Result(column = "id", property = "accounts", many = @Many(select = "cn.water.dao.AccountDao.findByUid", fetchType = FetchType.LAZY ) ) &#125;) List&lt;User&gt; findAll();&#125; 测试类MyBatisTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.water;import cn.water.dao.AccountDao;import cn.water.dao.UserDao;import cn.water.domain.Account;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;/** * @author Water * @date 2019/10/13 - 10:48 * @description */public class UserTest &#123; private InputStream inputStream; private SqlSessionFactory factory; private SqlSession session; @Before public void init() throws IOException &#123; inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); session = factory.openSession(true); &#125; @After public void destroy () throws IOException &#123; session.close(); inputStream.close(); &#125; /** 一对一查询 */ @Test public void test01()&#123; AccountDao dao = session.getMapper(AccountDao.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125; &#125; /** 一对多查询 */ @Test public void test02()&#123; UserDao dao = session.getMapper(UserDao.class); for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125;&#125; 一对一查询（延迟） @One注解代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 注解 @One：实现一对一结果集封装 select：指定用来多表查询的sqlmapper fetchType：覆盖全局的配置参数（延迟加载：lazyLoadingEnabled） 账户类 持久层接口12345678910111213141516@Select("SELECT * FROM account")@Results(id = "accountMap", value = &#123; @Result(id = true,column = "id",property = "id"), @Result(column = "uid",property = "uid"), @Result(column = "money",property = "money"), /* 传递值：uid，变量名：user */ @Result(column = "uid", property = "user", one = @One(select = "cn.water.dao.UserDao.findById", fetchType = FetchType.LAZY ) ) &#125;)List&lt;Account&gt; findAll(); 用户类 持久层接口12@Select("SELECT * FROM user WHERE id = #&#123;id&#125;")User findById(); 测试类1234567@Testpublic void test01()&#123; AccountDao dao = session.getMapper(AccountDao.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125;&#125; 运行结果![](13.注解 多表查询 延迟加载\注解 一对一查询 延迟查询.png) 一对多查询（延迟） @Many注解代替了&lt;Collection&gt;标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注解 @Many：实现一对多结果集封装 select：指定用来多表查询的sqlmapper fetchType：覆盖全局的配置参数（延迟加载：lazyLoadingEnabled） 用户类 持久层接口12345678910111213141516@Select("SELECT * FROM user")@Results(id = "userMap",value = &#123; @Result(id = true,column = "id",property = "id"), @Result(column = "username",property = "username"), @Result(column = "birthday",property = "birthday"), @Result(column = "sex",property = "sex"), @Result(column = "address",property = "address"), /* 传递值：uid，变量名：accounts */ @Result(column = "id", property = "accounts", many = @Many(select = "cn.water.dao.AccountDao.findByUid", fetchType = FetchType.LAZY ) )&#125;)List&lt;User&gt; findAll(); 账户类 持久层接口12@Select("SELECT * FROM account WHERE uid = #&#123;id&#125;")Account findByUid(Integer id); 测试类1234567@Testpublic void test02()&#123; UserDao dao = session.getMapper(UserDao.class); for (User user : dao.findAll()) &#123; System.out.println(user); &#125;&#125; 运行结果![](13.注解 多表查询 延迟加载\注解 一对多查询 延迟查询.png)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架12 —— 实现数据库的CRUD操作（基于注解）]]></title>
    <url>%2F2019%2F08%2F10%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F12.%E6%B3%A8%E8%A7%A3%20CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介 如何使用映射配置文件的方式完成 CRUD 操作在前面已经详细的介绍过了，本文将通过使用注解的方式完成 CRUD 操作，并演示 Java实体类变量名 和 数据库字段名 相同和不相同的两种不同的处理方法。 目录结构 src/main java cn/water/dao UserDao.java（持久层接口） User_UserDao.java（持久层接口） cn/water/domain User.java（实体层） User_User.java（实体层） resources SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） src/tese java cn/water/test UserTest.java（测试文件） UserUserTest.java（测试文件） MyBatis主配置文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root SqlMapConfig.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 实体类User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.domain;import java.io.Serializable;import java.util.Date;/** * @author Water * @date 2019/10/13 - 10:41 * @description Java实体类的变量名 与 数据库的字段名 相同 */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; User_User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.domain;import java.io.Serializable;import java.util.Date;/** * @author Water * @date 2019/10/13 - 11:48 * @description Java实体类的变量名 与 数据库的字段名 不相同 */public class User_User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; @Override public String toString() &#123; return "User_User&#123;" + "userId=" + userId + ", userName='" + userName + '\'' + ", userBirthday=" + userBirthday + ", userSex='" + userSex + '\'' + ", userAddress='" + userAddress + '\'' + '&#125;'; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125;&#125; 持久层接口UserDao.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.dao;import cn.water.domain.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * @author Water * @date 2019/10/12 - 16:43 * @description Java实体类的变量名 与 数据库的字段名 相同 */public interface UserDao &#123; /** 添加用户 */ @Insert("INSERT INTO user VALUES(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)") int add(User user); /** 更新用户 */ @Update("update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;") int update(User user); /** 删除用户 */ @Delete("DELETE FROM user WHERE id = #&#123;id&#125;") int delete(Integer id); /** 查询所有用户 */ @Select("SELECT * FROM user ") List&lt;User&gt; findAll(); /** 查询单个用户 */ @Select("SELECT * FROM user WHERE id = #&#123;uid&#125;") User findOne(Integer userId); /** 根据姓名模糊查询 */ @Select("SELECT * FROM user WHERE username LIKE #&#123;username&#125;") List&lt;User&gt; findByName01(String name); @Select("SELECT COUNT(*) FROM user") /** 查询所有用户的数量 */ Integer findTotal();&#125; User_UserDao.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.dao;import cn.water.domain.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * @author Water * @date 2019/10/13 - 11:50 * @description 由于 Java实体类的变量名 与 数据库的字段名 不相同 * 所以需要对 需要封装结果集的操作（查询操作） 进行设置 */public interface User_UserDao &#123; /** 查询所有用户 */ @Select("SELECT * FROM user ") @Results(id = "user_userMap", value = &#123; @Result(id = true,column = "id",property = "userId"), @Result(id = true,column = "username",property = "userName"), @Result(id = true,column = "birthday",property = "userBirthday"), @Result(id = true,column = "sex",property = "userSex"), @Result(id = true,column = "address",property = "userAddress") &#125;) List&lt;User&gt; findAll(); /** 查询用户，根据ID */ @Select("SELECT * FROM user WHERE id=#&#123;id&#125;") @ResultMap("user_userMap") User findById(Integer id); /** 模糊查询，根据username */ @Select("SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' ") @ResultMap("user_userMap") List&lt;User&gt; findByName(String username);&#125; 测试类UserTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package cn.water;import cn.water.dao.UserDao;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;/** * @author Water * @date 2019/10/13 - 10:48 * @description */public class UserTest &#123; private InputStream inputStream; private SqlSessionFactory factory; private SqlSession session; private UserDao dao; @Before public void init() throws IOException &#123; inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); session = factory.openSession(true); dao = session.getMapper(UserDao.class); &#125; @After public void destroy () throws IOException &#123; session.close(); inputStream.close(); &#125; /** 添加用户 */ @Test public void test01()&#123; User user = new User(); user.setId(1); user.setUsername("mybatis anno add"); user.setBirthday(new Date()); user.setSex("男"); user.setAddress("北京"); System.out.println("受影响的行数："+dao.add(user)); &#125; /** 更新用户 */ @Test public void test02()&#123; User user = new User(); user.setId(1); user.setUsername("mybatis anno update"); user.setBirthday(new Date()); user.setSex("男"); user.setAddress("北京"); System.out.println("受影响的行数："+dao.update(user)); &#125; /** 删除用户 */ @Test public void test03()&#123; System.out.println("受影响的行数："+dao.delete(1)); &#125; /** 查询所有用户 */ @Test public void test04()&#123; for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125; /** 查询用户，根据ID */ @Test public void test05()&#123; System.out.println(dao.findById(42)); &#125; /** 模糊查询，根据username */ @Test public void test06()&#123;// for (User user : dao.findByName("%王%")) &#123; for (User user : dao.findByName("王")) &#123; System.out.println(user); &#125; &#125; /** 查询用户数量 */ @Test public void test07()&#123; System.out.println(dao.findTotal()); &#125;&#125; User_UserTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.water;import cn.water.dao.UserDao;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;/** * @author Water * @date 2019/10/13 - 10:48 * @description */public class User_UserTest &#123; private InputStream inputStream; private SqlSessionFactory factory; private SqlSession session; private UserDao dao; @Before public void init() throws IOException &#123; inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); factory = new SqlSessionFactoryBuilder().build(inputStream); session = factory.openSession(true); dao = session.getMapper(UserDao.class); &#125; @After public void destroy () throws IOException &#123; session.close(); inputStream.close(); &#125; /* 查询所用用户 */ @Test public void test04()&#123; for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125; /* 查询单个用户 */ @Test public void test05()&#123; System.out.println(dao.findById(42)); &#125; /* 模糊查询 */ @Test public void test06()&#123;// for (User user : dao.findByName("%王%")) &#123; for (User user : dao.findByName("王")) &#123; System.out.println(user); &#125; &#125;&#125; 实现CRUD操作 单表的CRUD操作是最基本的操作，前面我们的学习都是基于Mybaits的映射配置文件来实现的，现在我们试着使用基于MyBatis注解的方式来实现CRUD操作。 本案例的情况是：Java实体类的变量名 与 数据库的字段名 相同 注解 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 添加用户 持久层接口 12@Insert("INSERT INTO user VALUES (#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)")int add (User user); 更新用户 持久层接口 12@Update("UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;id&#125;")int update (User user); 删除用户 持久层接口 12@Delete("DELETE FROM user WHERE id=#&#123;id&#125;")int delete (Integer id); 查找所有用户 持久层接口 12@Select("SELECT * FROM user ")List&lt;User&gt; findAll(); 查询单个用户 持久层接口 12@Select("SELECT * FROM user WHERE id=#&#123;id&#125;")User findById(Integer id); 根据姓名模糊查询 持久层接口 123// @Select("SELECT * FROM user WHERE username LIKE #&#123;username&#125;") @Select("SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' ") List&lt;User&gt; findByName(String username); 查询所有用户数量 持久层接口 12@Select("SELECT COUNT(*) FROM user ")Integer findTotal(); 实现查询操作 当 Java实体类的变量名 与 数据库的字段名 不相同时，我们需要设置 @Results注解。 注解 @Result：实现结果集封装 id：是否是主键字段 column：数据库的列名 property：需要装配的属性名 one：需要使用的@One注解（@Result（one=@One）（））） many：需要使用的@Many注解（@Result（many=@many）（））） @Results：封装多个结果集 @ResultMap：实现引用@Results定义的封装 查找所有用户 持久层接口 12345678910@Select("SELECT * FROM user ") @Results(id = "user_userMap", value = &#123; @Result(id = true,column = "id",property = "userId"), @Result(id = true,column = "username",property = "userName"), @Result(id = true,column = "birthday",property = "userBirthday"), @Result(id = true,column = "sex",property = "userSex"), @Result(id = true,column = "address",property = "userAddress") &#125;) List&lt;User&gt; findAll(); 查询单个用户 持久层接口 123@Select("SELECT * FROM user WHERE id=#&#123;id&#125;") @ResultMap("user_userMap") User findById(Integer id); 根据姓名模糊查询 持久层接口 123@Select("SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' ")@ResultMap("user_userMap")List&lt;User&gt; findByName(String username);]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架11 —— 缓存机制]]></title>
    <url>%2F2019%2F08%2F09%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F11.%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[简介 什么是缓存？ 缓存是存在于内存中的临时数据。 为什么使用缓存？ 缓存能够减少和数据库的交互次数，提高执行效率。 什么样的数据适用于缓存，什么样的数据不适用于缓存？ 适用于缓存： 经常查询，并且不经常改变的数据。 数据的正确与否对最终结果的影响不大。 不适用于缓存： 经常改变的数据。 数据的正确与否对最终结果的影响非常大。 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。Mybatis 中缓存分为一级缓存，二级缓存。 一级缓存 当我们执行查询操作之后，Mybatis 框架会将在数据库中的查询的结果自动存储到 SqlSession 中为一级缓存划分的一块区域中。（该区域的低层结构是 Map集合） 当我们再次执行同样的查询操作之后，Mybatis 框架会先从 SqlSession 中的一级缓存区域查询。如果存在数据，就直接拿出来；如果不存在数据，才会去数据库中进行查询。 因为一级缓存区域被设置在 SqlSession 中，所以当 SqlSession 消失时，一级缓存也就消失。 二级缓存 二级缓存被存储在 SqlSessionFactory 中，同一个 SqlSessionFactory 创建的 SqlSession 共享二级缓存。 ![](11.缓存\一级缓存 二级缓存.png) 目录结构src main java cn.water.dao UserDao.java（持久层接口） cn.water.domain User.java（实体类） resources cn.water.dao UserDao.xml（映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） test java.cn.water MybatisTest.java（测试类） MyBatis配置文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root SqlMapConfig.xml 开启 二级缓存 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置参数 --&gt; &lt;settings&gt; &lt;!-- 开启 二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 实体类User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.domain;import java.io.Serializable;import java.util.Date;/** * @author Water * @date 2019/10/12 - 7:51 * @description */public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口UserDao.java123456789101112131415package cn.water.dao;import cn.water.domain.User;/** * @author Water * @date 2019/10/12 - 7:51 * @description */public interface UserDao &#123; /* */ User findById(Integer userId);&#125; 映射配置文件UserDao.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;cache&gt;&lt;/cache&gt; &lt;select id="findById" parameterType="INT" resultType="user" useCache="true"&gt;&lt;!-- &lt;select id="findById" parameterType="INT" resultType="user" &gt;--&gt; SELECT * FROM user WHERE id = #&#123;userId&#125;; &lt;/select&gt;&lt;/mapper&gt; 测试类MyBatisTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.water;import cn.water.dao.UserDao;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * @author Water * @date 2019/10/12 - 7:56 * @description */public class MybatisTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSessionFactory factory; private SqlSession session; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(true);/* 设置自动提交 */ &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /** 一级缓存：同一个 SqlSession */ @Test public void test01()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); User user02 = dao.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02)); //true &#125; /** 一级缓存：不同 SqlSession */ @Test public void test02()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); /* commit()（执行插入、更新、删除）、close() */ session.close(); session = factory.openSession(); UserDao dao02 = session.getMapper(UserDao.class); User user02 = dao02.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02));//false &#125;&#125; 一级缓存测试类12345678910/** 一级缓存：同一个 SqlSession */@Testpublic void test01()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); User user02 = dao.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02));&#125; 运行结果 一级缓存是SqlSession级别的缓存，只要SqlSession没有flush或close，它就存在。 我们可以发现，在测试一中虽然我们查询了两次，但最后只执行了一次数据库操作，这就是Mybatis提供给我们的一级缓存在起作用了。 因为一级缓存的存在，导致第二次查询id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 ![](11.缓存\控制台 证明 一级缓存.png) 一级缓存的清空测试类1234567891011121314/** 一级缓存：不同 SqlSession */@Testpublic void test02()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); /* commit()（执行插入、更新、删除）、close() */ session.close(); session = factory.openSession(); UserDao dao02 = session.getMapper(UserDao.class); User user02 = dao02.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02));&#125; 运行结果 一级缓存是SqlSession范围的缓存，当调用SqlSession的commit()（修改，添加，删除），close()等方法时，就会清空一级缓存。 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。 ![](11.缓存\控制台 证明 一级缓存02.png) 二级缓存 当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable接口，这种就可以使用序列化方式来保存对象。 开启二级缓存 二级缓存的使用步骤： 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置 第三步：让当前的操作支持二级缓存（在select标签中配置） MyBatis主配置文件 开启二级缓存支持 cacheEnabled 默认值为 true（此配置可以省略） 12345678&lt;!-- 配置参数 --&gt;&lt;settings&gt; &lt;!-- 开启 延迟加载 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 开启 二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 映射配置文件 设置 &lt;cache&gt; 标签 表示当前 mapper 映射将使用二级缓存，区分的标准为 mapper 标签的 namespace 值。 12345&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; &lt;select&gt; 标签 设置 useCache=”true” 属性 注意：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。 12345678910&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;cache&gt;&lt;/cache&gt; &lt;select id="findById" parameterType="INT" resultType="user" useCache="true" &gt; SELECT * FROM user WHERE id = #&#123;userId&#125;; &lt;/select&gt;&lt;/mapper&gt; 测试类 依然执行 Test02() 123456789101112131415@Test public void test02()&#123; UserDao dao = session.getMapper(UserDao.class); User user01 = dao.findById(41); System.out.println("第一次查询："+user01); /* commit()（执行插入、更新、删除）、close() */ session.close(); session = factory.openSession(); UserDao dao02 = session.getMapper(UserDao.class); User user02 = dao02.findById(41); System.out.println("第二次查询："+user02); System.out.println("两次查询结果是否相等："+(user01==user02));//false &#125; 运行结果 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出sql语句，所以此时的数据就只能是来自于我们所说的二级缓存。 一级缓存![](11.缓存\控制台 证明 一级缓存02.png) 一级缓存和二级缓存![](11.缓存\控制台 证明 二级缓存.png)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架10 —— 实现多表查询的延迟加载操作]]></title>
    <url>%2F2019%2F08%2F09%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F10.%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[简介 通过前面的学习，我们已经掌握了Mybatis中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。 延迟加载 延迟加载（懒加载）就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。 优点 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张速度要快。 坏处 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 目录结构 src main java cn.water.dao AccountDao.java（持久层接口） UserDao.java（持久层接口） cn.water.domain Account.java（实体类） User.java（实体类） resources cn.water.dao AccountDao.xml（映射配置文件） UserDao.xml（映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） test java.cn.water MybatisTest.java（测试类） MyBatis主配置文件SqlMapConfig.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 数据库连接信息文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root 实体类Account.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.domain;/** * @author Water * @date 2019/10/11 - 8:35 * @description */public class Account &#123; private Integer id; private Integer uid; private Double money; private User user; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + ", user=" + user + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; User.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package cn.water.domain;import java.util.Date;import java.util.List;/** * @author Water * @date 2019/10/11 - 8:35 * @description */public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", accounts=" + accounts + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 持久层接口AccountDao.java1234567891011121314151617181920package cn.water.dao;import cn.water.domain.Account;import java.util.List;/** * @author Water * @date 2019/10/11 - 8:35 * @description */public interface AccountDao &#123; /* 一对一查询 */ List&lt;Account&gt; findAll(); /* 一对多查询 */ List&lt;Account&gt; findById(Integer id);&#125; UserDao.java123456789101112131415161718192021package cn.water.dao;import cn.water.domain.Account;import cn.water.domain.User;import java.util.List;/** * @author Water * @date 2019/10/11 - 8:35 * @description */public interface UserDao &#123; /* 一对一查询 */ User findById(Integer id); /* 一对多查询 */ List&lt;User&gt; findAll();&#125; 映射配置文件AccountDao.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.AccountDao"&gt; &lt;!-- 【次表：Account】 --&gt; &lt;resultMap id="o2o" type="account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 【主表：User】 --&gt; &lt;association property="user" javaType="user" select="cn.water.dao.UserDao.findById" column="uid" &gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="o2o"&gt; SELECT * FROM account &lt;/select&gt; &lt;select id="findById" parameterType="INT" resultType="account"&gt; SELECT * FROM account WHERE uid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; UserDao.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;select id="findById" parameterType="INT" resultType="user"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125; &lt;/select&gt; &lt;!-- 【主表：User】 --&gt; &lt;resultMap id="o2m" type="user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 【次表：Account】 --&gt; &lt;collection property="accounts" ofType="account" select="cn.water.dao.AccountDao.findById" column="id" &gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="o2m"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; 测试类MyBatisTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.water;import cn.water.dao.AccountDao;import cn.water.dao.UserDao;import cn.water.domain.Account;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * @author Water * @date 2019/10/11 - 8:49 * @description */public class MyBatisTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSession session; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(true);/* 设置自动提交 */ &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /* OneToOne */ @Test public void test01()&#123; AccountDao dao = session.getMapper(AccountDao.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125; &#125; /* OneToMany */ @Test public void test02()&#123; UserDao dao = session.getMapper(UserDao.class); for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125;&#125; 一对一查询（延迟） 一对一查询：从查询 账户信息（Account） 出发，关联查询 用户信息（User） 立即加载：一次多表查询 SELECT u.*,a.* FROM user u,account a WHERE u.id = a.uid; 延迟加载：多次单表查询（提供关联信息） SELECT * FROM account;（获取uid） SELECT * FROM user WHERE id = #{uid}; （提供uid） Account 实体类 将 用户类（User）设置为变量 123456789101112 public class Account implements Serializable &#123; /* 成员变量 */ private Integer id; private Integer uid; private Double money; private User user; /* 用户类 */ /* toString方法 省略 */ /* Setter Getter 省略 */ &#125; User 实体类123456789101112public class User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; Account 持久层接口12/* 一对一查询 */List&lt;Account&gt; findAll(); User 持久层接口 返回值 对应 Account类的User变量 12/* 一对一查询 */User findById(Integer id); Account 映射配置文件123456789101112131415161718&lt;!-- 【次表：Account】 --&gt;&lt;resultMap id="o2o" type="account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 【主表：User】 --&gt; &lt;association property="user" javaType="user" select="cn.water.dao.UserDao.findById" column="uid" &gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 单表查询 --&gt;&lt;select id="findAll" resultMap="o2o"&gt; SELECT * FROM account&lt;/select&gt; User 映射配置文件1234&lt;!-- 单表查询 --&gt;&lt;select id="findById" parameterType="INT" resultType="user"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125;&lt;/select&gt; 测试类1234567@Testpublic void test01()&#123; AccountDao dao = session.getMapper(AccountDao.class); for (Account account : dao.findAll()) &#123; System.out.println(account); &#125;&#125; 运行结果![](10.延迟加载\延迟加载 一对一查询 控制台输出.png) 一对多查询（延迟） 一对多查询：从查询 用户信息（User） 出发，关联查询 账户信息（Account） 立即加载：一次多表查询 SELECT * FROM user u LEFT OUTER JOIN account a ON u.id = a.uid; 延迟加载：多次单表查询（通过关联信息） SELECT * FROM user;（获取id） SELECT * FROM account WHERE uid = #{id}（提供id） User 实体类 将 账户类（Account） 的List集合 设置为变量 12345678910111213public class User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts;/* 账户类的集合 */ /* toString方法 省略 */ /* Setter Getter 省略 */&#125; Account 实体类1234567891011public class Account implements Serializable &#123; /* 成员变量 */ private Integer id; private Integer uid; private Double money; /* toString方法 省略 */ /* Setter Getter 省略 */ &#125; User 持久层接口12/* 一对多查询 */ List&lt;User&gt; findAll(); Account 持久层接口 返回值 对应 User类的List&lt;Account&gt;变量 12/* 一对多查询 */ List&lt;Account&gt; findById(Integer id); User 映射配置文件1234567891011121314151617181920&lt;!-- 【主表：User】 --&gt;&lt;resultMap id="o2m" type="user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 【次表：Account】 --&gt; &lt;collection property="accounts" ofType="account" select="cn.water.dao.AccountDao.findById" column="id" &gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 单表查询 --&gt;&lt;select id="findAll" resultMap="o2m"&gt; SELECT * FROM user&lt;/select&gt; Account 映射配置文件1234&lt;!-- 单表查询 --&gt;&lt;select id="findById" parameterType="INT" resultType="account"&gt; SELECT * FROM account WHERE uid = #&#123;id&#125;&lt;/select&gt; 测试类1234567@Testpublic void test02()&#123; UserDao dao = session.getMapper(UserDao.class); for (User user : dao.findAll()) &#123; System.out.println(user); &#125;&#125; 运行结果![](10.延迟加载\延迟加载 一对多查询 控制台输出.png)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架09 —— 实现多表查询操作]]></title>
    <url>%2F2019%2F08%2F08%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F9.%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[简介多表之间的关系 一对多 用户 ——&gt; 订单、订单、订单、订单 多对一（一对一） 订单、订单、订单、订单 ——&gt; 用户 单个订单 ——&gt; 用户 一对一 中国公民——&gt;身份证 多对多 语文老师、数学老师、英语老师——&gt;小明、小红、小黑、小绿 MyBatis中多表之间的关系 本次案例主要以最为简单的用户（User）、账户（Account）、角色（Role）的模型来分析Mybatis多表关系。 用户为User 表，账户为Account表。 一对多关系 一个用户（User）可以开设多个账户（Account） 从查询 用户信息（User） 出发，关联查询 账户信息（Account）属于一对多查询 一对一关系（多对一） 多个账户（Account）可以对应一个用户（User） 单个账户（Account）只能属于一个用户（User） 从查询 账户信息（Account） 出发，关联查询 用户信息（User）属于一对一查询 多对多关系 一个用户（User）可以拥有多个角色（Role） 一个角色（Role）可以赋予多个用户（User） 多对多关系其实我们看成是双向的一对多关系。 目录结构 src main java cn.water.dao M2MDao.java（多对多 持久层接口） O2MDao.java（一对多 持久层接口） O2ODao.java（一对一 持久层接口） cn.water.domain M2M_Role.java（多对多 实体类） M2M_User.java（多对多 实体类） O2M_Account.java（一对多 实体类） O2M_User.java（一对多 实体类） O2O_Account.java（一对一 实体类） O2O_AccountUser.java（一对一 实体类） O2O_User.java（一对一 实体类） resources cn.water.dao M2MDao.xml（多对多 映射配置文件） O2MDao.xml（一对多 映射配置文件） O2ODao.xml（一对一 映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） jdbcConfig.properties（数据库连接信息文件） test java.cn.water MybatisTest.java（测试类） MyBatis主配置文件SqlMapConfig.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 外部配置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定包：实体类--&gt; &lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定包：持久层接口 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 数据库连接信息文件jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root 实体类M2M_Role.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.water.domain;import java.io.Serializable;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:11 * @description ManyToMany 多对多查询 */public class M2M_Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; private List&lt;M2M_User&gt; users; @Override public String toString() &#123; return "M2M_Role&#123;" + "roleId=" + roleId + ", roleName='" + roleName + '\'' + ", roleDesc='" + roleDesc + '\'' + ", users=" + users + '&#125;'; &#125; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; public List&lt;M2M_User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;M2M_User&gt; users) &#123; this.users = users; &#125;&#125; M2M_User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package cn.water.domain;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:11 * @description ManyToMany 多对多查询 */public class M2M_User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;M2M_Role&gt; roles; @Override public String toString() &#123; return "M2M_User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", roles=" + roles + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;M2M_Role&gt; getRoles() &#123; return roles; &#125; public void setRoles(List&lt;M2M_Role&gt; roles) &#123; this.roles = roles; &#125;&#125; O2M_Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.water.domain;import java.io.Serializable;/** * @author Water * @date 2019/10/10 - 19:12 * @description OneToMany 一对多查询 */public class O2M_Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; @Override public String toString() &#123; return "O2M_Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; O2M_User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package cn.water.domain;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:10 * @description OneToMany 一对多查询 */public class O2M_User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;O2M_Account&gt; accounts; @Override public String toString() &#123; return "O2M_User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", accounts=" + accounts + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public List&lt;O2M_Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;O2M_Account&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; O2O_Account.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.water.domain;import java.io.Serializable;/** * @author Water * @date 2019/10/10 - 19:12 * @description OneToOne 一对一查询 */public class O2O_Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; private O2O_User user; @Override public String toString() &#123; return "O2O_Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + ", user=" + user + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public O2O_User getUser() &#123; return user; &#125; public void setUser(O2O_User user) &#123; this.user = user; &#125;&#125; O2O_AccountUser.java123456789101112131415161718192021222324252627282930313233343536373839package cn.water.domain;import java.io.Serializable;/** * @author Water * @date 2019/10/10 - 19:12 * @description OneToOne 一对一查询 */public class O2O_AccountUser extends O2O_Account implements Serializable &#123; private String username; private String address; @Override public String toString() &#123; /* 调用父类的toString方法 */ return super.toString()+" O2O_AccountUser&#123;" + "username='" + username + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; O2O_User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.domain;import java.io.Serializable;import java.util.Date;/** * @author Water * @date 2019/10/10 - 19:10 * @description OneToOne 一对一查询 */public class O2O_User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "O2O_User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层M2MDao.java123456789101112131415161718192021package cn.water.dao;import cn.water.domain.M2M_Role;import cn.water.domain.M2M_User;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:24 * @description ManyToMany 多对多查询 */public interface M2MDao &#123; /* 多表查询，封装类：Role类 User类 */ List&lt;M2M_Role&gt; findAll01(); /* 多表查询，封装类：Role类 User类 */ List&lt;M2M_User&gt; findAll02();&#125; O2MDao.java12345678910111213141516171819package cn.water.dao;import cn.water.domain.O2M_User;import cn.water.domain.O2O_Account;import cn.water.domain.O2O_User;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:24 * @description OneToMany 一对多查询 */public interface O2MDao &#123; /* 多表查询，封装类：Account类 User类 */ List&lt;O2M_User&gt; findAll ();&#125; O2ODao.java123456789101112131415161718192021package cn.water.dao;import cn.water.domain.O2O_Account;import cn.water.domain.O2O_AccountUser;import java.util.List;/** * @author Water * @date 2019/10/10 - 19:24 * @description OneToOne 一对一查询 */public interface O2ODao &#123; /* 多表查询，封装类：Account类 User类*/ List&lt;O2O_Account&gt; findAll01 (); /* 多表查询，封装类：父类Account 子类AccountUser */ List&lt;O2O_AccountUser&gt; findAll02 ();&#125; 映射配置文件M2MDao.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.M2MDao"&gt; &lt;!-- 【Role表】 --&gt; &lt;resultMap id="role" type="m2m_role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;!-- 【User表】 --&gt; &lt;collection property="users" ofType="m2m_user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll01" resultMap="role"&gt; SELECT u.*, r.id rid, r.role_name, r.role_desc FROM role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; O2MDao.xml12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.O2MDao"&gt; &lt;!-- 【主表：User】 --&gt; &lt;resultMap id="o2m" type="o2m_user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 【次表：Account】 --&gt; &lt;collection property="accounts" ofType="o2m_account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 多表查询 --&gt; &lt;select id="findAll" resultMap="o2m"&gt; SELECT * FROM user u LEFT OUTER JOIN account a ON u.id = a.uid; &lt;/select&gt;&lt;/mapper&gt; O2ODao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.water.dao.O2ODao"&gt; &lt;!-- 【次表：Account】 --&gt; &lt;resultMap id="o2o" type="o2o_account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 【主表：User】 --&gt; &lt;association property="user" javaType="o2o_user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 多表查询 --&gt; &lt;select id="findAll01" resultMap="o2o"&gt; SELECT u.*, a.* FROM user u, account a WHERE u.id = a.uid; &lt;/select&gt; &lt;!-- 多表查询 --&gt; &lt;select id="findAll02" resultType="o2o_accountUser"&gt; SELECT a.*, u.username, u.address FROM user u, account a WHERE u.id = a.uid; &lt;/select&gt;&lt;/mapper&gt; 测试类MyBatisTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.water;import cn.water.dao.M2MDao;import cn.water.dao.O2MDao;import cn.water.dao.O2ODao;import cn.water.domain.*;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * @author Water * @date 2019/10/10 - 19:44 * @description */public class MybatisTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSession session; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(true);/* 设置自动提交 */ &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /* OneToOne */ @Test public void test01()&#123; O2ODao dao = session.getMapper(O2ODao.class); for (O2O_Account account : dao.findAll01()) &#123; System.out.println(account); &#125; &#125; /* OneToOne */ @Test public void test02()&#123; O2ODao dao = session.getMapper(O2ODao.class); for (O2O_AccountUser accountUser : dao.findAll02()) &#123; System.out.println(accountUser); &#125; &#125; /* OneToMany */ @Test public void test03()&#123; O2MDao dao = session.getMapper(O2MDao.class); for (O2M_User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125; /* ManyToMany */ @Test public void test04()&#123; M2MDao dao = session.getMapper(M2MDao.class); for (M2M_Role role : dao.findAll01()) &#123; System.out.println(role); &#125; &#125; /* ManyToMany */ @Test public void test05()&#123; M2MDao dao = session.getMapper(M2MDao.class); for (M2M_User user : dao.findAll02()) &#123; System.out.println(user); &#125; &#125;&#125; 一对一查询 从查询 账户信息（Account） 出发，关联查询 用户信息（User） 结果集 当我们查询多个表的时候，我们就需要考虑考虑结果集封装类的问题了。 例如，我们需要查询用户（User）的 username字段 和 address字段 以及账户（Account）的 所有字段。 方法一：根据查询方式，将实体类设置为变量。 方法二：根据查询结果，创建新的实体类。 方法一：将实体类设置为变量 在账户类（Account）直接将 用户类（User）设置为变量，于是账户类即封装了账户信息，又封装了用户信息。 以持久层接口的方法 find01 为案例，查询 Account.uid 与 User.id 相等的所有 Account信息和 User信息。 用户类123456789101112public class O2O_User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private String address; private String sex; private Date birthday; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 账户类（结果集封装类） 将 用户类（User）设置为变量 123456789101112public class O2O_Account implements Serializable &#123; /* 成员变量 */ private Integer id; private Integer uid; private Double money; private User user; /* 用户类 */ /* toString方法 省略 */ /* Setter Getter 省略 */ &#125; 持久层接口1List&lt;O2O_Account&gt; findAll01 (); 映射配置文件 使用resultMap，定义专门的resultMap用于映射一对一查询结果。 12345678910111213141516171819202122232425&lt;!-- 【次表：Account】 --&gt;&lt;resultMap id="o2o" type="o2o_account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 【主表：User】 --&gt; &lt;association property="user" javaType="o2o_user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 多表查询 --&gt;&lt;select id="findAll01" resultMap="o2o"&gt; SELECT u.*, a.* FROM user u, account a WHERE u.id = a.uid;&lt;/select&gt; 测试类1234567@Testpublic void test01()&#123; O2ODao dao = session.getMapper(O2ODao.class); for (O2O_Account account : dao.findAll01()) &#123; System.out.println(account); &#125;&#125; 运行结果1234567891011O2O_Account&#123; id=46, uid=46, money=1000.0, user=O2O_User&#123;id=46, username=&apos;老王&apos;, birthday=Wed Mar 07 17:37:26 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;&#125; O2O_Account&#123; id=45, uid=45, money=1000.0, user=O2O_User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;&#125; 方法二：创建新的实体类 创建 账户子类（AccountUser），由于继承关系我们可以封装账户信息，于是我们只用再设置 usernam变量 和 address变量就可以封装用户信息了。 以持久层接口的方法 find02 为案例，查询 Account.uid 与 User.id 相等的所有 Account信息和 User的usename 和 address信息。 用户类123456789101112public class O2O_User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private String address; private String sex; private Date birthday; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 账户类1234567891011public class O2O_Account implements Serializable &#123; /* 成员变量 */ private Integer id; private Integer uid; private Double money; /* toString方法 省略 */ /* Setter Getter 省略 */ &#125; 账户子类（结果集封装类） 调用父类的toString方法 1234567891011121314151617181920public class O2O_AccountUser extends O2O_Account implements Serializable &#123; /* 成员变量 */ private String username; private String address; /* toString方法 省略 */ @Override public String toString() &#123; /* 调用父类的toString方法 */ return super.toString()+ " AccountUser&#123;" + "username='" + username + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; /* Setter Getter 省略 */ &#125; 持久层接口1List&lt;O2O_AccountUser&gt; findAll02 (); 映射配置文件123456789101112 &lt;!-- 多表查询 --&gt;&lt;select id="findAll02" resultType="o2o_accountUser"&gt; SELECT a.*, u.username, u.address FROM user u, account a WHERE u.id = a.uid;&lt;/select&gt; 测试类1234567@Testpublic void test02()&#123; O2ODao dao = session.getMapper(O2ODao.class); for (O2O_AccountUser accountUser : dao.findAll02()) &#123; System.out.println(accountUser); &#125;&#125; 运行结果123O2O_Account&#123;id=1, uid=46, money=1000.0, user=null&#125; O2O_AccountUser&#123;username=&apos;老王&apos;, address=&apos;北京&apos;&#125;O2O_Account&#123;id=2, uid=45, money=1000.0, user=null&#125; O2O_AccountUser&#123;username=&apos;传智播客&apos;, address=&apos;北京金燕龙&apos;&#125;O2O_Account&#123;id=3, uid=46, money=2000.0, user=null&#125; O2O_AccountUser&#123;username=&apos;老王&apos;, address=&apos;北京&apos;&#125; 一对多查询 从查询 用户信息（User） 出发，关联查询 账户信息（Account） 用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。 用户类 一对多关系映射：主表实体类 应该包含 从表实体类的集合引用 12345678910111213public class O2M_User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;O2M_Account&gt; accounts; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 账户类12345678910111213public class O2M_Account implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;O2M_Account&gt; accounts; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 持久层接口1List&lt;O2M_User&gt; findAll (); 映射文件123456789101112131415161718192021222324 &lt;!-- 【主表：User】 --&gt;&lt;resultMap id="o2m" type="o2m_user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 【次表：Account】 --&gt; &lt;collection property="accounts" ofType="o2m_account"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 多表查询 --&gt;&lt;select id="findAll" resultMap="o2m"&gt; SELECT * FROM user u LEFT OUTER JOIN account a ON u.id = a.uid;&lt;/select&gt; 测试类1234567@Testpublic void test03()&#123; O2MDao dao = session.getMapper(O2MDao.class); for (O2M_User user : dao.findAll()) &#123; System.out.println(user); &#125;&#125; 测试结果123456O2M_User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;, accounts=[O2M_Account&#123;id=41, uid=null, money=null&#125;]&#125;O2M_User&#123;id=42, username=&apos;小二王&apos;, birthday=Fri Mar 02 15:09:37 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;, accounts=[O2M_Account&#123;id=42, uid=null, money=null&#125;]&#125;O2M_User&#123;id=43, username=&apos;小二王&apos;, birthday=Sun Mar 04 11:34:34 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;, accounts=[O2M_Account&#123;id=43, uid=null, money=null&#125;]&#125;O2M_User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;, accounts=[O2M_Account&#123;id=45, uid=45, money=1000.0&#125;]&#125;O2M_User&#123;id=46, username=&apos;老王&apos;, birthday=Wed Mar 07 17:37:26 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;, accounts=[O2M_Account&#123;id=46, uid=46, money=1000.0&#125;]&#125;O2M_User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=Thu Mar 08 11:44:00 CST 2018, sex=&apos;女&apos;, address=&apos;北京修正&apos;, accounts=[O2M_Account&#123;id=48, uid=null, money=null&#125;]&#125; 多对多查询 多对多关系其实我们看成是双向的一对多关系。 用户类 多对多关系映射：两个实体类应该包含彼此的集合引用 12345678910111213public class M2M_User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;M2M_Role&gt; roles; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 角色类 多对多关系映射：两个实体类应该包含彼此的集合引用 1234567891011public class M2M_Role implements Serializable &#123; /* 成员变量 */ private Integer roleId; private String roleName; private String roleDesc; private List&lt;M2M_User&gt; users; /* toString方法 省略 */ /* Setter Getter 省略 */&#125; 持久层接口1List&lt;M2M_Role&gt; findAll(); 映射文件12345678910111213141516171819202122232425262728293031 &lt;!-- 【Role表】 --&gt;&lt;resultMap id="role" type="m2m_role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;!-- 【User表】 --&gt; &lt;collection property="users" ofType="m2m_user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="findAll" resultMap="role"&gt; SELECT u.*, r.id rid, r.role_name, r.role_desc FROM role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid&lt;/select&gt; 测试类1234567@Testpublic void test04()&#123; M2MDao dao = session.getMapper(M2MDao.class); for (M2M_Role role : dao.findAll()) &#123; System.out.println(role); &#125;&#125; 测试结果123M2M_Role&#123;roleId=1, roleName=&apos;院长&apos;, roleDesc=&apos;管理整个学院&apos;, users=[M2M_User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;, roles=null&#125;, M2M_User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;, roles=null&#125;]&#125;M2M_Role&#123;roleId=2, roleName=&apos;总裁&apos;, roleDesc=&apos;管理整个公司&apos;, users=[M2M_User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;, roles=null&#125;]&#125;M2M_Role&#123;roleId=3, roleName=&apos;校长&apos;, roleDesc=&apos;管理整个学校&apos;, users=[]&#125; 比较：O2O O2M一对一实体类 用户类 id username birthday sex address 账户类 id uid money user 映射配置文件 association标签 javaType属性 1234567891011121314&lt;!-- 【次表：Account】 --&gt;&lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;!-- 【主表：User】 --&gt; &lt;association property="user" javaType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多实体类 用户类 id username birthday sex address LIst&lt;Account&gt; 账户类 id uid money 映射配置文件 collection标签 ofType属性 1234567891011121314&lt;!-- 【主表：User】 --&gt;&lt;resultMap id="userAccountMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;!-- 【次表：Account】 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架08 —— Java与数据库的数据匹配方式]]></title>
    <url>%2F2019%2F08%2F08%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F8.%E6%95%B0%E6%8D%AE%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方式一：修改 JavaBean变量 在 JavaBean中，将 变量名 设置为 数据库的字段名 MySQL数据库 字段 id username birthday sex address Java实体类 变量名 id username birthday sex address 映射配置文件12345678910&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT id, username, address, sex, birthday FROM user;&lt;/select&gt; 方式二：修改 SQL语句 在SQL语句中，为 数据库字段 设置 别名 MySQL数据库 字段 id username birthday sex address Java实体类 变量名 userId username userBirthday userSex userAddress 映射配置文件12345678910&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT id AS userId, username, address AS userAddress, sex AS userSex, birthday AS userBrithday FROM user;&lt;/select&gt; 方式三：设置 对应关系 在 映射配置文件 中，设置 JavaBean变量 与 数据库字段 的对应关系。 变量：数据类型MySQL数据库 字段 id username birthday sex address Java实体类 变量名 userId username userBirthday userSex userAddress 映射配置文件1234567891011121314&lt;!-- 设置对应关系 --&gt;&lt;resultMap id="userMap" type="cn.water.domain.User"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property="userId" column="id" &gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property="username" column="username" &gt;&lt;/result&gt; &lt;result property="UserBirthday" column="birthday" &gt;&lt;/result&gt; &lt;result property="UserSex" column="sex" &gt;&lt;/result&gt; &lt;result property="UserAddress" column="address" &gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id="findAll" resultMap="userMap"&gt; SELECT id * FROM user;&lt;/select&gt; 变量：JavaBean（多表查询）MySQL数据库 用户表 字段 id username birthday sex address 账户表 字段 id uid money Java实体类 账户类 变量名 id uid money User 映射配置文件123456789101112 &lt;resultMap id="userAccountsMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;collection property="accountList" ofType="account"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; ##]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架07 —— 连接池与事务机制]]></title>
    <url>%2F2019%2F08%2F07%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F7.%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[连接池 连接池是用于存储连接的容器。 容器必须是一个线程安全的集合对象，并且具有队列的特性：先进先出。 MyBatis连接池 我们在前面的WEB课程中也学习过类似的连接池技术，而在Mybatis中也有连接池技术，但是它采用的是自己的连接池技术。 在Mybatis中我们将它的数据源dataSource分为以下几类： UNPOOLED：采用传统的获取连接的方式。 POOLED：采用传统的 javax.sql.DataSource规范中的连接池。 JNDI：采用服务器提供的 JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。 ![](7.连接池与事务\MyBatis DataSource jar包.png) UNPLLED执行语句，控制台显示结果 底层代码 虽然 UNPOOLED 并没有使用池的思想，但是 MyBatis框架依然定义了 java.sql.DataSource接口 的实现类 UnpooledDataSource 来表示 UNPOOLED类型 的数据源。 POOLED执行语句，控制台显示结果 底层代码 MyBatis框架定义了 java.sql.DataSource接口 的是实现类 DataSource 来表示 POOLED类型 的数据源。 MyBatis连接池的配置 在 Mybatis 的 SqlMapConfig.xml配置文件 中，通过 &lt;dataSource type=”pooled”&gt; 来实现 Mybatis 中连接池的配置。 123456789101112&lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- MyBatis连接池的配置 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; Mybatis连接池的存取 MyBatis 通过工厂模式来创建 DataSource连接池对象，MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法 返回DataSource连接池对象。 当我们需要创建 SqlSession对象 并需要执行 SQL语句 时，这时候 MyBatis 才会去调用 dataSource对象 来创建 connection数据库连接对象。也就是说，Connection对象的创建一直延迟到执行SQL语句的时候。 数据库连接是我们最为宝贵的资源，只有在要用到的时候，才去获取并打开连接，当我们用完了就再立即将数据库连接归还到连接池中。 事务控制 在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法 就可以调整。Mybatis框架 对 JDBC 进行了封装，所以 Mybatis框架 的事务控制方式，本身也是用 JDBC 的在· setAutoCommit()方法 来设置事务提交方式的。 MyBatis事务控制 Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoCommit()来实现事务控制。 我们运行之前所写的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UserTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSession session; private UserDao dao; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(); /* 获取 代理对象 */ dao = session.getMapper(UserDao.class); &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /** 添加用户 */ @Test public void test01()&#123; dao.add( new User(100,"ADD",new Date(),"男","UserDao") ); session.commit(); &#125; /** 更新用户 */ @Test public void test02()&#123; dao.update( new User(100,"UPDATE",new Date(),"男","UserDao") ); session.commit(); &#125; /** 删除用户 */ @Test public void test03()&#123; dao.delete(100); session.commit(); &#125;&#125; 控制台输出结果 它显示了 Connection数据库连接对象 的整个变化过程 ![](7.连接池与事务/MyBatis事务 控制台输出.png) MyBatis自动提交事务的设置 通过上面的研究和分析，现在我们一起思考，为什么 CUD过程 中必须使用 sqlSession.commit()提交事务？ 主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的 connection.commit()方法 实现事务提交。 我们在通过 SqlSession工厂类 生产 SqlSession类 时，可以传递布尔值 true 来设置 自动提交事务。 MyBatis动态SQL语句的编写if 标签 &lt;if&gt;标签 的 test属性 中写的是对象的属性名，如果是包装类的对象要使用OGNL表达式的写法。 另外要注意where 1=1 的作用~！ 持久层接口12/** 根据用户信息，查询用户列表 */List&lt;User&gt; findByUser1(User user); 映射配置文件123456789101112131415&lt;!-- SELECT * FROM user WHERE 1 = 1 AND username LIKE #&#123;username&#125; AND address LIKE #&#123;address&#125; --&gt;&lt;select id="findByUser1" resultType="user" parameterType="user"&gt; /* SQL语句 */ SELECT * FROM user WHERE 1 = 1 /* 动态SQL语句 */ &lt;if test="username!=null and username!='' "&gt; AND username LIKE #&#123;username&#125; &lt;/if&gt; &lt;if test="address!=null "&gt; AND address LIKE #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 测试类123456@Testpublic void test01()&#123; for (User user : dao.findByUser1(new User("老王","北京"))) &#123; System.out.println(user); &#125;&#125; where 标签 为了简化上面where 1=1的条件拼装，我们采用&lt;where&gt;标签来简化开发。 持久层接口12/** 根据用户信息，查询用户 */List&lt;User&gt; findByUser2(User user); 映射配置文件12345678910111213141516171819202122&lt;!-- 设置SQL语句 --&gt;&lt;sql id="select"&gt; SELECT * FROM user&lt;/sql&gt;&lt;!-- SELECT * FROM user WHERE username LIKE #&#123;username&#125; AND address LIKE #&#123;address&#125; --&gt;&lt;select id="findByUser2" resultType="user" parameterType="user"&gt; /* 使用设置的 SQL语句 */ &lt;include refid="select"&gt;&lt;/include&gt; /* 动态SQL语句 */ &lt;where&gt; &lt;if test="username!=null and username!='' "&gt; AND username LIKE #&#123;username&#125; &lt;/if&gt; &lt;if test="address!=null "&gt; AND address LIKE #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试类123456@Testpublic void test02()&#123; for (User user : dao.findByUser2(new User("老王","北京"))) &#123; System.out.println(user); &#125;&#125; foreach 标签QueryVo类 封装List集合，存储要查询的ID 123456789101112public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; 持久层接口12/** 在ID范围，查询用户 */List&lt;User&gt; findByIDs(QueryVo queryVo); 映射配置文件 SQL语句： select 字段 from user where id in (?) &lt;foreach&gt;标签 用于遍历集合，它的属性： collection属性：代表要遍历的集合元素，注意编写时不要写#{} open属性：代表语句的开始部分 close属性：代表结束部分 item属性：代表遍历集合的每个元素 sperator属性：代表分隔符 12345678910111213141516171819202122&lt;!-- 设置SQL语句 --&gt;&lt;sql id="select"&gt; SELECT * FROM user&lt;/sql&gt;&lt;!-- 在ID范围，查询用户 --&gt;&lt;select id="findByIDs" resultType="user" parameterType="queryVo" &gt; /* 使用设置的 SQL语句 */ &lt;include refid="select"&gt;&lt;/include&gt; /* 动态SQL语句 */ &lt;where&gt; &lt;if test="list!=null and list.size()&gt;0 "&gt; &lt;foreach collection="list" open=" id IN (" close=")" item="item" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试类12345678@Testpublic void test03()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Collections.addAll(list,41,42,43,46); for (User user : dao.findByIDs(new QueryVo(list))) &#123; System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架06 —— MyBatis主配置文件中的常用标签]]></title>
    <url>%2F2019%2F08%2F06%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F6.MyBatis%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[简介 介绍 MyBatis主配置文件 中常用的三个标签 properties标签：用于数据库连接的内外部配置。 typeAliases标签：用于对全类名设置别名。 package标签：用于指定类。 properties标签 在之前MyBatis主配置文件的环境搭建中，我们将连接数据库的4个基本信息编写在MyBatis主配置文件中，这种方式属于内部配置。 我们也可以选择外部配置的方式，只要我们通过properties标签来引用外部配置文件信息即可。 内部配置SqlMapConfig.xml1234567891011121314151617&lt;configuration&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 内部配置：连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 外部配置 外部配置的两种方式 resource=”jdbcConfig.properties” url=”file:///C:\Users\water\IDEA-workspace\mybatis_CRUD\src\main\resources\jdbcConfig.properties” URL 统一资源定位符（Uniform Resource Locator） 表示一个资源位置的唯一标识。 由协议、主机、端口和URI组成 http://localhost:8080/mybatis/demo file://localhost:8080/mybatis/demo.java URI 统一资源标识符（Uniform Resource Locator） 在某个应用中，表示一个资源位置的唯一标识。 jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee42jdbc.username=rootjdbc.password=1234 SqlMapConfig.xml12345678910111213141516&lt;!-- MyBatis主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 外部配置的两种方式:resource或url --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;properties url="file:///C:\Users\water\IDEA-workspace\mybatis_CRUD\src\main\resources\jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- ................. --&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;!-- ................. --&gt; &lt;/configuration&gt; typeAliases标签 在之前MyBatis主配置文件的环境搭建中，我们在持久层接口的映射配置文件中的resultType属性中，每次都需要输入冗长的实体类全类名。我们可以通过 typeAliases标签 来取别名，从而避免输入冗长的实体类全类名问题。 别名不区分大小写。实体类全类名 UserDao.xml1234567891011121314&lt;!-- 添加用户 --&gt;&lt;select id="add" parameterType="cn.water.domain.User" &gt;&lt;/select&gt;&lt;!-- 更新用户 --&gt;&lt;select id="update" parameterType="cn.water.domain.User"&gt;&lt;/select&gt;&lt;!-- 删除用户 --&gt;&lt;select id="delete" parameterType="INT" &gt;&lt;/select&gt;&lt;!-- 查询所有 --&gt;&lt;select id="findAll" resultType="cn.water.domain.User"&gt;&lt;/select&gt;&lt;!-- 查询单个用户 --&gt;&lt;select id="findOne" parameterType="INT" resultType="cn.water.domain.User"&gt;&lt;/select&gt; 起别名SqlMapConfig.xml12345678910&lt;configuration&gt;&lt;!-- ................. --&gt; &lt;!-- 起别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias type="cn.water.domain.User" alias="user"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;!-- ................. --&gt;&lt;/configuration&gt; UserDao.xml1234567891011121314&lt;!-- 添加用户 --&gt;&lt;select id="add" parameterType="user" &gt;&lt;/select&gt;&lt;!-- 更新用户 --&gt;&lt;select id="update" parameterType="user"&gt;&lt;/select&gt;&lt;!-- 删除用户 --&gt;&lt;select id="delete" parameterType="INT" &gt;&lt;/select&gt;&lt;!-- 查询所有 --&gt;&lt;select id="findAll" resultType="user"&gt;&lt;/select&gt;&lt;!-- 查询单个用户 --&gt;&lt;select id="findOne" parameterType="INT" resultType="user"&gt;&lt;/select&gt; package标签 使用 TypeAliases标签 为每个实体类起别名的确简化了我们的操作，但我们也需要为每一个实体类手动的其别名，仍然有简化的余地。为了是操作更加简便，我们可以使用Package标签来指定包，来自动加载包下的所有实体类，并以其类名作为别名，不区分大小写。另外，Mappers标签中有Package属性，用于指定包，来自动加载包下的所有映射文件。相当于代替了所有的Mapper标签。 mappers标签mapper标签123456&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;mapper resource="cn/water/dao/AccountDao.xml"&gt;&lt;/mapper&gt; &lt;mapper resource="cn/water/dao/StudentDao.xml"&gt;&lt;/mapper&gt; &lt;mapper resource="cn/water/dao/EmployeeDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt; package标签123&lt;mappers&gt; &lt;package name="cn.water.dao"/&gt;&lt;/mappers&gt; typeAliases标签mapper标签123456&lt;typeAliases&gt; &lt;typeAlias type="cn.water.domain.User" alias="user"&gt;&lt;/typeAlias&gt; &lt;typeAlias type="cn.water.domain.Account" alias="account"&gt;&lt;/typeAlias&gt; &lt;typeAlias type="cn.water.domain.Student" alias="studnet"&gt;&lt;/typeAlias&gt; &lt;typeAlias type="cn.water.domain.Employee" alias="employee"&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; package标签 别名默认为类名 123&lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt;&lt;/typeAliases&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架04 —— 手动编写持久层实现类实现CRUD操作]]></title>
    <url>%2F2019%2F08%2F04%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F4.MyDao%20CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介 MyBatis环境搭建 的方式在前面已经详细的介绍过了，本文仍然通过映射配置文件，但不再使用代理持久层接口实现类的方式，而是使用手动编写持久层实现类的方式来进行MySQL数据库的CRUD操作。 创建持久层接口实现类的方式在实际开发中并不常用，所以我会将本文的主题放在与使用代理持久层实现类方法的比较上。 改变的内容主要是测试类和持久层接口实现类。 目录结构 src/main java cn/water/dao impl UserDaoImpl.java（持久层实现类） UserDao.java（持久层接口） cn/water/domain User.java（实体类） resources cn/water/dao UserDao.xml（映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 持久层接口UserDao.java123456789101112131415161718192021222324252627282930313233343536package cn.water.dao;import cn.water.domain.User;import java.util.List;public interface UserDao &#123; /** 添加用户 */ void add(User user); /** 更新用户 */ void update(User user); /** 删除用户 */ void delete(Integer id); /** 查询所有用户 */ List&lt;User&gt; findAll(); /** 查询单个用户 */ User findOne(Integer id); /** 根据姓名模糊查询 */ List&lt;User&gt; findByName01(String name); List&lt;User&gt; findByName02(String name); /** 查询所有用户的数量 */ Integer findTotal(); /** 添加用户 + 返回ID */ /*Integer addReturnID(User user);*/ /** 根据QueryVo对象的条件，模糊查询 */ /*List&lt;User&gt; findByQueryVO(QueryVo queryVo);*/&#125; 映射配置文件UserDao.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 添加用户 --&gt; &lt;!-- 参数类型 JavaBean，占位符 = 成员变量名的小写形式 --&gt; &lt;select id="add" parameterType="cn.water.domain.User" &gt; INSERT INTO user VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125; ) ; &lt;/select&gt; &lt;!-- 更新用户 --&gt; &lt;select id="update" parameterType="cn.water.domain.User"&gt; UPDATE user SET username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;, address = #&#123;address&#125; WHERE id = #&#123;id&#125; ; &lt;/select&gt; &lt;!-- 删除用户 --&gt; &lt;!-- 参数类型 基本类型，占位符 = 方法参数名称 --&gt; &lt;select id="delete" parameterType="INT" &gt; DELETE FROM user WHERE id = #&#123;id&#125;; &lt;/select&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt; &lt;!-- 查询单个用户 --&gt; &lt;select id="findOne" parameterType="INT" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; ; &lt;/select&gt; &lt;!-- 根据姓名模糊查询 --&gt; &lt;select id="findByName01" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;username&#125;; &lt;/select&gt; &lt;select id="findByName02" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'; &lt;/select&gt; &lt;!-- 查询所有用户的数量 --&gt; &lt;select id="findTotal" resultType="INT" &gt; SELECT COUNT(*) FROM user; &lt;/select&gt; &lt;/mapper&gt; 持久层实现类UserDaoImp.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.water.dao;import cn.water.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.junit.After;import java.util.List;public class UserDaoImp implements UserDao &#123; /** 私有成员变量 */ private SqlSessionFactory factory; private SqlSession session; /** 带参构造 */ /* 初始化操作： factory 和 session */ public UserDaoImp(SqlSessionFactory factory)&#123; this.factory = factory; session = factory.openSession(); &#125; /** 销毁操作 */ /* 释放资源 */ @After public void destroy() &#123; session.close(); &#125; /** 添加用户 */ public void add(User user)&#123; session.insert("cn.water.dao.UserDao.add", user); session.commit(); &#125;; /** 更新用户 */ public void update(User user)&#123; session.update("cn.water.dao.UserDao.update", user); session.commit(); &#125;; /** 删除用户 */ public void delete(Integer id)&#123; session.delete("cn.water.dao.UserDao.delete", id); session.commit(); &#125;; /** 查询所有用户 */ public List&lt;User&gt; findAll()&#123; return session.selectList("cn.water.dao.UserDao.findAll"); &#125;; /** 查询单个用户 */ public User findOne(Integer id)&#123; return session.selectOne("cn.water.dao.UserDao.findOne", id); &#125;; /** 根据姓名模糊查询 */ public List&lt;User&gt; findByName01(String name)&#123; return session.selectList("cn.water.dao.UserDao.findByName01", name); &#125;; public List&lt;User&gt; findByName02(String name)&#123; return session.selectList("cn.water.dao.UserDao.findByName02", name); &#125;; /** 查询所有用户的数量 */ public Integer findTotal()&#123; return session.selectOne("cn.water.dao.UserDao.findTotal"); &#125;;&#125; 测试类Test.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package cn.water.test;import cn.water.dao.UserDao;import cn.water.dao.UserDaoImp;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class UserTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSession session; private UserDao dao; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 持久层实现类 */ dao = new UserDaoImp(factory); &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; inputStream.close(); &#125; /** 添加用户 */ @Test public void test01()&#123; dao.add( new User(100,"ADD",new Date(),"男","UserDao") ); &#125; /** 更新用户 */ @Test public void test02()&#123; dao.update( new User(100,"UPDATE",new Date(),"男","UserDao") ); &#125; /** 删除用户 */ @Test public void test03()&#123; dao.delete(100); &#125; /** 查询所有用户 */ @Test public void test04()&#123; for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125; /** 查询单个用户 */ @Test public void test05()&#123; System.out.println( dao.findOne(41) ); &#125; /** 根据用户模糊查询 */ @Test public void test06()&#123; // LIKE #&#123;username&#125; 使用的是PreparedStatement对象 List&lt;User&gt; userList1 = dao.findByName01("%王%"); // LIKE '%$&#123;value&#125;%' 使用的是Statement对象 List&lt;User&gt; userList2 = dao.findByName02("王"); /* 输出 */ for (User user : userList1) &#123; System.out.println("1--"+user); &#125; for (User user : userList2) &#123; System.out.println("2--"+user); &#125; &#125; /** 查询所有用户的数量 */ @Test public void test07()&#123; System.out.println( dao.findTotal() ); &#125;&#125; ProxyDao vs MyDao ProxyDao 和 MyDao 的具体区别在于： 当我们使用代理持久层实现类的方式时，代理对象会帮我们增强代码去调用 selectList方法； 但是当我们使用手动编写持久层实现类的方式时，我们就需要自己去编写实现类实现方法去调用 selectList方法了。 而且我们不难发现，都是实现同一个功能，在测试类中 ProxyDao 比 MyDao 多了2行代码。但恐怖的是，MyDao 比 ProxyDao 多了一个类。 ProxyDao测试类1234567891011121314151617/* 1.加载 MyBatis配置文件 */inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");/* 2.获取 工厂类 */SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);/* 3.获取 产品类 */session = factory.openSession();/* 4.获取 代理对象 */dao = session.getMapper(UserDao.class);/* 5.调用方法 */dao.add( new User(100,"ADD",new Date(),"男","UserDao") );/* 6.提交事务 */session.commit();/* 7.释放资源 */session.close();inputStream.close(); MyDao测试类12345678910111213/* 1.加载 MyBatis配置文件 */inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");/* 2.获取 工厂类 */SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);/* 3.获取 持久层实现类 */dao = new UserDaoImp(factory);/* 5.调用方法 */dao.add( new User(100,"ADD",new Date(),"男","UserDao") );/* 7.释放资源 */inputStream.close(); 实现类1234567/* 5.调用方法 */session.insert("cn.water.dao.UserDao.add", user);/* 6.提交事务 */session.commit();/* 7.释放资源 */session.close(); 实现CRUD操作 本章节抛开了获取代理持久层实现类或持久层实现类的代码，以便直接显示 ProxyDao 和 MyDao 的具体区别。 我们可以明显的看出 MyDao 代码的臃肿，所以这也是为什么手动编写持久层实现类的方法在实际编程中不受欢迎的原因了。 思维导图![](4.MyDao CRUD操作/ProxyDao MyDao 区别.png) 添加用户ProxyDao 测试类 12dao.add( new User(100,"ADD",new Date(),"男","UserDao") );session.commit(); MyDao 测试类 1dao.add( new User(100,"ADD",new Date(),"男","UserDao") ); 实现类 1234public void add(User user)&#123; session.insert("cn.water.dao.UserDao.add", user); session.commit();&#125;; 更新用户ProxyDao 测试类 12dao.update( new User(100,"UPDATE",new Date(),"男","UserDao") );session.commit(); MyDao 测试类 1dao.update( new User(100,"UPDATE",new Date(),"男","UserDao") ); 实现类 1234public void update(User user)&#123; session.update("cn.water.dao.UserDao.update", user); session.commit();&#125;; 删除用户ProxyDao 测试类 12dao.delete(100);session.commit(); MyDao 测试类 1dao.delete(100); 实现类 1234public void delete(Integer id)&#123; session.delete("cn.water.dao.UserDao.delete", id); session.commit();&#125;; 查找所有用户ProxyDao 测试类 123for (User user : dao.findAll()) &#123; System.out.println(user);&#125; MyDao 测试类 123for (User user : dao.findAll()) &#123; System.out.println(user);&#125; 实现类 123public List&lt;User&gt; findAll()&#123; return session.selectList("cn.water.dao.UserDao.findAll");&#125;; 查询单个用户ProxyDao 测试类 1System.out.println( dao.findOne(41) ); MyDao 测试类 1System.out.println( dao.findOne(41) ); 实现类 123public User findOne(Integer id)&#123; return session.selectOne("cn.water.dao.UserDao.findOne", id);&#125;; 根据姓名模糊查询ProxyDao 测试类 123456789List&lt;User&gt; userList1 = dao.findByName01("%王%"); List&lt;User&gt; userList2 = dao.findByName02("王"); for (User user : userList1) &#123; System.out.println("1--"+user); &#125; for (User user : userList2) &#123; System.out.println("2--"+user); &#125; MyDao 测试类 123456789List&lt;User&gt; userList1 = dao.findByName01("%王%"); List&lt;User&gt; userList2 = dao.findByName02("王"); for (User user : userList1) &#123; System.out.println("1--"+user); &#125; for (User user : userList2) &#123; System.out.println("2--"+user); &#125; 实现类 1234567public List&lt;User&gt; findByName01(String name)&#123; return session.selectList("cn.water.dao.UserDao.findByName01", name);&#125;;public List&lt;User&gt; findByName02(String name)&#123; return session.selectList("cn.water.dao.UserDao.findByName02", name);&#125;; 查询所有用户数量ProxyDao 测试类 1System.out.println( dao.findTotal() ); MyDao 测试类 1System.out.println( dao.findTotal() ); 实现类 123public Integer findTotal()&#123; return session.selectOne("cn.water.dao.UserDao.findTotal");&#125;; 执行过程（思维流图）查询方法![](4.MyDao CRUD操作/MyDao 查询操作 底层.png) 增删改方法![](4.MyDao CRUD操作/MyDao 增删改操作 底层.png)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架03 —— 使用代理持久层实现类实现CRUD操作]]></title>
    <url>%2F2019%2F08%2F03%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F3.ProxyDao%20CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介 MyBatis环境搭建 的方式在前面已经详细的介绍过了，本文将通过映射配置文件，使用代理持久层实现类的方式，来进行MySQL数据库的CRUD操作。 环境搭建成功后，MySQL数据库的CRUD操作基于以下几个文件的基础上进行修改： UserDao.java（持久层接口） 添加CRUD操作的抽象方法。 UserDao.xml（持久层接口的映射配置文件） 添加持久层接口的全类名：namespace 添加CRUD操作的mapper子标签：select、update、insert、 添加方法名：id 添加返回值类型的全类名：resultType 环境搭建Maven项目依赖 在pom.xml 文件中，并不引入MyBatis框架的依赖： mybatis（MyBatis框架） mysql-connector-java（数据库连接） junit （单元测试） 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section03_CRUD_ProxyDao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- MyBatis框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 数据库表123456789101112131415161718192021#创建数据库CREATE DATABASE mybatis;USE mybatis;#创建表CREATE TABLE USER( id INT(11) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, birthday DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, sex CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, address VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos; ) ENGINE = INNODB DEFAULT CHARSET = utf8;#插入数据INSERT INTO USER VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;), (42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;), (46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;), (48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 目录结构 src/main java cn/water/dao UserDao.java（持久层接口） cn/water/domain User.java（实体层） resources cn/water/dao UserDao.xml（映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 实体类User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package cn.water.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; /** 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; /** 构造方法 */ public User() &#123; &#125; public User(Integer id, String username, Date birthday, String sex, String address) &#123; this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; &#125; /** toString */ @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; /** Getter Setter */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口UserDao.java12345678910111213141516171819202122232425262728293031package cn.water.dao;import cn.water.domain.User;import java.util.List;public interface UserDao &#123; /** 添加用户 */ void add(User user); /** 更新用户 */ void update(User user); /** 删除用户 */ void delete(Integer id); /** 查询所有用户 */ List&lt;User&gt; findAll(); /** 查询单个用户 */ User findOne(Integer id); /** 根据姓名模糊查询 */ List&lt;User&gt; findByName(String name); /** 查询所有用户的数量 */ Integer findTotal();&#125; 映射配置文件UserDao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 添加用户 --&gt; &lt;!-- 参数类型 JavaBean，占位符 = 成员变量名的小写形式 --&gt; &lt;select id="add" parameterType="cn.water.domain.User" &gt; INSERT INTO user VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125; ) ; &lt;/select&gt; &lt;!-- 更新用户 --&gt; &lt;select id="update" parameterType="cn.water.domain.User"&gt; UPDATE user SET username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;, address = #&#123;address&#125; WHERE id = #&#123;id&#125; ; &lt;/select&gt; &lt;!-- 删除用户 --&gt; &lt;!-- 参数类型 基本类型，占位符 = 方法参数名称 --&gt; &lt;select id="delete" parameterType="INT" &gt; DELETE FROM user WHERE id = #&#123;id&#125;; &lt;/select&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt; &lt;!-- 查询单个用户 --&gt; &lt;select id="findOne" parameterType="INT" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; ; &lt;/select&gt; &lt;!-- 根据姓名模糊查询 --&gt; &lt;select id="findByName" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;name&#125;; &lt;/select&gt; &lt;select id="findByName" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE '% &#123;value&#125; %'; &lt;/select&gt; &lt;!-- 查询所有用户的数量 --&gt; &lt;select id="findTotal" resultType="INT" &gt; SELECT COUNT(*) FROM user; &lt;/select&gt; &lt;/mapper&gt; 测试类Test.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.QueryVo;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class UserTest &#123; /* 成员变量 */ private InputStream inputStream; private SqlSession session; private UserDao dao; /* 初始化操作 */ @Before public void init() throws IOException &#123; /* 加载 MyBatis配置文件 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 获取 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 获取 产品类 */ session = factory.openSession(); /* 获取 代理对象 */ dao = session.getMapper(UserDao.class); &#125; /* 销毁操作 */ @After public void destroy() throws IOException &#123; session.close(); inputStream.close(); &#125; /** 添加用户 */ @Test public void test01()&#123; dao.add( new User(100,"ADD",new Date(),"男","UserDao") ); session.commit(); &#125; /** 更新用户 */ @Test public void test02()&#123; dao.update( new User(100,"UPDATE",new Date(),"男","UserDao") ); session.commit(); &#125; /** 删除用户 */ @Test public void test03()&#123; dao.delete(100); session.commit(); &#125; /** 查询所有用户 */ @Test public void test04()&#123; for (User user : dao.findAll()) &#123; System.out.println(user); &#125; &#125; /** 查询单个用户 */ @Test public void test05()&#123; System.out.println( dao.findOne(41) ); &#125; /** 根据用户模糊查询 */ @Test public void test06()&#123; // LIKE #&#123;username&#125; 使用的是PreparedStatement对象 List&lt;User&gt; userList1 = dao.findByName01("%王%"); // LIKE '%$&#123;value&#125;%' 使用的是Statement对象 List&lt;User&gt; userList2 = dao.findByName02("王"); /* 输出 */ for (User user : userList1) &#123; System.out.println("1--"+user); &#125; for (User user : userList2) &#123; System.out.println("2--"+user); &#125; &#125; /** 查询所有用户的数量 */ @Test public void test07()&#123; System.out.println( dao.findTotal() ); &#125; /** 添加用户 + 返回ID */ @Test public void test08()&#123; System.out.println(dao.addReturnID(new User(100, "ADD RETURN", new Date(), "男", "UserDao"))); &#125; /** 根据QueryVo对象的条件，模糊查询 */ @Test public void test09()&#123; for(User user : dao.findByQueryVO(new QueryVo(new User(100, "ADD RETURN", new Date(), "男", "UserDao"))))&#123; System.out.println(user); &#125; &#125;&#125; 实现CRUD操作 在前一篇博客里，我们学习了自定义MyBatis框架，当时我们使用了 Proxy类 和 MapperProxy类 实现了动态代理，并调用了 selectList方法 帮我去执行具体的SQL语句。尽管这并不是完全具体的MyBatis框架底层运作方式，但以目前的知识来讲就足够了。 所以当我们使用代理持久层实现类的方式时，代理对象会帮我去调用 selectList方法；但是当我们使用手动编写持久层实现类的方式时，我们就需要自己去调用 selectList方法了。但关于这方面的事情，我不准备在下面讲，这是下一篇博客的事情了。 本篇博客在实现CRUD操作的章节，主要用于描述 持久层接口和映射配置文件。 思维导图![](3.ProxyDao CRUD操作/MyBatisCRUD操作.png) 添加用户 持久层接口 1void add(User user); 映射配置文件 123&lt;select id="add" parameterType="cn.water.domain.User" &gt; INSERT INTO user VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125; ) ;&lt;/select&gt; 更新用户 持久层接口 1void update(User user); 映射配置文件 123456789&lt;select id="update" parameterType="cn.water.domain.User"&gt; UPDATE user SET username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;, address = #&#123;address&#125; WHERE id = #&#123;id&#125; ;&lt;/select&gt; 删除用户 持久层接口 1void delete(Integer id); 映射配置文件 123&lt;select id="delete" parameterType="INT" &gt; DELETE FROM user WHERE id = #&#123;id&#125;;&lt;/select&gt; 查找所有用户 持久层接口 1User findOne(Integer id); 映射配置文件 123&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 查询单个用户 持久层接口 1List&lt;User&gt; findAll(); 映射配置文件 123 &lt;select id="findOne" parameterType="INT" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; ;&lt;/select&gt; 根据姓名模糊查询 持久层接口 12List&lt;User&gt; findByName01(String name);List&lt;User&gt; findByName02(String name); 映射配置文件 1234567&lt;select id="findByName01" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;username&#125;;&lt;/select&gt;&lt;select id="findByName02" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%';&lt;/select&gt; 查询所有用户数量 持久层接口 1Integer findTotal(); 映射配置文件 123&lt;select id="findTotal" resultType="INT" &gt; SELECT COUNT(*) FROM user;&lt;/select&gt; 添加用户返回ID 持久层接口 123456789&lt;insert id="addReturnID" parameterType="cn.water.domain.User"&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="INT" order="AFTER"&gt; SELECT last_insert_id(); &lt;/selectKey&gt; INSERT INTO usr VALUES (null,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;);&lt;/insert&gt; 映射配置文件 123for(User user : dao.findByQueryVO(new QueryVo(new User(100, "ADD RETURN", new Date(), "男", "UserDao"))))&#123; System.out.println(user);&#125; 【OGNL表达式】 Object Graphic Navigation Language：对象图导航语言 获取数据的一种表达式，在形式上省略了get Java表达式：user.getUsername(); OGNL表达式：user.username MyBatis表达式：username 其实在MyBatis的映射配置文件中，我们使用的也是OGNL表达式。只是由于我们再 parameterType属性中已经提供了实体类，所以我们可以省略实体类名直接使用属性名来获取数据。 【POJO对象】 POJO对象等同于JavaBean对象，属于实体类的一种。 我们通过User对象来传递查询条件时，查询条件的范围有限，只能是User对象中有的数据。但在实际操作中，除了需要User对象的查询条件，还会需要其他对象的查询条件，此时使用User对象来传递查询条件显然是不够的。 通过POJO对象来传递查询条件的优势正在于此，将User对象以及所需的其他对象作为成员变量封装进POJO对象，在查询时，就可以使用多个对象的查询条件。 根据Query对象的条件，模糊查询 QueryVo对象 将User对象封装进QueryVo对象中，并通过QueryVo对象来获取User对象中Username的值，用于进行模糊查询。 123456789101112131415161718192021package cn.water.domain;public class QueryVo &#123; /* 成员变量 */ private User user; /* 构造方法 */ public QueryVo(User user) &#123; this.user = user; &#125; /* Getter Setter */ public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 持久层接口 1List&lt;User&gt; findByQueryVO(QueryVo queryVo); 映射配置文件 123&lt;select id="findByQueryVo" parameterType="cn.water.domain.QueryVo" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;user.username&#125;;&lt;/select&gt; 执行过程（思维导图）![](3.ProxyDao CRUD操作/ProxyDao CRUD操作 底层.png)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Spring框架的Java数据库连接对象：JdbcTemplate]]></title>
    <url>%2F2019%2F08%2F02%2FJava%20SE%2FJdbcTemplate%2F</url>
    <content type="text"><![CDATA[Spring JDBC Spring框架对JDBC的简单封装，它提供了一个JDBCTemplate对象，简化JDBC的开发。 快速入门 导入jar包 创建JdbcTemplate对象，传递DataSource对象 JdbcTemplate template = new JdbcTemplate(dataSource); 调用JdbcTemplate的方法，完成CRUD的操作 update() queryForMap() queryForList() query() queryForObject() 方法update update()：执行DML增、删、改语句。 1234567/* 添加数据 */// SQL语句String sql = "UPDATE account SET balance = ? ";// 调用update方法int update = jdbcTemplate.update(sql, 1000);// 输出结果System.out.println("update添加:"+update); 1234567/* 修改数据 */// SQL语句 String sql = "INSERT INTO account VALUES (?,?,?),(?,?,?) ";// 调用update方法int update = jdbcTemplate.update(sql,null,"Rat",1000,null,"Ant",1000);// 输出结果ystem.out.println("update修改:"+update); 1234567/* 删除数据 */// SQL语句String sql = "DELETE FROM account WHERE name IN (?,?) ";// 调用update方法nt update = jdbcTemplate.update(sql,"Rat","Ant");// 输出结果System.out.println("update删除:"+update); queryForMap queryForMap()：查询结果，将结果集封装为Map集合。（结果集长度只能是1） 将列名作为key，将字段作为value，将一条记录封装为一个map集合。 一个Map对应着一条记录。1234567 /* 查询一条记录，封装至Map集合 */// SQL语句String sql = "SELECT * FROM account WHERE id = ?";// 调用queryForMap方法Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 1 );// 输出结果System.out.println(map); queryForList queryForList()：查询结果，将结果集封装为List集合。 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。 一个List对应着一张表。123456789/* 查询所有记录，封装至List集合 */// SQL语句String sql = "SELECT * FROM account";// 调用queryForMap方法List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql);// 输出结果for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap);&#125; query query()：查询结果，将结果集封装为JavaBean对象。 将列名作为成员变量，将字段作为成员变量的值，将一条记录封装为一个JavaBean对象。 一个JavaBean对象对应着一条记录。 query的参数：RowMapper接口 使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装。 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 传递RowMapper匿名内部类123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*基本数据类型*/ private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 123456789101112131415161718192021222324/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递RowMapper匿名内部类，手动的一条一条的获取ResultSet结果集中的数据，然后封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Record&gt;() &#123; @Override public Record mapRow(ResultSet reSet, int i) throws SQLException &#123; int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); Record record = new Record(id, ename, job_id, mgr, join_date, salary, bonus, dept_id); return record; &#125;&#125;// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; 传递BeanPropertyRowMapper实现类 注意，JavaBean对象中的成员变量类型一定要使用引用数据类型。 因为基本数据类型不能接受NULL值，而数据库中的字段可以设置为NULL值，所以在传递时，会发生类型转换的问题。 123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*引用数据类型*/ private Integer id; private String ename; private Integer job_id; private Integer mgr; private Date join_date; private Double salary; private Double bonus; private Integer dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 12345678910/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递BeanPropertyRowMapper实现类，自动获取ResultSet结果集中的数据，自动封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;&gt;(Record.class));// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; queryForObject queryForObject：查询结果，将结果集封装为对象。 用于聚合函数（查询表的记录数、列的最大数最小数平均数）123456/* 查询总记录数 */String sql = "SELECT COUNT(id) FROM emp";// 调用queryForObject方法Integer integer = jdbcTemplate.queryForObject(sql, Integer.class);// 输出结果System.out.println(integer);]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Spring JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据库连接对象的容器：JDBC连接池]]></title>
    <url>%2F2019%2F08%2F02%2FJava%20SE%2FJDBCDateSource%2F</url>
    <content type="text"><![CDATA[数据库连接池 概念 数据库连接池：其实就是一个容器，存放数据库连接的容器。 当系统初始化后，容器被创建，并且容器会申请一些连接对象。 当用户来访问数据库时，从容器中获取连接对象；用户访问完之后，会将连接对象归还给容器。 优点 节约资源 用户访问高效 接口 数据库连接池接口由Sun公司编写，具体实现类由各个数据库厂商提供。 数据库连接池接口： javax.sql.DataSource 接口方法 获取连接：getConnection() 归还连接：Connection.close()。 Connection对象是从DataSource对象中获取，此时就不再是关闭连接了，而是归还连接。 接口的实现类 C3P0：数据库连接池实现技术 Druid：数据库连接池实现技术（阿里巴巴） C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 不要忘记导入数据库驱动jar包 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 123456789101112131415161718192021222324252627282930313233&lt;!-- c3p0-config.xml文件 --&gt;&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/jdbc&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!-- initialPoolSize：初始化申请的Connection对象数量 --&gt; &lt;!-- maxPoolSize：最大的的Connection对象数量 --&gt; &lt;!-- checkoutTimeout：超时时间 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 使用自定义的配置读取连接池对象 --&gt; &lt;named-config name="otherc3p0"&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/servlet&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345678910111213141516171819202122// 打印获取的数据库连接对象 public static void main(String[] args) throws SQLException &#123;//1.导入jar包//2.定义配置文件//3.使用默认配置，获取数据库连接池对象DataSource dataSource = new ComboPooledDataSource();//3.使用自定义配置，获取数据库连接池对象// DataSource dataSource = new ComboPooledDataSource("otherc3p0");// 最大获取连接对象为10个，但我们需要获取15个。// 那就一边获取数据库连接对象，一边归还数据库连接对象。for (int i = 0; i &lt; 15; i++) &#123; //4.获取 数据库连接对象 Connection connection = dataSource.getConnection(); System.out.print(i+" "); //5.打印 数据库连接对象 System.out.println(connection); if (i &gt;= 5 &amp;&amp; i&gt;= 9 ) &#123; connection.close(); &#125;&#125;&#125; Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象12345678# druid.properties文件driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/jdbcusername=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 123456789101112131415public static void main(String[] args) throws Exception &#123;//1.导入jar包//2.定义配置文件//3.加载配置文件Properties properties = new Properties();InputStream is = C_Druid.class.getClassLoader().getResourceAsStream("druid.properties");properties.load(is);//3.获取 数据库连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource( properties );//4.获取 数据库连接对象Connection connection = dataSource.getConnection();//5.打印System.out.println(connection);&#125; 对比 C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象 JDBC工具类 我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接池对象的静态方法 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class JDBCUtils &#123;// [静态变量:数据库连接池] private static DataSource dataSource;// [静态代码块：获取数据库连接池对象]// 使用数据库连接池对象后，我们就不需要挨个获取配置文件中的数据了，因为数据库连接池对象已经帮我们获取了，所以我们只需要获取数据库连接池对象就行了。 static &#123; try &#123; //1.创建properties对象 Properties properties = new Properties(); //2.加载配置文件 properties.load( JDBCUtils.class.getClassLoader(). getResourceAsStream("druid.properties")); //3.获取 数据库连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;//[成员方法：获取Connection对象] public static Connection getConneciton() throws SQLException &#123; return dataSource.getConnection(); &#125;//[成员方法：获取DataSource对象] public static DataSource getDataSource()&#123; return dataSource; &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat,Connection conn)&#123; close(null,stat,conn); &#125; //[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(ResultSet reSet,Statement stat, Connection conn)&#123; if (reSet!=null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat!=null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>DataSource</tag>
        <tag>C3P0</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架02 —— 自定义MyBatis相关的类和接口]]></title>
    <url>%2F2019%2F08%2F02%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F2.%E5%AE%9E%E7%8E%B0MyBatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[简介 我们知道创建Maven项目后，在项目中的pom.xml配置文件中引入MyBatis依赖之后，我们就可以使用MyBatis相关的类和接口和相应的功能。 但为了对MyBatis的体系结构和功能有更加深刻的理解和全面的认识，本文Maven项目中的pom.xml配置文件将不再引入MyBatis依赖，转而通过自定义编写MyBatis相关的类和接口来实现同样的功能。 MyBatis相关类和接口的介绍流程按照 测试类 中的操作步骤为顺序，先用到的类和接口先出现。 思维导图 环境搭建Maven项目依赖 在pom.xml 文件中，并不引入MyBatis框架的依赖： mysql-connector-java（数据库连接） junit （单元测试） log4j（日志文件） dom4j（解析xml文件） jaxen（dom4j的依赖） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section02_MyPom&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 此处没有引入MyBatis的依赖 --&gt; &lt;dependencies&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jog4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j：解析xml文件 --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jaxen：dom4j的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建数据库123456789101112131415161718192021#创建数据库CREATE DATABASE mybatis;USE mybatis;#创建表CREATE TABLE USER( id INT(11) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, birthday DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, sex CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, address VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos; ) ENGINE = INNODB DEFAULT CHARSET = utf8;#插入数据INSERT INTO USER VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;), (42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;), (46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;), (48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 目录结构 src/main java cn/water/dao UserAnnoDao.java（持久层接口） UserDao.java（持久层接口） cn/water/domain User.java（实体类） cn/water/mybatis cfg Configuration.java（实体类） Mapper.java（实体类） defaults DeaultSqlSession.java（产品实现类） DeaultSqlSessionFactory.java（工厂实现类） io Resources.java（AsStream类） proxy MapperProxy.java（代理增强类） session SqlSession.java（产品接口） SqlSessionFactory.java（工厂接口） SqlSessionFactoryBuilder.java（工厂构建者） Utils DataSourceUtil.java（数据库连接对象工具类） Executor.java（数据库操作工具类） XMLConfigBuilder.java（封装信息工具类） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） pom.xml 数据库表123456789101112131415161718192021#创建数据库CREATE DATABASE eesy_mybatis;USE eesy_mybatis;#创建表CREATE TABLE USER( id INT(11) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, birthday DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, sex CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, address VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos; ) ENGINE = INNODB DEFAULT CHARSET = utf8;#插入数据INSERT INTO USER VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;), (42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;), (46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;), (48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); MyBatis主配置文件 提取 MyBatis主配置文件中映射信息的方式是读取 mapper标签的属性，所以 mappers 标签中最好只设置一种 mapper标签，resource 或是 class。 SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 数据库连接信息 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射信息 --&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt;--&gt; &lt;mapper class="cn.water.dao.UserAnnoDao"&gt;&lt;/mapper&gt; &lt;/mappers&gt; &lt;/configuration&gt; 映射配置文件UserDao.java1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt; &lt;/mapper&gt; 实体类 封装数据库表的信息 User.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.water.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口 xml UserDao.java123456789101112131415package cn.water.dao;import cn.water.domain.User;import java.util.List;public interface UserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findAll();&#125; 注解 UserAnnoDao.java1234567891011121314package cn.water.dao;import cn.water.Anno.Select;import cn.water.domain.User;import java.util.List;public interface UserAnnoDao &#123; /** 查询所有用户 */ @Select("SELECT * FROM user;") List&lt;User&gt; findAll();&#125; Mapper实体类 成员变量 结果集全类名 SQL语句 Mapper.java12345678910111213141516171819202122232425262728293031package cn.water.mybatis.cfg;public class Mapper &#123; private String queryString; private String resultType; @Override public String toString() &#123; return "Mapper&#123;" + "queryString='" + queryString + '\'' + ", resultType='" + resultType + '\'' + '&#125;'; &#125; public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; Configuration实体类 封装了 数据库连接信息+映射信息 的实体类 成员变量 数据库连接信息 drive URL username password 映射信息 Mappers String 持久层全类名 方法名 Mapper 结果集全类名 SQL语句 Configuration.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.water.mybatis.cfg;import java.util.HashMap;import java.util.Map;public class Configuration &#123; /* 数据库连接信息 */ private String driver; private String url; private String username; private String password; /* 映射信息 */ private Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); @Override public String toString() &#123; return "Configuration&#123;" + "driver='" + driver + '\'' + ", url='" + url + '\'' + ", username='" + username + '\'' + ", password='" + password + '\'' + ", mappers=" + mappers + '&#125;'; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123;// this.mappers = mappers; 覆盖：Map集合中永远只会有一个键值对 this.mappers.putAll(mappers); // 追加 &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; **MyBatisTest测试类MybatisTest.java123456789101112131415161718192021222324252627282930313233343536373839package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.User;import cn.water.mybatis.io.Resources;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;import cn.water.mybatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserDao dao = sqlSession.getMapper(UserDao.class);// UserAnnoDao dao = sqlSession.getMapper(UserAnnoDao.class); /* 使用代理对象 执行方法 */ List&lt;User&gt; list = dao.findAll(); /* 遍历 */ for (User user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; Resources 输入 “SqlMapConfig.xml”，返回 InputStream Resources.java12345678910111213141516package cn.water.mybatis.io;import java.io.InputStream;public class Resources &#123; public static InputStream getResourceAsStream(String filePath) &#123; // 1.获取类字节码文件 // 2.获取加载器对象 // 3.读取配置文件路劲 // filePath 不以’/'开头时默认是从此类所在的包下取资源 // filePath 以’/'开头则是从ClassPath根下获取 return Resources.class.getClassLoader().getResourceAsStream(filePath); &#125;&#125; SqlSessionFactoryBuilder工厂构建者 返回 DefaultSqlSessionFactory工厂实现类 SqlSessionFactoryBuilder.java12345678910111213141516171819package cn.water.mybatis.session;import cn.water.mybatis.Utils.XMLConfigBuilder;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.defaults.DefaultSqlSessionFactory;import java.io.InputStream;public class SqlSessionFactoryBuilder &#123; /** 根据MyBatis配置文件路径的字节输入流，返回工厂实现类 */ public SqlSessionFactory build(InputStream config) &#123; /* 读取MyBatis配置文件，将数据封装进实体类 */ Configuration configuration = XMLConfigBuilder.loadConfiguration(config); /* 返回值 */ return new DefaultSqlSessionFactory(configuration); &#125;&#125; XMLConfigBuilder工具类 工具类直接使用即可！ 用于解析MyBatis主配置文件、xml映射配置文件、存在注释的持久层接口，并将数据封装至 Configuration实体类中。 XMLConfigBuilder.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package cn.water.mybatis.Utils;import cn.water.Anno.Select;import cn.water.mybatis.io.Resources;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.cfg.Mapper;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;public class XMLConfigBuilder &#123; /** 解析MyBatis主配置文件 */ public static Configuration loadConfiguration(InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是XML"); //表示有resource属性，用的是XML //取出属性的值 String mapperPath = attribute.getValue();//获取属性的值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据daoClassPath获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 String namespace = root.attributeValue("namespace");//是组成map中key的部分 //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历select节点集合 for(Element selectElement : selectElements)&#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue("id"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace+"."+id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * @param daoClassPath 持久层接口的位置 * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给map赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; SqlSessionFactory工厂接口 生产 DefaultSqlSession对象，为了降低耦合度。 SqlSessionFactory.java12345678package cn.water.mybatis.session;public interface SqlSessionFactory &#123; /** 生产 操作数据库对象 */ public abstract SqlSession openSession();&#125; DefaultSqlSessionFactory工厂实现类DefaultSqlSessionFactory.java123456789101112131415161718192021222324package cn.water.mybatis.defaults;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; /** 成员变量 */ /* 数据库连接信息 + 映射信息 */ private Configuration configuration; /** 带参构造 */ public DefaultSqlSessionFactory(Configuration configuration) &#123; this.configuration = configuration; &#125; /** 生产 操作数据库对象 */ public SqlSession openSession() &#123; return new DefaultSqlSession(configuration); &#125;&#125; SqlSession产品接口 生产 持久层接口的代理对象 SqlSession.java1234567891011package cn.water.mybatis.session;public interface SqlSession &#123; /** 根据参数，创建代理对象 */ /* &lt;T&gt; T 返回值为泛型时，需要先声明再使用。 */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface); /** 释放资源 */ void close();&#125; DefaultSqlSession产品实现类DefaultSqlSession.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.water.mybatis.defaults;import cn.water.mybatis.Utils.DataSourceUtil;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.proxy.MapperProxy;import cn.water.mybatis.session.SqlSession;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.SQLException;public class DefaultSqlSession implements SqlSession &#123; /** 成员变量 */ /* 数据库连接信息 + 映射信息 */ private Configuration configuration; /* 数据库连接对象 */ private Connection connection; /** 带参构造 */ /* 初始化 configuration 和 connection */ public DefaultSqlSession(Configuration configuration) &#123; this.configuration = configuration; connection = DataSourceUtil.getConnection(configuration); &#125; /** 创建代理对象 */ public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface) &#123; return (T) Proxy.newProxyInstance( daoInterface.getClassLoader(), // 持久层接口的类加载器 new Class[]&#123;daoInterface&#125;, // 持久层接口 new MapperProxy(configuration.getMappers(), connection)); &#125; /** 释放资源 */ public void close() &#123; if (connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; DataSourceUtils工具类 创建 Connection对象 DataSourceUtils.java1234567891011121314151617181920212223package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Configuration;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DataSourceUtil &#123; /** 根据实体类中的连接数据库信息，创建数据库连接对象 */ public static Connection getConnection(Configuration configuration) &#123; try &#123; /* 加载 数据库驱动 */ Class.forName(configuration.getDriver()); /* 返回值 */ return DriverManager.getConnection(configuration.getUrl(),configuration.getUsername(),configuration.getUsername()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; MapperProxy代理增强类 用于对代理类方法进行代码增强 MapperProxy.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.water.mybatis.proxy;import cn.water.mybatis.Utils.Executor;import cn.water.mybatis.cfg.Mapper;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Map;public class MapperProxy implements InvocationHandler &#123; /** * 私有成员变量 * key：全类名+方法名 * value：SQL语句+结果集数据类型的全类名 */ private Map&lt;String, Mapper&gt; mappers; private Connection connection; /** 带参构造 */ public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection connection) &#123; this.mappers = mappers; this.connection = connection; &#125; /** 代码增强 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1.获取方法名 String methodName = method.getName(); // 2.获取方法所在类的名称 String className = method.getDeclaringClass().getName(); // 3.组合key String key = className + "." + methodName; // 4.获取mappers中的Mapper对象 Mapper mapper = mappers.get(key); // 5.判断是否有Mapper if (mapper==null)&#123; throw new IllegalArgumentException("传入的参数有误！"); &#125; // 6.调用工具类执行查询所有 return new Executor().selectList(mapper,connection); &#125;&#125; Executor工具类 执行SQL语句，并且封装结果集 Executor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Mapper;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;public class Executor &#123; /** 执行，封装 */ public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125; &#125; /** 释放资源 */ private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 执行结果 执行不同的测试类记得更换 MyBatis配置文件中的 mapper标签 和 测试类中代理对象的接口字节码。 xml1234567使用的是XMLUser&#123;id=41, username=&apos;老王&apos;, birthday=2018-02-27 17:47:08.0, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=42, username=&apos;小二王&apos;, birthday=2018-03-02 15:09:37.0, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=43, username=&apos;小二王&apos;, birthday=2018-03-04 11:34:34.0, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=45, username=&apos;传智播客&apos;, birthday=2018-03-04 12:04:06.0, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=46, username=&apos;老王&apos;, birthday=2018-03-07 17:37:26.0, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=2018-03-08 11:44:00.0, sex=&apos;女&apos;, address=&apos;北京修正&apos;&#125; 注解1234567使用的是注解User&#123;id=41, username=&apos;老王&apos;, birthday=2018-02-27 17:47:08.0, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=42, username=&apos;小二王&apos;, birthday=2018-03-02 15:09:37.0, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=43, username=&apos;小二王&apos;, birthday=2018-03-04 11:34:34.0, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=45, username=&apos;传智播客&apos;, birthday=2018-03-04 12:04:06.0, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=46, username=&apos;老王&apos;, birthday=2018-03-07 17:37:26.0, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=2018-03-08 11:44:00.0, sex=&apos;女&apos;, address=&apos;北京修正&apos;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的数据库连接接口：JDBC]]></title>
    <url>%2F2019%2F08%2F01%2FJava%20SE%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC简介 概念 Java DataBase Connectivity，Java 数据库连接。 JDBC是sun公司定义的一套操作所有关系型数据库的规则，即接口。 各个数据库厂商去编写这套接口的实现类，包装成数据库驱动jar包。通过导入不同数据库厂商编写的数据库驱动jar包，来对JBDC接口进行实现。 快速入门 导入MySQL数据库驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制到项目的libs目录下 右键 –&gt; Add As Library 注册驱动 driver “com.mysql.jdbc.Driver” 获取数据库连接对象 Connection 第一个参数：URL（jdbc:mysql://连接IP地址:端口号/数据库名） 第二个参数：数据库账号 第三个参数：数据库密码 定义SQL语句 获取执行SQL语句的对象 Statement 执行SQL语句，接受返回结果 处理结果 释放资源 123456789101112# 创建数据库CREATE DATABASE jdbc;# 使用数据库USE jdbc;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT , NAME VARCHAR(20), balance INT);# 插入数据INSERT INTO account VALUES(1,&apos;Cat&apos;,1000),(2,&apos;Dog&apos;,1000); 12345678910111213141516//1.导入驱动jar包//2.注册驱动Class.forName("com.mysql.jdbc.Driver");//3.获取数据库连接对象ConnectionConnection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc", "root", "root");//4.定义SQL语句String s = "UPDATE account SET balance = 1500 WHERE id =1";//5.获取执行SQL的对象StatementStatement statement = connection.createStatement();//6.执行SQLint count = statement.executeUpdate(s);//7.处理结果System.out.println(count);//8.释放资源statement.close();connection.close(); 详解对象DriverManager DriverManager驱动管理对象：用于管理一组JDBC驱动程序的基本服务。 新增的DataSource接口提供了另一种连接到数据源的方法。 使用DataSource对象是连接到数据源的首选方法。 注册驱动 注册驱动：其实就是一个指定数据库驱动jar包的过程。 我们在快速入门的时候，使用的注册驱动方式是加载文件： 加载MySQL数据库驱动jar包中的com.mysql.jdbc.Driver类 Class.forName(“com.mysql.jdbc.Driver”); 那么为什么加载com.mysql.jdbc.Driver类就能够注册驱动呢？我们来探究一下。 其实真正注册驱动调用的是DriverManager类中的registerDriver静态方法 注册与给定的驱动程序 DriverManager ：static void registerDriver(Driver driver) 而由于com.mysql.jdbc.Driver类在其静态代码块调用了registerDriver静态方法，所以当我们去加载这个类时，它会帮我们自动的注册驱动，简便了我们的操作。 MySQL5之后的驱动jar包可以省略注册驱动的步骤，因为它自动加载了com.mysql.jdbc.Driver类。12345678/* com.mysql.jdbc.Driver类中的静态代码块 */static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; 获取数据库连接 static Connection getConnection(String url, String user, String password) url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/db3 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection Connection数据库连接对象：与特定数据库的连接。 获取执行SQL语句的对象 Statement createStatement() ：创建一个 Statement对象，用于将SQL语句发送到数据库。 PreparedStatement prepareStatement(String sql) ：创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 管理事务 void setAutoCommit(boolean autoCommit) ：（开启事务）将此连接的自动提交模式设置为给定状态。 true（自动提交） false（手动提交，开启事务） void commit() ：（提交事务）使自上次提交/回滚以来所做的所有更改都将永久性，并释放此 Connection对象当前持有的任何数据库锁。 void rollback() ：（回滚事务）撤消在当前事务中所做的所有更改，并释放此 Connection对象当前持有的任何数据库锁。 Statement Statement执行静态SQL语句的对象：用于执行静态SQL语句并返回其生成的结果的对象。 执行sql boolean execute(String sql) ：可以执行任意的SQL语句 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数 通过影响的行数可以判断语句是否执行成功。返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 练习：增删改添加记录注意：添加记录调用的是executeUpdate方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123;Connection conn = null;Statement stat = null;try &#123; //1.注册驱动 抓取异常 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "INSERT INTO account VALUES (NULL,'Rat',2000);"; //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 Statement stat = conn.createStatement(); //5.执行SQL语句 int i = stat.executeUpdate(s); //6.处理结果 if (i&gt;0) &#123; System.out.println("操作成功"); &#125;else &#123; System.out.println("操作失败"); &#125;&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; finally &#123;//7.释放资源/* 因为Statement和Connection已经在trycatch语句外声明了一个NULL值由于trycatch语句的特性，可能会造成在执行新的赋值语句之前就被中断了运行，所以Statement和Connection可能会是空值。于是这里需要采用if语句来避免空指针异常 */ if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 修改记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：修改记录执行SQL语句的是executeUpdate方法 123// .....String s = "UPDATE account SET balance =1000 WHERE name = 'rat'";// ..... 删除记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：删除记录执行SQL语句的是executeUpdate方法 123// .....String s = "DELETE FROM account WHERE name = 'rat'";// ..... ResultSet ResultSet结果集对象：表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。 封装查询结果 boolean next():：游标向下移动一行，并判断当前行是否是最后一行的末尾(是否有数据)。 如果是最后一行的末尾，则返回false；如果不是，则返回true。 getTYPE(参数)：获取数据 TYPE：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号，从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 练习：查询查询记录除了SQL语句、执行SQL语句和处理结果不一样，所有的代码都跟添加记录的练习一模一样。另外，你要在trycatch语句外声明一个ResultSet对象为NULL，并在finally语句中释放ResultSet资源。注意：查询记录执行SQL语句的是executeQuery方法 123456789101112131415161718192021// .....//2.定义SQL语句String s = "SELECT * FROM account";//3.获取数据库连接对象conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root");//4.获取执行SQL的对象 statementstat = conn.createStatement();//5.执行SQL，获取结果集reSet = stat.executeQuery(s);//6.处理结果// 1.让游标向下移动一行// 2.并判断是否是最后一行 while (reSet.next()) &#123;// 3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble("balance");// 4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125;// .... 查询记录（实体类）代码 查询数据库中emp表的数据，并将其封装为Employee对象，然后将其封装进List集合。 123456789101112131415161718192021222324252627282930# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号);-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),(1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10); 1234567891011121314151617181920212223242526272829303132333435363738394041// 实体类public class Employee &#123; // 成员变量（根据数据库的列来设置） private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; // 无参构造 public Employee() &#123; &#125; // 带参构造（按照数据库表中列的顺序） public Employee(int id, String ename, int job_id, int mgr, Date join_date, double salary, double bonus, int dept_id) &#123; this.id = id; this.ename = ename; this.job_id = job_id; this.mgr = mgr; this.join_date = join_date; this.salary = salary; this.bonus = bonus; this.dept_id = dept_id; &#125; // toString方法 @Override public String toString() &#123; return "Employee&#123;" + "id=" + id + ", ename='" + ename + '\'' + ", job_id=" + job_id + ", mgr=" + mgr + ", join_date=" + join_date + ", salary=" + salary + ", bonus=" + bonus + ", dept_id=" + dept_id + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 测试类// mian方法public static void main(String[] args) &#123; //调用方法，接收list集合 List&lt;Employee&gt; emps = returnTable(); //遍历list集合 for (Employee record : emps) &#123; System.out.println(record); &#125;&#125;// 成员方法（返回查询结果）public static List&lt;Employee&gt; returnTable()&#123;Connection conn = null;Statement stat = null;ResultSet reSet = null;List&lt;Employee&gt; tableList = new ArrayList&lt;&gt;();try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "SELECT * FROM emp"; //3.获取数据库连接对象 conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //6.1 让游标向下移动一行 //6.2 并判断是否是最后一行 while (reSet.next()) &#123; //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); //6.4 创建 Employee对象Employee emp = new Employee(id,ename,job_id,mgr,join_date,salary,bonus,dept_id); //6.5 将Employee对象添加进List集合 tableList.add(emp); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 /* 避免空指针异常，使用if语句判断 */ if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //8. 返回List集合 return tableList;&#125; 比较将数据库、实体类和测试类进行比较。 12345678910111213# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号); 1234567891011// 实体类 // 成员变量 private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; 12345678910// 测试类 //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); PreparedStatement PreparedStatement执行动态SQL语句的对象：表示预编译（动态）的SQL语句的对象。 SQL注入问题 指在拼接SQL时，有一些特殊的SQL关键字参与，从而造成了安全性问题。 用户输入前 12// Java语句String sql = "SELECT * FROM user WHERE username = '"+username+"' AND password = '"+password+"';"; 用户输入后， 账户：随便，密码：a’ or ‘a’=’a 1234# SQL语句SELECT * FROM JDBC_user WHERE username = &apos;随便&apos; AND password =&apos;a&apos; OR &apos;a&apos;=&apos;a&apos;;# 语句永远成立，轻松登录成功。 解决SQL注入问题 使用PreparedStatement对象来解决SQL注入问题。 预编译（动态）的SQL：参数使用?作为占位符 使用步骤： 导入驱动jar包 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 传递SQL语句，获取执行动态SQL语句的对象 PreparedStatement 给？占位符赋值： 方法： setXxx(参数1,参数2) 参数1：？占位符的位置编号，从1 开始 参数2：？占位符的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 登录案例 需求 用户通过键盘录入用户名和密码； 查询数据库后，判断用户是否登录成功。 使用静态SQL12345678# 创建表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(30), PASSWORD VARCHAR(30));# 插入数据INSERT INTO USER VALUES(1,&apos;cat&apos;,111),(2,&apos;dog&apos;,222); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// [main方法]public static void main(String[] args) &#123;//用户输入Scanner scanner = new Scanner(System.in);System.out.println("请输入账户：");String username = scanner.next();System.out.println("请输入密码：");String password = scanner.next();//调用login方法boolean flg = login(username, password);//输入if (flg)&#123; System.out.println("登录成功");&#125;else &#123; System.out.println("登录失败");&#125;&#125;//[login方法]public static boolean login(String username, String password) &#123; //防止输入空值 if (username == null) &#123; return false; &#125; if (password == null) &#123; return false; &#125; //声明变量 Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM JDBC_user WHERE username = '"+username+"' AND password = '"+password+"'"; //获取Statement对象 statement = connection.createStatement(); //执行SQL语句，并获取ResultSet对象 resultSet = statement.executeQuery(sql); //返回 return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //返回 return false; &#125; 使用动态SQL1234567891011121314151617// ..... try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM user WHERE username = ? AND password = ? "; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql); //通过PreparedStatement类的set方法，给？占位符赋值 preparedStatement.setString(1,username); preparedStatement.setString(2,password); //通过PreparedStatement类的executeQuery方法，并获取ResultSet对象 resultSet = preparedStatement.executeQuery();//不需要传参 //返回 return resultSet.next();&#125; catch (SQLException e) &#123;// ..... JDBC工具类 经过几个JDBC的案例之后，我们不难发现JDBC的编写中存在大量复杂的相同的代码，为了简化书写，我们引入了JDBC工具类：JDBCUtils。 但仅仅使用JDBC工具类，仍然不能使得获取数据库连接对象的代码变得简洁，而我们每次在获取数据库连接对象时，输入的三个参数是很少会变化的。于是，为了更加简化书写，我们引入了JDBC配置文件：jdbc.properties。 为了达到最终的目的，我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//J DBC工具类：JDBCUtilspublic class JDBCUtils &#123;// [静态变量] private static String url; private static String user; private static String password; private static String driver; // [静态代码块：读取配置文件的数据] static &#123; try &#123;// 1.创建properties对象 Properties properties = new Properties();// 1.1 获取 字节码文件 Class jdbcClass = JDBCUtils.class;// 1.2 获取 类加载器 ClassLoader classLoader = jdbcClass.getClassLoader();// 1.3 获取 统一资源定位符 URL resource = classLoader.getResource("jdbc.properties");// 1.4 获取 路径 String path = resource.getPath();// 2.加载配置文件 properties.load(new FileReader(path));// 3.获取数据 url = properties.getProperty("url"); user = properties.getProperty("user"); password = properties.getProperty("password"); driver = properties.getProperty("driver");// 4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //[成员方法：获取Connection对象] public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat, Connection conn) &#123; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;//[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(Statement stat, Connection conn, ResultSet reSet) &#123; if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345# properties提示配置文件url = jdbc:mysql:///jdbcuser = rootpassword = rootdriver = com.mysql.jdbc.Driver 查询练习123456789101112131415161718192021222324252627282930313233// 使用JDBC工具类public static void main(String[] args) &#123; Connection conn = null; Statement stat = null; ResultSet reSet = null; try &#123; //1.注册驱动 //2.获取数据库连接对象 conn = JDBCUtils.getConnection(); //3.定义SQL语句 String s = "SELECT * FROM account"; //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //1.让游标向下移动一行 //2.并判断是否是最后一行 while (reSet.next()) &#123; //3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble(3); //4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 JDBCUtils.close(stat,conn,reSet); &#125;&#125; JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 JDBC使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) （false为开启事务） 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 我在代码中写入了一句异常 ，当程序运行到异常时，异常后的提交事务不会进行，程序运行catch语句，进行事务回滚，账户会回滚到之前的状态。当然，如果去除异常，交易会正常进行，账户会发生变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null;try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //【开启事务】 connection.setAutoCommit(false); //定义SQL语句 [Cat -500]*** String sql1 = "UPDATE account SET balance = balance - ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql1); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,1); //执行SQL语句 int i = preparedStatement.executeUpdate();System.out.println(i); //定义SQL语句 [Dog +500]*** String sql2 = "UPDATE account SET balance = balance + ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql2); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,2); //执行SQL语句 i = preparedStatement.executeUpdate(); System.out.println(i); // ***异常*** int iii = 3/0; //【提交事务】 connection.commit();&#125; catch (Exception e) &#123; //【事务回滚】 try &#123; if (connection!= null) &#123; connection.rollback(); &#125; &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace();&#125; finally &#123;// 释放资源JDBCUtils.close(preparedStatement,connection);&#125;&#125;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架01 —— 入门案例]]></title>
    <url>%2F2019%2F08%2F01%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F1.MyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[内容简介 本文是对MyBatis的基础操作方式进行的演示，包括MyBatis环境搭建，以及一些细节知识点。 我们会发现其实各种操作方式的步骤大同小异，因为究其根源它们实现的都是相同的功能。 为了让大家能更好的理解，我们来试着分析一下MyBatis究竟帮我们实现了什么样的功能。 连接MySQL数据库的功能 连接持久层接口的功能 通过映射配置文件的方式 通过注解的方式 实现持久层接口的功能 创建持久层接口实现类 使用代理的持久层接口实现类 思维导图 搭建环境创建Maven工程 GroupID 项目组织唯一的标识符 实际对应Java的包的结构，main/Java目录下的目录结构。 GroupID分为多段，第一段为域，第二段为公司名称等。 域：org（非盈利组织）、com（商业公司）、cn（中国组织） ArtifactID 项目的唯一的标识符 实际对应项目的名称，项目根目录的名称。 举例：Apache公司的Tomcat项目GroupID：org.apacheArtigactID：tomcat 添加MyBatis坐标 Maven坐标 Maven拥有数量非常巨大的构件（jar/war），而任何一个构件都可以使用Maven坐标来获取。maven坐标的元素包括groupId，artifactId，version，package，classifier。 引入依赖 一旦我们在pom.xml文件中配置好 dependancy标签 中的 groupId标签，artifact标签，verison标签 和classifier标签，maven就会从仓库中寻找相应的构件供我们使用。 在pom.xml 文件中，引入4个依赖： mybatis（MyBatis框架） mysql-connector-java（数据库连接） junit （单元测试） log4j（日志文件） 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建数据库123456789101112131415161718192021#创建数据库CREATE DATABASE mybatis;USE mybatis;#创建表CREATE TABLE USER( id INT(11) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, birthday DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, sex CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, address VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos; ) ENGINE = INNODB DEFAULT CHARSET = utf8;#插入数据INSERT INTO USER VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;), (42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;), (45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;), (46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;), (48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 方法一：映射配置文件目录结构 src/main java cn/water/dao UserDao.java（持久层接口） cn/water/domain User.java（实体类） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test UserTest.java（测试文件） 实体类 实体类要实现Serializable接口，因为在封装MySQL数据库数据时，运用了代理对象。 实体类中的成员变量和MySQL数据库中的列属性保持一致。 User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.water.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口 编写一个操作数据库的抽象方法，但是具体的SQL语句会由持久层接口的映射文件来编写。 UserDao.java1234567891011121314package cn.water.dao;import cn.water.domain.User;import java.util.List;public interface UserDao &#123; /** 查询所有用户 */ public abstract List&lt;User&gt; findAll();&#125;` 映射配置文件 映射配置文件：专注于编写SQL语法，一个持久层接口对应一个映射配置文件。 创建位置：映射配置文件必须和持久层接口在相同的包中。 持久层接口：src/main/java/cn/water/dao/ 映射配置文件：src/main/resources/cn/water/dao/ 名称：映射配置文件必须以持久层接口名称命名文件名，扩展名是.xml。 持久层接口：UserDao.java 映射配置文件：UserDao.xml UserDao.xml 语法 mapper namespace：持久层接口的全类名 select id：方法名称 resultType：返回值类型 SQL语句 含义 findAll方法的位置：cn.water.do.UserDao findAll方法的SQL语句：SELECT * FROM user; findAll方法的返回值类型：cn.water.domain.User 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!-- 配置映射 --&gt; &lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt; &lt;/mapper&gt;&lt;/mapper&gt; MyBatis主配置文件 MyBatis主配置文件：专注于连接数据库，一个映射配置文件对应一个mapper标签。 SqlMapConfig.xml configuration environments default=”mysql” ：环境 environment id=”mysql” ：MySQL环境 transactionManager type=”JDBC” ：事务类型 dataSource type=”POOLED” ：数据库连接池 property name=”” value=”” ：连接数据库的4个基本信息 mappers mapper resource=”” ：指定映射配置文件的项目路径 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 测试类 加载 MyBatis主配置文件（Resources.getResourceAsStream），获取IO流（InputStream） 通过 工厂建造者类（SqlSessionFactoryBuilder），创建 工厂类**（build()） 通过 工厂类（SqlSessionFactory），生产 SqlSession对象（openSession()） 通过 Session对象（SqlSession），创建 持久层接口的代理对象（getMapper(UserDao.class)） 通过 代理对象，执行方法 释放资源（SqlSession）（InputStream） UserTest.java1234567891011121314151617181920212223242526272829303132333435363738package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取 MyBatis主配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 工厂建造者类，创建 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂类，生产 SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 通过 SqlSession对象，创建 持久层接口的代理对象 */ UserDao userDao = sqlSession.getMapper(UserDao.class); /* 通过 代理对象，执行方法 */ List&lt;User&gt; all = userDao.findAll(); /* 遍历 */ for (User user : all) &#123; System.out.println(user); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果123456User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=42, username=&apos;小二王&apos;, birthday=Fri Mar 02 15:09:37 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=43, username=&apos;小二王&apos;, birthday=Sun Mar 04 11:34:34 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=46, username=&apos;老王&apos;, birthday=Wed Mar 07 17:37:26 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=Thu Mar 08 11:44:00 CST 2018, sex=&apos;女&apos;, address=&apos;北京修正&apos;&#125; 设计模式构建者模式 定义： 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 举例 计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将不同计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 123InputeStream in = Resources.getResourceAsStream("SqlMapConfig.xml");SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder;SqlSessionFactory factory = builder.build(in); 工厂模式 定义 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。 举例 各种产品有专门的工厂生产。在苹果工厂，我们可以拿到iPhone、iPad和macbook；在华为工厂，我们可以拿到p30，mate20，Matebook。我们不关心产品是如何做的，甚至可以不关心产品的名字（拿到工厂你就拿到了产品）。 优点 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 区别 建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 1SqlSession sqlSession = factory.openSession(); 代理模式 定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 举例 购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 1List&lt;User&gt; list = dao.findAll(); 方法二：注解 注解可以代替映射配置文件。 目录结构 src/main java cn/water/dao AnnoUserDao.java（持久层接口） cn/water/domain AnnoUser.java（持久层） resources SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test AnnoUserTest.java（测试文件） 实体类AnnoUser.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.water.domain;import java.io.Serializable;import java.util.Date;public class AnnoUser implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口（注解） 在持久层接口的抽象方法上添加 @Select注解，并编写SQL语句 AnnoUserDao.java12345678910111213141516package cn.water.dao;import cn.water.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AnnoUserDao &#123; /** 查询所有用户 */ @Select("SELECT * FORM user;") public abstract List&lt;User&gt; findAll();&#125;` 映射配置文件（删除）MyBatis主配置文件（映射） environments 标签中的内容用于连接MySQL数据库无需更改。 在 mappers 标签中添加映射 方法一：使用class属性，指定被注解的持久层接口的全类名。 方法二：使用package标签，指定被注解的持久层接口的包。 SqlMapConfig.xml123&lt;mappers&gt; &lt;mapper class="cn.water.dao.AnnoUserDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 123&lt;mappers&gt; &lt;package name="cn.water.dao"/&gt;&lt;/mappers&gt; 测试类AnnoUserTest.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.test;import cn.water.dao.AnnoUserDao;import cn.water.dao.UserDao;import cn.water.domain.AnnoUser;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class AnnoUserTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取 MyBatis主配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 工厂建造者类，创建 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂类，生产 SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 通过 SqlSession对象，创建 持久层接口的代理对象 */ AnnoUserDao annoUserDao = sqlSession.getMapper(AnnoUserDao.class); /* 通过 代理对象，执行方法 */ List&lt;AnnoUser&gt; all = annoUserDao.findAll(); /* 遍历 */ for (AnnoUser user : all) &#123; System.out.println(user); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果123456User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=42, username=&apos;小二王&apos;, birthday=Fri Mar 02 15:09:37 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=43, username=&apos;小二王&apos;, birthday=Sun Mar 04 11:34:34 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=46, username=&apos;老王&apos;, birthday=Wed Mar 07 17:37:26 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=Thu Mar 08 11:44:00 CST 2018, sex=&apos;女&apos;, address=&apos;北京修正&apos;&#125; 方法三：创建持久层接口实现类目录结构 src/main java cn/water/dao ImpUserDao.java（持久层接口） ImpUserDaoImp.java（持久层接口的实现类） cn/water/domain ImpUser.java（持久层） resources cn/water/dao ImpUserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test ImpUserTest.java（测试文件） 实体类ImpUser.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.water.domain;import java.io.Serializable;import java.util.Date;public class ImpUser implements Serializable &#123; /* 成员变量 */ private Integer id; private String username; private Date birthday; private String sex; private String address; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 持久层接口ImpUserDao.java1234567891011121314package cn.water.dao;import cn.water.domain.ImpUser;import cn.water.domain.User;import java.util.List;public interface ImpUserDao &#123; /** 查询所有用户 */ public abstract List&lt;ImpUser&gt; findAll();&#125;` 持久层接口实现类（新增） ImpUserDaoImp.java 1234567891011121314151617181920212223242526272829303132333435363738package cn.water.dao.imp;import cn.water.dao.ImpUserDao;import cn.water.domain.ImpUser;import cn.water.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class ImpUserDaoImp implements ImpUserDao &#123; /* 成员变量：工厂类 */ private SqlSessionFactory factory; /* 构造方法（工厂类） */ public ImpUserDaoImp(SqlSessionFactory factory) &#123; this.factory = factory; &#125; /* 实现的接口的方法 */ public List&lt;ImpUser&gt; findAll() &#123; /* Session对象 */ SqlSession sqlSession = factory.openSession(); /* 获取代理对象 */ ImpUserDao impUserDao = sqlSession.getMapper(ImpUserDao.class); /* 使用SqlSession对象 执行查询所有方法 */ /* 参数Statement：映射配置文件的namespace属性值+id属性值 */ List&lt;ImpUser&gt; list = sqlSession.selectList("cn.water.dao.ImpUserDao.findAll"); /* 释放资源 */ sqlSession.close(); /* 返回 */ return list; &#125;&#125;` 映射配置文件（修改）ImpUserDao.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!-- 配置映射 --&gt; &lt;mapper namespace="cn.water.dao.ImpUserDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.ImpUser"&gt; SELECT * FROM user; &lt;/select&gt; &lt;/mapper&gt; MyBatis主配置文件（映射）SqlMapConfig.xml123&lt;mappers&gt; &lt;mapper resource="cn/water/dao/ImpUserDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类（更改）ImpUserTest.java123456789101112131415161718192021222324252627282930313233343536package cn.water.test;import cn.water.dao.ImpUserDao;import cn.water.dao.UserDao;import cn.water.dao.imp.ImpUserDaoImp;import cn.water.domain.ImpUser;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class ImpUserTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取 MyBatis主配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 工厂建造者类，创建 工厂类 */ SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); /* --创建 持久层接口实现类，传递 工厂类-- */ ImpUserDao impUserDao = new ImpUserDaoImp(factory); /* --执行 持久层实现类的方法-- */ List&lt;ImpUser&gt; all = impUserDao.findAll(); /* 遍历 */ for (ImpUser user : all) &#123; System.out.println(user); &#125; /* 释放资源 */ inputStream.close(); &#125;&#125; 运行结果123456User&#123;id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=42, username=&apos;小二王&apos;, birthday=Fri Mar 02 15:09:37 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=43, username=&apos;小二王&apos;, birthday=Sun Mar 04 11:34:34 CST 2018, sex=&apos;女&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;&#125;User&#123;id=46, username=&apos;老王&apos;, birthday=Wed Mar 07 17:37:26 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;User&#123;id=48, username=&apos;小马宝莉&apos;, birthday=Thu Mar 08 11:44:00 CST 2018, sex=&apos;女&apos;, address=&apos;北京修正&apos;&#125; 区别SQL语句映射配置文件 持久层接口 1List&lt;UserAnno&gt; findAll(); 映射配置文件 123456&lt;!-- 配置映射 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; 持久层接口实现类 持久层接口 1List&lt;UserAnno&gt; findAll(); 映射配置文件 123456&lt;!-- 配置映射 --&gt;&lt;mapper namespace="cn.water.dao.ImpUserDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.ImpUser"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; 注解 持久层接口 12@Select("SELECT * FROM user;")List&lt;UserAnno&gt; findAll(); mappers标签 MyBatis主配置文件 123456789101112131415&lt;mappers&gt; &lt;!-- 映射配置文件：使用resource属性，指定映射配置文件的项目路径。 --&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;!-- 持久层实现类：使用resource属性，指定映射配置文件的项目路径。 --&gt; &lt;mapper resource="cn/water/dao/ImpUserDao.xml"&gt;&lt;/mapper&gt; &lt;!-- 注解：使用class属性，指定被注解的持久层接口的全类名。 --&gt; &lt;mapper class="cn.water.dao.AnnoUserDao"&gt;&lt;/mapper&gt; &lt;!-- 注解：使用package标签，指定被注解的持久层接口的包。 --&gt; &lt;package name="cn.water.dao"/&gt; &lt;/mappers&gt; 执行映射配置文件 测试类 123456789101112131415161718/* 1.读取 MyBatis主配置文件 */InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");/* 2.通过 工厂建造者类，创建 工厂类 */SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);/* 3.通过 工厂类，生产 SqlSession对象 */SqlSession sqlSession = factory.openSession();/* 4.通过 SqlSession对象，创建 持久层接口的代理对象 */UserDao userDao = sqlSession.getMapper(UserDao.class);/* 5.通过 代理对象，执行方法 */List&lt;User&gt; all = userDao.findAll();/* 6.遍历 */for (User user : all) &#123; System.out.println(user);&#125;/* 7.释放资源 */sqlSession.close();inputStream.close(); 持久层接口实现类 持久层接口实现类 12345678/* 4.Session对象 */SqlSession sqlSession = factory.openSession();/* 5.获取代理对象 */ImpUserDao impUserDao = sqlSession.getMapper(ImpUserDao.class);/* 6.调用方法 */List&lt;ImpUser&gt; users = impUserDao.findAll();/* 7.释放资源 */sqlSession.close(); 测试类 12345678910111213141516/* 1.读取 MyBatis主配置文件 */InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");/* 2.通过 工厂建造者类，创建 工厂类 */SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);/* 3.创建 持久层接口实现类，传递 工厂类 */ImpUserDao impUserDao = new ImpUserDaoImp(factory);/* 8.执行 持久层实现类的方法 */List&lt;ImpUser&gt; all = impUserDao.findAll();/* 9.遍历 */for (ImpUser user : all) &#123; System.out.println(user);&#125;/* 10.释放资源 */inputStream.close(); 注解123456789101112131415161718/* 1.读取 MyBatis主配置文件 */InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");/* 2.通过 工厂建造者类，创建 工厂类 */SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);/* 3.通过 工厂类，生产 SqlSession对象 */SqlSession sqlSession = factory.openSession();/* 4.通过 SqlSession对象，创建 持久层接口的代理对象 */AnnoUserDao annoUserDao = sqlSession.getMapper(AnnoUserDao.class);/* 5.通过 代理对象，执行方法 */List&lt;AnnoUser&gt; all = annoUserDao.findAll();/* 6.遍历 */for (AnnoUser user : all) &#123; System.out.println(user);&#125;/* 7.释放资源 */sqlSession.close();inputStream.close(); 报错错误一：IllegalArgumentException错误代码1Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.water.dao.UserImpDao 错误原因一：SqlSession调用selectList方法的参数错误123456&lt;!-- 持久层接口的映射配置文件 --&gt;&lt;mapper namespace="cn.water.dao.UserImpDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.UserImp"&gt; SELECT * FROM user; &lt;/select&gt; 12345678910111213/* 持久层接口的实现类*/public class UserImpDaoImpl implements UserImpDao &#123; public List&lt;UserImp&gt; findAll() &#123; /* 错误参数：持久层接口的映射配置文件的namespace属性值 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao"); /* 正确参数：持久层接口的映射配置文件的namespace属性值+id属性 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll"); &#125;&#125; 错误原因二：MyBatis主配置文件中没有设置mapper标签1234&lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置。 --&gt;&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserImpDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架05 —— CRUD操作的源码分析]]></title>
    <url>%2F2019%2F07%2F31%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2F5.CRUD%E6%93%8D%E4%BD%9C%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介 代理持久层实现类（ProxyDao） 通过动态代理增强代码，自动获取 SqlSession类，并调用 selectOne方法、selectList方法、insert方法、update方法、delete方法。- 手动编写持久层实现类（MyDao） 手动获取 SqlSession类，并用 selectList方法、selectOne方法、insert方法、update方法、delete方法。 CRED方法分析 SqlSession接口 selectOne方法 实际上调用的是 selectList方法， insert方法、delete方法 实际上调用的是 update方法， Executor接口 query方法 update方法 StatementHandler接口 query方法 update方法 PreparedStatement接口 execute方法 执行 CRUD语句 返回值：有结果集是 true，没有结果集是 false executeUpdate方法 执行 CUD语句 返回值：数据库中受影响记录的行数 executeQuery方法 执行 SELECT语句 返回值：ResultSet 结果集对象 源码展示![源码](5.CRUD操作 源码分析/MyBatis CRUD操作 源码分析.jpg)]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的反射机制]]></title>
    <url>%2F2019%2F07%2F25%2FJava%20SE%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[基础知识概念 反射是框架设计的灵魂。 反射机制就是将类的各个组成部分封装为其他对象。优势 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 Java代码的阶段 Java代码在计算机中经历的三个阶段 Source（源代码阶段） Java文件被Javac编译为class文件，class文件会将成员变量、成员方法和构造方法等编译成不同的模块。 class文件通过 Classload类加载器 来进入和下一阶段。 Class（类对象阶段） 通过 Classload类加载器，将class文件加载进内存，成员变量、成员方法和构造方法会被封装为Class类中的对象。 Runtime（运行阶段） 当我们需要访问Java文件的成员时，我们就可以逆向访问，通过Class类的Classload类加载器来获取该成员的对象。 获取Class对象 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。 处于Source（源代码阶段），并未加载进内存。 用于配置文件，将类名定义在配置文件中。读取文件，从而加载类。 类名.class：通过类名的属性class获取。 处于Class（类对象阶段），已经加载进内存。 多用于参数的传递。 对象.getClass()：Object类中定义的方法。 Runtime（运行阶段），处于运行时。 用于获取对象的字节码文件对象。 Class类对象 同一个字节码文件( .class)在一次程序运行过程中，只会被加载一次。 不论通过哪一种方式获取的Class类对象都是同一个。12345678// Class类.静态方法forName("全类名")Class class1 = Class.forName("com.test.Person");// 类名.成员classClass class2 = Person.class;// 对象名.成员方法getClass()Person person = new Person();Class class3 = person.getClass(); 获取成员变量 Field[] getFields() 返回包含一个 Field对象数组，反射 所有可访问的 public字段类对象。 Field getField(String name) 返回一个 Field对象，反射 指定的 public成员字段类对象。 Field[] getDeclaredFields() 返回一个 Field对象，反射 所有可访问的 已声明字段类对象。（不考虑修饰符） Field getDeclaredField(String name) 返回一个 Field对象数组，反射 指定已声明字段类对象。（不考虑修饰符） Person类中的成员变量 123456789// public修饰符 public String publicName; public int publicAge;// private修饰符 private String privateName;// protected修饰符 protected String protectedName;// 无修饰符 String name; 获取Person类中的成员变量 123456789101112131415161718192021222324252627 Class pc = Person.class;/* getField("") */Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicName/* getFields() */Field[] fies = pc.getFields(); // public java.lang.String test.Person.publicName // public int test.Person.publicAge/* getDeclaredField("") */Field fie = pc.getDeclaredField("privateName");privateName.setAccessible(true); // private java.lang.String test.Person.privateName/* getDeclaradFields() */Field[] fies = pc.getDeclaredFields();for (Field fie : fies) &#123; fie.setAccessible(true);&#125; // public java.lang.String test.Person.publicName // private java.lang.String test.Person.privateName // protected java.lang.String test.Person.protectedName // java.lang.String test.Person.name 获取构造方法 Constructor&lt;?&gt;[] getConstructors() 返回一个 Constructor对象，反射 指定的 public构造类对象。 Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象，反射 指定的 构造类对象。 Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象数组，反射 所有的 public构造类对象。 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回一个 Constructor对象数组，反射 所有定的 构造类对象。 Person类中的构造方法 123456789// 无参构造public Person() &#123;&#125;// public 带参构造（String）public Person(String publicName) &#123;&#125;// private 带参构造（String,String）private Person(String publicName,String privateName) &#123;&#125; 获取Person类中的构造方法 12345678910111213141516171819202122232425262728/* getConstructor */ Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; Constructor con = pc.getConstructor(String.class); Object object = constructor2.newInstance("Cat"); // &#123;publicName='Cat', privateName='null'&#125;/* getDeclaredConstructor */ Constructor con = pc.getDeclaredConstructor(String.class,String.class,); declaredConstructor.setAccessible(true); Object object = declaredConstructor1.newInstance("Pig","Pug"); // &#123;publicName='Pig', privateName='Pug'&#125;/* getConstructors */ Constructor[] cons = pc.getConstructors(); // public test.Person() // public test.Person(java.lang.String,)/* getDeclaredConstructors */ Constructor[] cons = pc.getDeclaredConstructors(); // public test.Person() // public test.Person(java.lang.String) // private test.Person(java.lang.String,java.lang.String) 获取成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 public成员方法类对象。 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 成员方法类对象。 Method[] getMethods() 返回一个 Method对象数组，反射 所有的 public成员方法类对象。 Method[] getDeclaredMethods() 返回一个 Method对象数组，反射 所有的 成员方法类对象。 Person类中的成员方法 12345678910// public修饰符 public void publicMethod111()&#123;System.out.println("publicMethod()...");&#125; public void publicMethod222(String s)&#123;System.out.println("publicMethod("+ s +")...");&#125;// private修饰符 private void privateMethod()&#123;System.out.println("privateMethod()...");&#125;// protected修饰符 protected void protectedMethod()&#123;System.out.println("publicMethod()...");&#125; 获取Person类中的成员方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445 Class pc = Person.class; Person p = new Person();/* getMethod */ Method method = personClass.getMethod("publicMethod111"); // public void test.Person.publicMethod111() method.invoke(p); // publicMethod()... Method method = personClass.getMethod("publicMethod222", String.class); // public void test.Person.publicMethod222(java.lang.String) method.invoke(p,"带参"); // publicMethod(带参).../* getDeclaredMethod */Method method = pc.getDeclaredMethod("privateMethod"); //private void test.Person.privateMethod()method.setAccessible(true);method.invoke(p); // privateMethod().../* getMethods */ Method[] methods = personClass.getMethods(); //public java.lang.String test.Person.toString() //public java.lang.String test.Person.getName() //public void test.Person.setName(java.lang.String) //public void test.Person.publicMethod111() //public void test.Person.publicMethod222(java.lang.String) //public void test.Person.setPublicAge(int) //public void test.Person.setProtectedName(java.lang.String) //public int test.Person.getPublicAge() // ................................/* getDeclaredMethods */Method[] methods = personClass.getDeclaredMethods(); // public java.lang.String test.Person.toString() // public java.lang.String test.Person.getName() // public void test.Person.setName(java.lang.String) // public void test.Person.publicMethod111() // protected void test.Person.protectedMethod() // private void test.Person.privateMethod() // public void test.Person.publicMethod222(java.lang.String) // public void test.Person.setPublicAge(int) // public void test.Person.setProtectedName(java.lang.String) // ............................... 获取全类名 String getName() 其他操作操作Field 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 暴力反射：忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射123456789101112131415161718Class pc = Person.class;Person p = new Person(); /*public修饰符*/Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicNamefie.set(p,"cat");System.out.print( fie.get(p) ); // cat /*private修饰符*/Field fie = pc.getDeclaredField("privateName"); // private java.lang.String test.Person.privateNamepc.setAccessible(true);pc.set(p,"dog");System.out.print( fie.get(p) ); // dog 操作Constructor 创建对象 T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化 Class对象的newInstance方法 123456789101112 /* Class */ Class pc = Person.class; Object object = pc.newInstance(); // &#123;publicName='null', privateName='null'&#125;/* Constructor */ Class pc = Person.class; Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; 操作Method 执行方法 Object invoke(Object obj, Object… args) 获取方法名 String getName12345Class pc = Person.class;Person p = new Person();Method method = personClass.getMethod("publicMethod111");method.invoke(p);// publicMethod()...]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%2FMySQL%2F</url>
    <content type="text"><![CDATA[基础知识数据库 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。 我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。 所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS 即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS 术语 数据库：数据库是一些关联表的集合。 数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列：一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。MySQL数据库 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。 MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将- 所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。入门配置 打开刚刚解压的文件夹 C:\web\mysql-8.0.11 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 启动 启动MySQL 1net start mysql 登录 MySQ -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 1mysql -h 主机名 -u 用户名 -p 密码 登录本机MySQL 1mysql -u 用户名 -p 密码 关闭MySQL 1net stop mysql 管理 USE $table SHOW DATABASES SHOW TABLES SHOW COLUMNS FROM $table USE $database 选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。 12&gt; Database changed&gt; SHOW DATABASES 列出 MySQL 数据库管理系统的数据库列表。 123456789&gt; +--------------------+&gt; | Database |&gt; +--------------------+&gt; | information_schema |&gt; | mysql |&gt; | performance_schema |&gt; | test |&gt; +--------------------+&gt; SHOW TABLES 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。 12345678&gt; +------------------+&gt; | Tables_in_runoob |&gt; +------------------+&gt; | employee_tbl |&gt; | runoob_tbl |&gt; | tcount_tbl |&gt; +------------------+&gt; SHOW COLUMNS FROM $database 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 12345678+-----------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+--------------+------+-----+---------+-------+| runoob_id | int(11) | NO | PRI | NULL | || runoob_title | varchar(255) | YES | | NULL | || runoob_author | varchar(255) | YES | | NULL | || submission_date | date | YES | | NULL | |+-----------------+--------------+------+-----+---------+-------+ SQL SQL （Structured Query Language ） 结构化查询语言 特点 以分号结尾； 不区分大小写。 分类 DDL（Data Definition Language ） ：定义数据库、表。 DML（Data Manipulation Language） ：对数据库中表的数据进行增删改。 DQL （Data Query Language）：查询数据库中表的数据。 DCL（Data Control Language） ：定义数据库的访问权限和安全级别，及创建用户。 注释 单行注释：“– ”(空格必须加） 单行注释：“#”（空格可加可不加） 多行注释：“/* */” DDL Data Definition Language 数据定义语言 操作数据库使用123456# 使用数据库USE $database;# 查询当前正在使用的数据库名称SELECT DATABASE(); 创建123456789101112# 创建数据库CREATE DATABASE $database;# 创建数据库，并判断是否存在CREATE DATABASE IF NOT EXISTS $database;# 创建数据库，并设置字符集CREATE DATABASE $database CHARACTER SET utf-8;# 创建数据库，判断是否存在，并设置字符集CREATE DATABASE IF NOT EXISTS $database CHARACTER SET utf-8; 查询123456# 查询所有数据库名称SHOW DATABASES;# 查询数据库的创建语句SHOW CREATE DATABASE $database; 修改123# 修改数据库的字符集ALTER DATABASE $database CHARACTER SET gbk; 删除123456# 删除数据库DROP DATABASE $database;# 删除数据库，判断是否存在DROP DATABASE IF EXISTS $database; 操作表、列创建123456789# 创建表CREATE TABLE $table( $columnA $type, $columnB $tyep);# 创建副本CREATE TABLE $tableB LIKE $tableA 查询123456789# 查询某个数据库中的所有表SHOW TABLES;# 查询表结构DESC $table;# 查询表的创建语句SHOW CREATE TABLE $table; 修改123456789101112131415161718# 修改表名ALTER TABLE $tableOld RENAME TO $tableNew# 修改表的字符集ALTER TABLE $table CHARACTER SET utf-8;# 修改列ALTER TABLE $table CHANGE $columnOld $columnNew $typeNew;# 修改类型ALTER TABLE $table MODIFY $column $tyepNew;# 添加列ALTER TABLE $table ADD $column $type;# 删除列ALTER TABLE $table DROP $column; 删除123456# 删除表DROP TABLE $table;# 删除表，判断是否存在DROP TABLE IF EXISTS $table; DML Data Manipulation Language 数据操作语言 操作记录、值创建123456# 给记录中的所有字段，添加值INSERT INTO $table VALUES($valueA,$valueB....)# 给记录中指定的字段，添加值INSERT INTO $table($columnA) VALUES($valueA) 删除123456789# 删除所有记录DELETE * FROM $table;# 删除指定记录DELETE FROM $table WHERE $column = $value;# 删除所有记录，并创建一个空副本TRUNCATE TABLE $table; 修改123456# 给记录中所有的字段，修改值UPDATE $table SET $columnA = $valueA;# 给记录中指定的字段，修改值UPDATE $table SET $columnA = $valueA WHERE $colmnB = $valueB; DQL Data Query Language 数据查询语言 基础查询123456789101112131415161718192021222324252627282930313233# 查询表中的所有列SELECT * FROM $table;# 查询表中指定的列SELECT $column FROM $table;# 查询表中指定的列，并去掉重复的字段SELECT DISTINCT $column FROM $table;# 查询表中指定的列，并计算SELECT $columnA, $columnB, $columnA + $columnB FROM $table;# 查询表中指定的列，并计算，且排除为null的情况SELECT $columnA, $columnB, IFNULL($columnA,0) + IFNULL($columnB,0) FROM $table;# 查询表中指定的列，计算，排除为null的情况，给计算结果起名# AS可省略SELECT $columnA AS $nameA, $columnB AS $nameB, IFNULL($columnA,0)+IFNULL($columnB,0) AS $nameCFROM $table; 条件查询1234567891011121314151617181920# 大于、大于等于、等于、不等于、不等于WHERE $column &gt; $value;WHERE $column &gt;= $value;WHERE $column = $value;WHERE $column != $value;WHERE $column &lt;&gt; $value;# 范围WHERE $column&gt;=10 &amp;&amp; $column&lt;=100;WHERE $column&gt;=10 AND $column&lt;=100;WHERE $column BETWEEN 10 AND 1000;# 个例WHERE $column=10 OR $column=20;WHERE $column IN (10,20,30,40);#查询NULLWHERE $column IS NULL;WHERE $column IS NOT NULL; 模糊查询123456# “_” 单个任意字符WHERE $column = &apos;C_t&apos;;# “%” 多个任意字符WHERE $column = &apos;super%&apos;; 排序查询123456# 按照指定列的顺序，升序排序ORDER BY $column ASC;# 按照指定列的顺序，降序排序ORDER BY $column DESC; 聚合函数 聚合函数排除了NULL值123456789101112131415161718# 计算指定列的 字段个数SELECT COUNT($column) FROM $table;# 计算指定列的 字段个数，且不排除NULL值SELECT COUNT( IFNULL($column,0) ) FROM $table;# 计算指定列的 最大值SELECT MAX($column) FROM $table;# 计算指定列的 最小值SELECT MIN($column) FROM $table;# 计算指定列的和SELECT SUM($column) FROM $table;# 计算指定列的平均值SELECT AVG($column) FROM $table; 分组查询12 分页查询DCL Data Control Language 数据控制语言 12 约束]]></content>
      <categories>
        <category>&lt;b&gt;数据库&lt;/b&gt;</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS中的函数是否加括号的问题]]></title>
    <url>%2F2019%2F07%2F22%2FJava%20Web%2FJS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数表达式的定位 本文相关的概念：函数，函数表达式，返回值。 函数：函数名为Fun的函数。函数表达式：Fun() 和 fun。返回值：即函数Fun的返回值。 首先，需要明确的概念是：函数表达式的定位。不同的定位决定了不同的功能，以下是我列出来的函数表达式及其定位。我会在详细表述表达式时，附上便于理解的代码。 函数表达式 定位 function() 调用函数、返回返回值 function 函数的副本 函数表达式 function()当按钮被点击，函数表达式Fun() 作为参数首先被执行。于是，第一步，函数Fun被调用，函数Fun执行 方法alert(111)，弹出“111”；第二步，函数fun 返回 返回值222。接着，按钮的点击事件执行 alert方法，并接收到了返回值222，弹出“222”。 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun()); &#125;&lt;/script&gt; 函数表达式 function我们在前面说到 函数表达式Fun 的定位是 函数Fun 的一个副本。为了印证这个观点，其余代码不变，将函数表达式Fun() 换成 函数表达式Fun。我得到的结果是，弹出： “ function Fun() { alert(1); return 222; } “ 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能的Key-Value数据库：Redis]]></title>
    <url>%2F2019%2F07%2F21%2FJava%20Web%2FRedis%2F</url>
    <content type="text"><![CDATA[NoSQL概念 NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web- 0网站的兴起，传统的关系数据库在应付web- 0网站，特别是超大规模和高并发的SNS类型的web- 0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 比较非关系型数据库优势 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 ## 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 ## 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis## 概念 Redis是一款高性能的NOSQL系列的非关系型数据库 Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s 。 Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedsetredis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离下载安装 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端数据结构 Redis存储：key，value格式的数据 key的数据类型：字符串 value的数据结构： 字符串类型 string 哈希类型 hash （map格式） 列表类型 list （ Linkedlist格式，允许重复） 集合类型 set （HashSet格式，不允许重复） 有序集合类型 sortedset （不允许重复，且有序）命令操作字符串类型 string 存储： set key value 获取： get key 删除： del key 哈希类型 hash 存储： hset key field value 获取指定的field对应的值：hget key field: 获取所有的field和value：hgetall key 删除： hdel key field 列表类型 list 将元素加入列表左边： lpush key value 将元素加入列表右边：rpush key value 范围获取：lrange key start end 获取所有元素：lrange key 0 -1 删除列表最左边的元素，并将元素返回：lpop key 删除列表最右边的元素，并将元素返回：rpop key 集合类型 set set 集合 （ 不允许重复） 存储：sadd key value 获取set集合中所有元素：smembers key 删除set集合中的某个元素：srem key value 有序集合类型 sortedset sortedset集合 不允许重复元素，且元素有顺序。 每个元素都会关联一个double类型的分数。 redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令 查询所有的键：keys * 获取键对应的value的类型：type key 删除指定的key value：del key 持久化机制 Redis持久化 Redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据丢失时，我们可以将redis内存中的数据持久化，将其保存到硬盘的文件中。RDB 默认持久化机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据。 修改 redis.windwos.conf 文件 save 900 1：after 900 sec (15 min) if at least 1 key changed save 300 10：after 300 sec (5 min) if at least 10 keys changed save 60 10000：after 60 sec if at least 10000 keys changed 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf AOF 日志记录机制 记录每一条命令的操作。每一次命令操作后，持久化数据。 编辑 redis.windwos.conf 文件 开启AOF appendonly no（关闭AOF） ppendonly yes （开启AOF） 取值 appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化（默认） appendfsync no： 不进行持久化 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf Jedis（Java客户端） Jedis:是一款java操作redis数据库的工具.快速入门 下载jedis的jar包 使用123456// 获取连接 Jedis jedis = new Jedis("localhost",6379);// 操作 jedis.set("username","zhangsan");// 关闭连接 jedis.close(); 命令操作字符串类型 string set get1234567891011121314151617@Test/* 操作字符串String */public void test02() &#123; // 获取连接 Jedis jedis = new Jedis(); //空参构造，默认("localhost",6379) // 存储 jedis.set("cat","001"); // 获取 String cat = jedis.get("cat"); System.out.println(cat); // 存储有时限的数据 jedis.setex("dog",10,"002"); // 时间单位：秒 // 关闭连接 jedis.close();&#125; 哈希类型 hash （ map格式 ） hset hget hgetAll12345678910111213141516171819202122232425@Test /* 操作Hash */public void test03() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.hset("map","cat","111"); jedis.hset("map","dog","222"); jedis.hset("map","rat","333"); // 获取 String cat = jedis.hget("map", "cat"); System.out.println(cat); // 获取hash中的map中的所有数据 Map&lt;String, String&gt; map = jedis.hgetAll("map"); // 输出 Set&lt;String&gt; keySet = map.keySet(); for (String s : keySet) &#123; String value = map.get(s); System.out.println(s+":"+value); &#125; // 关闭连接 jedis.close();&#125; 列表类型 list （ LinkedList格式，允许重复） lpush / rpush lpop / rpop lrange start end 12345678910111213141516171819202122@Test /* 操作List(允许重复) */public void test04() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.lpush("list","A","B","C","D"); jedis.rpush("list","A","B","C","D"); // 打印 List&lt;String&gt; list = jedis.lrange("list", 0, -1); System.out.println(list); // 弹出 String element1 = jedis.lpop("list"); String element2 = jedis.lpop("list"); // 打印 System.out.println(element1); System.out.println(element2); List&lt;String&gt; list2 = jedis.lrange("list", 0, -1); System.out.println(list2); // 关闭连接 jedis.close();&#125; 集合类型 set （HashSet格式， 不允许重复） sadd smembers12345678910111213@Test /* 操作Set(不允许重复) */public void test05() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.sadd("set","A","B","C","D"); // 获取 Set&lt;String&gt; set = jedis.smembers("set"); // 打印 System.out.println(set); // 关闭连接 jedis.close();&#125; 有序集合类型 sortedset zadd zrange123456789101112131415@Test /* 操作SortedSet(不允许重复，有序) */public void test06() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.zadd("sortedSet",1,"cat"); jedis.zadd("sortedSet",2,"dog"); jedis.zadd("sortedSet",3,"rat"); // 获取 Set&lt;String&gt; sortedSet = jedis.zrange("sortedSet", 0, -1); // 打印 System.out.println(sortedSet); // 关闭连接 jedis.close();&#125; JedisPool（jedis连接池） 快速入门 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接123456789101112131415// 创建连接池配置对象 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); // 设置配置 jedisPoolConfig.setMaxTotal(50); jedisPoolConfig.setMaxIdle(10); // 创建连接池对象，并传入连接池配置对象 JedisPool jedisPool = new JedisPool(jedisPoolConfig, "localhost", 6379); // 获取连接 Jedis resource = jedisPool.getResource(); // 使用 resource.set("name", "cat"); String s = resource.get("name"); System.out.println(s); // 关闭，归还到连接池中 resource.close(); JedisPoolUtil工具类 设置 JedisPoolUtil工具类 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 设置之后的操作，简化了很多 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; ​]]></content>
      <categories>
        <category>&lt;b&gt;数据库&lt;/b&gt;</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的对象表示法：JSON]]></title>
    <url>%2F2019%2F07%2F20%2FJava%20Web%2FJson%2F</url>
    <content type="text"><![CDATA[概念 JSON：JavaScript 对象表示法（JavaScript Object Notation） JSON现在多用于存储和交换文本信息的语法，进行数据的传输。 JSON 比 XML 更小、更快，更易解析。 注意：JSON 虽然使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。1234567&#123; "employees": [ &#123; "firstName":"Bill" , "lastName":"Gates" &#125;, &#123; "firstName":"George" , "lastName":"Bush" &#125;, &#123; "firstName":"Thomas" , "lastName":"Carter" &#125; ]&#125; 区别类似 XML JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字总结 对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 语法 JSON 语法是 JavaScript 语法的子集。语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组名称/值对JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：1"firstName" : "John" 值 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） { “firstName”:”John” , “lastName”:”Doe” } null文件 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” 使用获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 123456789101112131415161718192021222324252627282930313233 /* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; var name11 = person.name; var name12 = person["name"];/* 嵌套格式 */ // JSON &#123; JSON,JASON &#125; var persons = &#123; "personCat": &#123;"name":"cat","age":11&#125;, "personDog":&#123;"name":"dog","age":12&#125;, "personRat":&#123;"name":"rat","age":13&#125;&#125; var personCat = persons.personCat; var name2 = persons.personCat.name; // Array [JSON,JASON] var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] var name3 = array[0].name; // JSON &#123; Array[JSON,JASON], Array[JSON,JASON] &#125; var persons = &#123; "person1":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,], "person2":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,] &#125; var name4 = persons.person1[0].name; 遍历12345678910111213141516171819202122/* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; for (var key in person) &#123; // * key默认为字符串 alert(key); alert(person.key); // * person."name"; 无法获取 alert(person[key]); // * person["name"]; 无法获取 &#125; /* 嵌套格式 */ var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] for (var i =0;i&lt;array.length;i++) &#123; var p = array[i]; for (var key in p) &#123; alert(key); alert(p[key]); &#125; &#125; 转换 转换 由于JSON对象的特性，在实际操作中，我们通过JSON对象代替Java对象在数据中的传输。所以，我们需要学习JSON对象和Java对象的相互转换。 JSON解析器 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class)Java对象转换JSON 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 writeValue(参数1，obj) File：将obj对象转换为JSON字符串，并保存到指定的文件中。 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中。 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中。 writeValueAsString(obj) 将对象转为json字符串 注解 @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern = “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致 格式问题 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。 在浏览器端设置$.ajax属性 $.get(type):将最后一个参数type指定为”json” 在服务器端设置MIME类型 response.setContentType(“application/json;charset=utf-8”);]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>JavaScript</category>
        <category>Json</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用于构建快速动态网页的异步数据传输技术：Ajax]]></title>
    <url>%2F2019%2F07%2F20%2FJava%20Web%2FAjax%2F</url>
    <content type="text"><![CDATA[基础知识AJAX AJAX 是与服务器交换数据的艺术，它在不重载全部页面的情况下，实现了对部分网页的更新。 AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 异步和同步 同步 客户端和服务器端相互通信的基础上，客户端必须等待服务器端的响应。 在等待的期间客户端不能做其他操作。 异步 客户端和服务器端相互通信的基础上，客户端不需要等待服务器端的响应。 在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式JS实现方式（了解） 如果没有 jQuery，AJAX 编程还是有些难度的。123456789101112131415161718192021222324252627282930313233/* 发送异步请求 */// 1.创建对象 var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125;// 2.建立连接// * 请求方式：GET/POST// * 请求的URL// * 同步或异步请求：true（异步）、false（同步） xmlhttp.open("GET","/ajaxServlet?fname=Henry&amp;lname=Ford",true);// 3.发送请求 xmlhttp.send(); // POST方式 // xmlhttp.open("POST","/ajaxServlet",true); // xmlhttp.send("fname=Henry&amp;lname=Ford");// 4.接受并处理来自服务器的相应结果// 判断服务器是否成功响应 xmlhttp.onreadystatechange=function()&#123; // readyState：就绪状态 // status：响应状态码 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; // responseText：响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQeury实现方式 通过 jQuery AJAX 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON 同时能够把这些外部数据直接载入网页的被选元素中。$.ajax() 12345678910111213141516171819$.ajax(&#123; // url：请求路径 url:"/ajaxServlet", // type：请求方式 type:"POST", // data：请求参数 // data:"fname=Henry&amp;lname=Ford", data:&#123;"fname":"Henry","lname":"Ford"&#125;, // Json方式// success：响应成功后的回调函数 success:function (responseData) &#123; alert(responseData);&#125;,// error：响应错误后的回调函数error:function () &#123; alert("出错了!"); &#125;, // dateType：设置接受到的响应数据的格式 dataType:"text"&#125;); $.get()123456789101112 $.get( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125; $.post()123456789101112$.post( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125;]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>JavaScript</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁、快速的JavaScript框架/库：jQuery]]></title>
    <url>%2F2019%2F07%2F19%2FJava%20Web%2FjQuery%2F</url>
    <content type="text"><![CDATA[基础知识简介 jQuery是一个快速、简洁的JavaScript框架。 jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 jQuery封装了JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery本质上就是一些js文件，封装了js的原生代码而已。 jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 安装 下载JQuery 目前jQuery有三个大版本 1.x 兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了。 2.x 不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x。 3.x 不兼容ie678，只支持最新的浏览器。 除非特殊要求，一般不会使用3.x版本的，因为很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。 每个大版本包括两个小版本 jquery.js Development version（开发版本） - 用于测试和开发。 给程序员看的，有良好的缩进和注释，体积大一些，程序加载较慢。 jquery.min.js Production version（生产版本）- 用于实际的网站中，已被精简和压缩。 在程序中使用，没有缩进，体积小一些，程序加载更快。 导入JQuery的js文件 引入Jquery资源 请注意，&lt;script&gt; 标签应该位于页面的 &lt;head&gt; 部分。123&lt;head&gt; &lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt; 基础语法 $(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作文档就绪函数 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 123456789/* 完全体 */$(document).ready(function()&#123;&#125;);/* 简化版 */$(function()&#123;&#125;); 转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用 两者相互转换 Jquery – &gt; JS Jquery对象[索引] Jquery对象.get(索引) JS – &gt; Jquery $(JS对象) 选择器 jQuery选择器允许您对元素组或单个元素进行操作。 jQuery 元素选择器和属性选择器允许您通过标签名、属性名或内容对 HTML 元素进行选择。 jQuery选择器允许您对 HTML 元素组或单个元素进行操作。 在 HTML DOM 术语中：jQuery选择器允许您对 DOM 元素组或单个 DOM 节点进行操作。 基本选择器 选择器 实例 描述 * $(“*”) 所有元素 this $(this) 当前 HTML 元素 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) 所有 class=”intro” 的元素 .class.class $(“.intro.demo”) 所有 class=”intro” 且 class=”demo” 的元素 element $(“p”) 所有 &lt;p&gt; 元素 element.class $(“p.intro”) 所有 class=”intro” 的 &lt;p&gt; 元素 element#id $(“p#demo”) 所有 id=”demo” 的 &lt;p&gt; 元素。 s1,s2,s3 $(“th,td,.intro”) 所有带有匹配选择的元素 层级选择器 选择器 实例 描述 super sub $(“table tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;元素（不仅是子元素） super &gt; sub $(“table &gt; tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;子元素 ## 属性选择器 - jQuery 使用 XPath 表达式来选择带有给定属性的元素。 选择器 实例 描述 :—: —– —– [atribute] $(“[href]”) 所有带有 href 属性的元素 [[attribute = value]] $(“[href=’#’]”) 所有 href 属性的值等于 “#” 的元素 [[attribute != value]] $(“[href!=’#’]”) 所有 href 属性的值不等于 “#” 的元素 [[attribute *$= *value]] $(“[href$=’.jpg’]”) 所有 href 属性的值包含以 “.jpg” 结尾的元素 过滤选择器 选择器 实例 描述 [:first] $(“p:first”) 第一个 &lt;p&gt; 元素 [:last] $(“p:last”) 最后一个 &lt;p&gt; 元素 [:even] $(“tr:even”) 所有偶数 &lt;tr&gt; 元素 [:odd] $(“tr:odd”) 所有奇数 &lt;tr&gt; 元素 [:eq(index)] $(“ul li:eq(3)”) 列表中的第四个元素（index 从 0 开始） [:gt(no)] $(“ul li:gt(3)”) 列出 index 大于 3 的元素 [:lt(no)] $(“ul li:lt(3)”) 列出 index 小于 3 的元素 [:empty] $(“:empty”) 无子（元素）节点的所有元素 :not(selector) $(“input:not(:empty)”) 所有不为空的 input 元素 [:header] $(“:header”) 所有标题元素 &lt;h1&gt; - &lt;h6&gt; [:contains(text)] $(“:contains(‘W3School’)”) 包含指定字符串的所有元素 :hidden $(“p:hidden”) 所有隐藏的 &lt;p&gt; 元素 [:visible] $(“table:visible”) 所有可见的表格 表单过滤选择器 选择器 实例 描述 [:input] $(“:input”) 所有 &lt;input&gt; 元素 [:text] $(“:text”) 所有 type=”text” 的 &lt;input&gt; 元素 [:password] $(“:password”) 所有 type=”password” 的 &lt;input&gt; 元素 [:radio] $(“:radio”) 所有 type=”radio” 的 &lt;input&gt; 元素 [:checkbox] $(“:checkbox”) 所有 type=”checkbox” 的 &lt;input&gt; 元素 [:submit] $(“:submit”) 所有 type=”submit” 的 &lt;input&gt; 元素 [:reset] $(“:reset”) 所有 type=”reset” 的 &lt;input&gt; 元素 [:button] $(“:button”) 所有 type=”button” 的 &lt;input&gt; 元素 [:image] $(“:image”) 所有 type=”image” 的 &lt;input&gt; 元素 [:file] $(“:file”) 所有 type=”file” 的 &lt;input&gt; 元素 [:enabled] $(“:enabled”) 所有激活的 input 元素 [:disabled] $(“:disabled”) 所有禁用的 input 元素 [:selected] $(“:selected”) 所有被选取的 input 元素 [:checked] $(“:checked”) 所有被选中的 input 元素 事件函数 jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 术语由事件“触发”（或“激发”）经常会被使用。 如果你的网站包含许多页面，为了让 jQuery 函数易于维护，需要将 jQuery 函数放到独立的 .js 文件中。123456&lt;head&gt;&lt;!-- 引入Jquery资源 --&gt;&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;!-- 引入独立的js文件 --&gt;&lt;script type="text/javascript" src="my_jquery_functions.js"&gt;&lt;/script&gt;&lt;/head&gt; 鼠标事件 事件 描述 click 当单击元素时 dbclick 当双击元素时 mouseenter 当鼠标指针穿过（进入）被选元素时 mouseleave 当鼠标指针离开被选元素时 hover 当鼠标指针悬停在被选元素上时 ## 键盘事件 事件 描述 —– :—: keydown 键按下的过程 keypress 键被按下 keyup 键被松开 ## 表单事件 事件 描述 —– :—: submit 当提交表单时 change 当元素的值改变时发生 change 事件（仅适用于表单字段） focus 当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时） blur 当元素失去焦点时 ## 窗口事件 事件 描述 —– :—: resize 当调整浏览器窗口大小时 scroll 当用户滚动指定的元素时 DOM操作 jQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 提示：DOM = Document Object Model（文档对象模型）内容操作方法 html() 获取/设置元素的标签体内容（包括 HTML 标记） text() 获取/设置元素的标签体纯文本内容 val() 获取/设置元素的value属性值123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("Dolly Duck");&#125;); 属性操作方法 通用属性操作 attr() 获取/设置元素的属性 如果操作的是元素自定义的属性，则建议使用attr removeAttr() 删除属性 prop() 获取/设置元素的属性 如果操作的是元素的固有属性，则建议使用prop removeProp() 删除属性123$("button").click(function()&#123; $("#w3s").attr("href","http://www.w3school.com.cn/jquery");&#125;); 对class属性操作 addClass() 添加class属性值 removeClass() 删除class属性值 toggleClass() 切换class属性 toggleClass(“one”): 如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加。 css() 设置/添加属性值 123456789101112131415$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;);$("button").click(function()&#123; $("h1,h2,p").removeClass("blue");&#125;);$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;);$("p").css("background-color","yellow");$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); 文档操作方法 append() 父元素将子元素追加到末尾 A.append(B) 将B添加到A元素内部，并且在末尾。 prepend() 父元素将子元素追加到开头 A.prepend(B) 将B添加到A元素内部，并且在开头。 appendTo() 子元素将父元素追加到末尾 A.appendTo(B) 将A添加到B内部，并且在末尾。 prependTo() 子元素将父元素追加到开头 A.prependTo(B) 将A添加到B内部，并且在开头。 after() 添加元素2到元素1后边 A.after(B) 将B添加到A后边（兄弟关系） before() 添加元素2到元素1前边 A.before(B) 将B添加到A前边（兄弟关系） insertAfter() 添加元素1到元素2后边 A.insertAfter(B) 将A添加到B后边（兄弟关系） insertBefore() 添加元素1到元素2前边 A.insertBefore(B) 将A添加到B前边（兄弟关系） remove() 移除元素 A.remove() 将A删除掉 empty() 清空元素的所有后代元素。 A.empty() 将对象的后代元素全部清空，但是保留当前A以及其属性节点12345678$("p").append("Some appended text.");$("p").prepend("Some prepended text.");$("img").after("Some text after");$("img").before("Some text before");$("#div1").remove();// jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。$("p").remove(".italic");$("#div1").empty(); 动画显示/隐藏 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： show( speed，callback ) hide( speed，callback ) 通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。 toggle(speed,callback) speed：参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 callback：参数是隐藏或显示完成后所执行的函数名称。1234567891011$("#hide").click(function()&#123; $("p").hide();&#125;);$("#show").click(function()&#123; $("p").show();&#125;);$("button").click(function()&#123; $("p").toggle();&#125;); 淡入/淡出 通过 jQuery，您可以实现元素的淡入淡出效果。 fadeIn() 用于淡入已隐藏的元素。 fadeOut() 用于淡出可见元素。 fadeToggle() 在淡入淡出之间切换。1234567891011121314151617$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); 滑动 通过 jQuery，您可以在元素上创建滑动效果。 slideDown() 用于向下滑动元素。 slideUp() 用于向上滑动元素。 slideToggle() 在向下滑动向上滑动之间切换。1234567891011$("#flip").click(function()&#123; $("#panel").slideDown();&#125;);$("#flip").click(function()&#123; $("#panel").slideUp();&#125;);$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 遍历JS的遍历方式 for (初始化值;循环结束条件;步长)Jquery的遍历方式 Jquery对象.each(callback) jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 callback：回调函数返回值 true：如果当前function返回为false，则结束循环(break)。 false：如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of for(元素对象 of 容器对象) Jqueryuery 3.0 之后1234567891011121314151617181920212223242526272829303132333435363738 /* for循环 */var citys = $("#city li");for (var i = 0; i &lt; citys.length; i++) &#123; //获取内容 alert(i+":"+citys[i].innerHTML); if("上海" == citys[i].innerHTML)&#123; //break; 结束循环 //continue; //结束本次循环，继续下次循环 &#125;&#125;/* Jquery对象.each(callback) */var citys = $("#city li");citys.each(function (index,element) &#123; // 1.获取li对象 第一种方式 this alert(this.innerHTML);//JS对象调用 alert($(this).html());//Jquery对象调用 // 2.获取li对象 第二种方式 在回调函数中定义参数 index（索引） element（元素对象） alert(index+":"+element.innerHTML); alert(index+":"+$(element).html()); //判断如果是上海，则结束循环 if("上海" == $(element).html())&#123; //返回false，结束循环(break)。 //返回true，结束本次循环，继续下次循环(continue) return true; &#125;&#125;);/* $.each(object, [callback]) */$.each(citys,function (index,element) &#123; alert($(this).html());&#125;);/* for ... of (jquery 3.0 版本之后提供的方式) */for(li of citys)&#123; alert($(li).html());&#125; 事件绑定 Jquery标准的绑定方式 jq对象.事件方法(回调函数) 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 toggle事件切换 jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。1&lt;script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 插件 $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议里的Cookie、Session、JSP]]></title>
    <url>%2F2019%2F07%2F15%2FJava%20Web%2FCookie%20Session%20JSP%2F</url>
    <content type="text"><![CDATA[会话技术 概念 一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。 功能 在一次会话的范围内的多次请求间，来共享数据。 方式 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 客户端会话技术，将数据保存到客户端。 Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies）； 一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies） 快速入门 使用步骤： 服务器通过response，对浏览器发送cookie *new Cookie(String name, String value) * *response.addCookie(Cookie cookie) * 服务器通过request，接收浏览器发送的cookie *Cookie[] request.getCookies() * 实现原理 服务器通过response，对浏览器发送cookie 服务器将数据，保存在响应头的set-cookie中。 当服务器通过request，接收浏览器发送的cookie 浏览器将数据，保存在请求头的cookie中。 cookie的细节一次可不可以发送多个cookie? 一次可以发送多个cookie。 创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁。 设置Cookie生命周期，使其持久化存储 setMaxAge(int seconds) 正数：持久化存储，并指定cookie存活时间。 在时间内，关闭浏览器cookie仍然可访问。 负数：默认值 关闭浏览器后，无法访问。 零：删除cookie信息 一般是先设置持久化存储，然后删除。cookie能不能存储中文？ 在tomcat8 之前，cookie中不能直接存储中文数据。 需要将中文数据转码为一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。 特殊字符还是不支持，建议使用URL编码存储，URL解码解析cookie共享问题？ 在同一个tomcat服务器中的多个web项目的cookie能不能共享？ 默认情况下cookie不能共享 设置获取cookie范围（默认设置当前虚拟目录） setPath(String path) 如果要共享，则可以将path设置为”/“（根路径） 在不同的tomcat服务器间cookie能不能共享？ 设置获取cookie范围 setDomain(String path) 如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”) 那么tieba.baidu.com和news.baidu.com中cookie可以共享 特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 浏览器对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别（个性化设置） JSP概念 Java Server Pages（java服务器端页面） 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理 JSP本质上就是一个Servlet实现类 如果我们要编写一个正常的主页，那么我们在servlet实现类中既要写后端代码，也要写前端代码。但是在servlet实现类中写前端代码（response.write.write()）太麻烦了，所以出现了JSP。 JSP本质是一个servlet实现类，它会将所有的前端代码自动的包裹进输出代码（out.write()）。 脚本 JSP的脚本：JSP定义Java代码的方式 &lt;% %&gt; 定义的java代码，在service方法中。 &lt;%! %&gt; 定义的java代码，定义java类的成员。 &lt;%= %&gt; 定义的java代码，输出到页面上。 内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象 request response out 字符输出流对象。可以将数据输出到页面上。 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 Session概念 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 快速入门 获取HttpSession对象 HttpSession session = request.getSession() 使用HttpSession对象 Object getAttribute(String name) void setAttribute(String name, Object value) *void removeAttribute(String name) * 原理 Session的实现是依赖于Cookie的。 细节 当浏览器关闭后，服务器不关闭，两次获取的session是否相同？ 默认情况下，两次session不同。 浏览器关闭，意味着会话结束。 如果需要两次session相同 创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie cookie = new Cookie(“JSESSIONID”,session.getId()); cookie.setMaxAge(60*60); response.addCookie(c); 浏览器不关闭，服务器关闭后，两次获取的session是否相同？ 两次session不同，但是要确保数据不丢失。 tomcat自动完成，IDEA不能 自动完成。 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上。 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30 &lt;session-config&gt; ## 特点－ session用于存储一次会话的多次请求的数据，存在服务器端。－ session可以存储任意类型，任意大小的数据。 session与Cookie的区别 Session(会话） － session存储数据在服务器端 － session没有数据大小限制 － session数据安全 Cookie（甜点） －Cookie有数据大小限制 －Cookie存储数据在客户端 －Cookie相对于不安全]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议下Servlet的响应消息对象：Request]]></title>
    <url>%2F2019%2F07%2F14%2FJava%20Web%2Fresponse%2F</url>
    <content type="text"><![CDATA[功能设置响应行 设置状态码 *setStatus(int sc) * 设置响应头 设置响应头 *setHeader(String name, String value) * 设置响应体 获取输出流 字符输出流（字符数据） PrintWriter getWriter() 字节输出流（任意数据） ServletOutputStream getOutputStream() 其他功能重定向（redirect） 重定向是一种在互联网中的资源跳转方式。 方法一 通过response对象设置状态码 response.setStatus(302); 使用response对象设置响应头的location参数 *response.setHeader(“location”,”/response2”); * 方法二 通过response对象的重定向方法 response.sendRedirect(“/response2”); 重定向的特点 重定向 重定向 地址栏会发生变化 重定向 可以访问其他服务器的资源 重定向 是两次请求 转发的特点 转发 转发 地址栏不会发生变化 转发 不可以访问其他服务器的资源 转发 是一次请求 输出数据 设置 获取字符输出流 PrintWriter writer = response.getWriter(); 输出数据 writer.write(“&lt;h1&gt;在恭喜发财！&lt;/h1&gt;”); 中文乱码问题 在获取流之前，设置流编码为系统默认编码（可以不写） response.setCharacterEncoding(“utf-8”); 设置浏览器解码的编码 response.setHeader(“content-type”,”text/html;charset=utf-8”); 设置浏览器解码的编码（简化） response.setContentType(“text/html;charset=utf-8”); ServletContext对象概念 ServletContext对象代表整个web应用，可以和程序的容器(服务器)来通信。获取 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext();功能获取MIME类型 获取MIME类型 String getMimeType(String file) MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。ServletContext域：所有用户所有请求的数据 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 文件真实路径 获取文件的真实路径（tomcat服务器） String getRealPath(String path); web目录下资源访问 context.getRealPath(“/b.txt”); WEB-INF目录下的资源访问 context.getRealPath(“/WEB-INF/c.txt”); src目录下的资源访问 context.getRealPath(“/WEB-INF/classes/a.txt”);]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议下Servlet的请求消息对象：Request]]></title>
    <url>%2F2019%2F07%2F13%2FJava%20Web%2Frequest%2F</url>
    <content type="text"><![CDATA[原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 体系结构 ServletRequest 接口 HttpServletRequest 接口 （继承） org.apache.catalina.connector.RequestFacade 类（Tomcat实现） 功能获取请求消息数据获取请求行数据 请求行数据：GET /web/A?name=Cat HTTP/1.1 请求方式： GET String getMethod() 请求端的URI(统一资源标识符) 地址：/web/A String getRequestURI() 请求端的URL(统一资源定位符)地址： http: //localhost//web/A StringBuilder getRequestURL() 虚拟目录：/web String getContextPath() 服务器路径：/A String getServletPath() 请求参数：name=Cat String getQueryString() HTTP协议的版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr()123456789101112131415161718//请求方式： GET String method = request.getMethod();//请求端的URI地址：/web/A String requestURI = request.getRequestURI();//请求端的URI地址：/web/A StringBuffer requestURL = request.getRequestURL();//虚拟目录：/web String contextPath = request.getContextPath();//服务器路径：/A String servletPath = request.getServletPath();//请求参数：name=Cat String queryString = request.getQueryString();//HTTP协议的版本：HTTP/1.1 String protocol = request.getProtocol();//获取客户机的IP地址： String remoteAddr = request.getRemoteAddr();//获取客户机的端口号 int remotePort = request.getRemotePort(); 获取请求头数据 请求头数据 通过请求头的名称 获取请求头的值 String getHeader(String name) 获取 所有的请求头名称（判断浏览器） Enumeration&lt;String&gt; getHeaderNames():12345678//获取 所有的请求头名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements())&#123; //通过请求头的名称 获取请求头的值 String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name+" ===== "+value); &#125; 获取请求体数据 请求体（POST请求方式） 获取字符输入流（字符数据） BufferedReader getReader() 获取字节输入流（所有类型数据） ServletInputStream getInputStream()1234567&lt;form action="/request1" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;input type="checkbox" name="hobby" value="dance"&gt; &lt;input type="checkbox" name="hobby" value="sing"&gt; &lt;input type="checkbox" name="hobby" value="rap"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 1234567891011@WebServlet("/request1")public class Request1 extends HttpServlet &#123;//获取字符输入流（字符数据） BufferedReader reader = request.getReader(); String line; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; 其他功能获取动态目录 为了防止虚拟目录变更，建议使用动态虚拟目录 -getContextPath() 路径 相对路径 相对路径 无法确定唯一资源 ./index.html 当前资源和目标资源的相对位置关系 ./ 当前目录 ../ 后退一级目录 绝对路径 绝对路径 可以确定唯一资源 /web/index.html 获取请求参数(通用) 获取请求参数通用方式 不论get还是post请求方式都可以使用下列方法来获取请求参数 根据参数名称 获取参数值 ：(username) cat String getParameter(String name) 根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] getParameterValues(String name) 获取 所有请求的参数名称：username hobby Enumeration&lt;String&gt; getParameterNames() 获取 所有参数的map集合：username=cat hobby=sing,rap Map&lt;String,String[]&gt; getParameterMap()1234567891011121314151617181920212223242526272829303132333435//根据参数名称 获取参数值 ：(username)cat String username = request.getParameter("username"); System.out.println(username); //根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] hobbies = request.getParameterValues("hobby"); for (String hobby : hobbies) &#123; System.out.println(hobby); &#125;//获取 所有请求的参数名称： username hobbyEnumeration&lt;String&gt; parameterNames = request.getParameterNames();while (parameterNames.hasMoreElements())&#123;String s = parameterNames.nextElement();System.out.println(s);&#125;//获取 所有参数的map集合 /* Map集合：获取所有参数 */ Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); /* Set集合：包含参数和参数的值们 */ Set&lt;String&gt; keyset = parameterMap.keySet(); /* 迭代器*/ Iterator&lt;String&gt; iterator = keyset.iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.print(key+": "); String[] values = parameterMap.get(key); for (String value : values) &#123; System.out.print(value+" "); &#125; System.out.println();&#125; 请求转发（forword） 请求转发是一种在服务器内部的资源跳转方式。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 *forward(ServletRequest request, ServletResponse response) * 特点 浏览器地址栏路径不发生变化。 只能转发到当前服务器内部资源中。 多个服务器资源使用一次请求。 Java文件一 1234567891011@WebServlet("/request111")public class Request1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("助理：我是处理部门的助理，你有什么问题？"); System.out.println("助理：你的问题我解决不了，我去叫经理，稍等。"); //找到“经理的位置” RequestDispatcher requestDispatcher = request.getRequestDispatcher("/request222"); //把“问题”告诉经理 requestDispatcher.forward(request,response); &#125;&#125; Java文件二 1234567@WebServlet("/request222")public class Request2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("经理：我是处理部门的经理，你有什么问题？"); System.out.println("经理：你的问题我已经解决了，你回去吧。"); &#125;&#125; 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 中文乱码问题 get方式：tomcat 8 已经将get方式乱码问题解决了。 post方式：中文或非法数据会乱码。 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(“utf-8”);]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet中的过滤器和监听器：Filter、Listener]]></title>
    <url>%2F2019%2F07%2F12%2FJava%20Web%2FFilter%20Listener%2F</url>
    <content type="text"><![CDATA[Filter（过滤器）概念 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。作用 一般用于完成通用的操作。 如：登录验证、统一编码处理、敏感字符过滤… 快速入门 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 过滤器细节web.xml配置123456789&lt;filter&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;!-- 拦截路径 --&gt;&lt;url-pattern&gt;/-&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码过滤器生命周期方法 init 在服务器启动后，会创建Filter对象，然后调用init方法。 只执行一次。 用于加载资源。 doFilter 每一次请求被拦截资源时，会执行。 执行多次。 destroy 在服务器关闭后，Filter对象被销毁。 如果服务器是正常关闭，则会执行destroy方法。 只执行一次。 用于释放资源。过滤器配置详解拦截路径配置 具体资源路径 /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录 /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截 *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源 /* 访问所有资源时，过滤器都会被执行拦截方式配置 资源被访问的方式 注解配置 设置dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源。 FORWARD：转发访问资源 。 ERROR：错误跳转资源。 ASYNC：异步访问资源。 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置：&lt;filter-mapping&gt;谁定义在上边，谁先执行 Listener（监听器）概念 web的三大组件之一事件监听机制 事件：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码运用 监听ServletContext对象的创建和销毁 ServletContextListener 方法： ServletContext对象被销毁之前会调用该方法 void contextDestroyed(ServletContextEvent sce) ServletContext对象创建后会调用该方法 void contextInitialized(ServletContextEvent sce) 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置1234web.xml&lt;listener&gt;&lt;listener-class&gt;listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解 @WebListener]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行在服务器上的Java程序：Servlet]]></title>
    <url>%2F2019%2F07%2F12%2FJava%20Web%2Fservlet%2F</url>
    <content type="text"><![CDATA[概念 server applet：运行在服务器端的小程序 为了更好的理解servlet，我们先从B/S模式来示例 用户输入账号密码，请求登录 我们需要判断 用户A输入的账号和密码是否正确。 此处需要运用 Java逻辑来判断。 也就是，我们需要通过Java代码来确定。 具体就是，通过Java类来实现。 创建 Java类，判断账号密码 但是，并非所有的Java类都可以在服务器端运行，想要在服务器端运行就必须依赖于服务器端。 换句话说，想要在服务器端运行就要遵循服务器端的”规则“。 而具体来说，在Java中的规则，即是接口。 Servlet就是一个接口 Servlet接口中定义了能被浏览器访问到的，且能被tomcat服务器识别到的Java类的规则。 自定义一个类，实现Servlet接口，复写Servlet接口方法。 快速入门 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 配置web.xml文件，设置虚拟路径 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo 文字输出在服务器端 刷新一次页面，输出一次文字 java文件 123456789101112131415161718192021public class A_ServletDemo implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123;&#125; @Override public ServletConfig getServletConfig() &#123;return null;&#125; /* 提供服务的方法 */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("Hello Servlet!!!"); &#125; @Override public String getServletInfo() &#123;return null;&#125; @Override public void destroy() &#123;&#125; &#125; 在web/WEB-INF目录下，配置web.xml 123456789101112131415&lt;!--配置Servlet --&gt; &lt;!-- name --&gt; &lt;!-- 全类名 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet.A_ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--配置Servlet映射--&gt; &lt;!-- name --&gt; &lt;!-- 虚拟路径 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 执行原理客户端对服务器发出请求 用户通过浏览器对服务器发出请求（ *http: //localhost:8080/web/demo * ） Tomcat服务器接受请求，并开始解析URL路径 web.xml文件 首先，Tomcat服务器通过虚拟路径找到相对应的&lt;url-pattern&gt;标签。 其次，Tomcat服务器通过&lt;url-pattern&gt;标签，获取&lt;servlet-name&gt;标签，以及&lt;servlet-class&gt;标签。 最后，Tomcat服务器通过&lt;servlet-class&gt;标签，获取到Java文件的全类名。 Tomcat服务器将java文件加载进内存（classObj = Class.forName(全类名); ） Tomcat服务器创建Servlet对象（ classObj.instance(); ） Tomcat服务器创建request对象和response对象。 request对象中封装 请求消息数据 response对象中封装 响应消息数据 Tomcat服务器调用service方法，并传入request对象和response对象。 我们通过request对象获取请求消息数据 并通过response对象设置响应消息数据 Tomcat服务器在给浏览器做出响应之前，会从response对象中拿出设置好的响应消息数据。 不同的请求方式GET方式 如果我们要通过GET方式来对Tomcat服务器发送请求，那么我们可以直接访问Tomcat服务器中的GET实现类。 比如，我创建了一个HTTPServlet实现类，但是里面只重写了doGET方法。此时可打开Tomcat服务器，直接通过浏览器访问GET实现类，继而完成在Tomcat服务器中的操作。POST方式 如果我们要通过POST方式来对Tomcat客户端发送请求，那么我们就不可以直接访问Tomcat客户端中的POST实现类。 比如，创建一个HTTPServlet实现类，但是里面只重写了doPOST方法，此时打开Tomcat客户端，但是无法直接通过浏览器访问POST实现类。 不过，可以通过使用POST方法传递的表单来实现。定义一个这样的POST表单，打开Tomcat客户端，访问POST表单，继而完成在Tomcat服务器中的操作。 抽象方法 service 提供服务的方法 只要servlet服务器被访问，service方法就会执行。 *init 初始化的方法 * 无论servlet服务器被访问多少次，init方法只会执行一次。 *destroy 销毁的方法 * 当servlet服务器被正常关闭时，destroy方法会执行一次。 *getServletConfig 获取配置对象的方法 * *getServletInfo 获取servlet信息的方法 * java文件 123456789101112131415161718192021222324252627282930313233/* 初始化方法 */ // 只会执行一次 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println("===init()执行了"); &#125; /* 获取配置对象方法 */ //ServletConfig：配置对象 @Override public ServletConfig getServletConfig() &#123; return null; &#125; /* 提供服务的方法 */ // servlet被访问一次，就执行一次 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("===service()执行了"); &#125; /* 获取servlet信息方法*/ @Override public String getServletInfo() &#123; return null; &#125; /* 销毁方法 */ // servlet正常关闭时，执行一次。 @Override public void destroy() &#123; System.out.println("===destroy&#123;&#125;执行了"); &#125; 生命周期被创建 servlet被创建时会执行init方法，且只执行一次。 修改配置 默认情况下，在servlet服务器第一次被访问时，Servlet被创建。 web.xml文件中，可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 第一次被访问时 创建&lt;load-on-startup&gt;标签，值为负数 在服务器启动时 创建&lt;load-on-startup&gt;标签，值为0或正整数 安全问题 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 所以多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。 提供服务 每次访问Servlet服务器时，Service方法都会被调用一次。 被销毁 Servlet服务器被销毁时执行一次。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 注解 上述情况下，我们发现一个问题，即每次新建文件都需要在web.xml文件中添加虚拟路径。 为了解决这个问题，官方在Servlet3.0版本支持了注解配置，从而代替web.xml文件了。 在web.xml文件，除了需要指定虚拟目录以外，还需要指定文件目录。 而对于注解来说，@WebServlet已经定义在文件中了，所以只需要指定虚拟目录即可。 步骤 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = “/demo3”) *@WebServlet(“/demo3”) * 此处填写的源代码应是”value=’’demo3” “， 如果注解后只写一个属性的话，value可以不写。 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo3 文字输出在服务器端 刷新一次页面，输出一次文字 体系结构 Servlet 接口 GenericServlet 抽象类 （继承） HttpServlet 抽象类（继承） GenericServlet 抽象类 GenericServlet抽象类 将Servlet接口中其他的抽象方法默认空实现，只将service()方法作为抽象方法。 上述情况下，我们仍可以发现一个问题，即创建的实现了servlet接口的Java类中，有许多我们不需要重写的抽象方法。但是大部分情况下我只用需要实现service方法，那我们为什么不能不实现其他方法呢？ 为了解决这个问题，我们可以通过GenericServlet抽象类来完成。 Java类不再是 实现servlet接口 Java类如今是 继承GenericServelet抽象类 HttpServlet 抽象类 HttpServlet抽象类在其父类GenericServlet 抽象类的功能上更进一步。为了可以获取正确的数据，HttpServlet抽象类对请求的方法（get、post）自动进行了判断。 Java类继承 HttpServlet抽象类 复写doGet/doPost方法 相关配置 urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： 目录结构：/xxx 多层目录结构：/xxx/xxx 文件名：*.do]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求消息和响应消息的数据格式]]></title>
    <url>%2F2019%2F07%2F11%2FJava%20Web%2FHTTP%2F</url>
    <content type="text"><![CDATA[概念 HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 传输协议 传输协议定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型 ：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本 HTTP 1.0：每一次请求响应都会建立新的连接，浪费时间，消耗资源。 HTTP 1.1：复用连接。 请求消息数据格式 数据格式 请求消息数据格式 响应消息数据格式 请求消息数据格式请求方式 HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求行 Request method ：请求方式 Request URI ：请求端的URI地址 Http version ：HTTP协议的版本 GET方式 POST方式2 请求头 Accept：指浏览器或其他客户可以接爱的MIME文件格式。 Accept-Encoding：指出浏览器可以接受的编码方式。 Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。 connection：用来告诉服务器是否可以维持固定的HTTP连接。 Cookie：浏览器用这个属性向服务器发送Cookie。 Host：对应网址URL中的Web名称和端口号。 User-Agent：客户浏览器名称。 兼容性问题 Referer：表明产生请求的网页URL。 防盗链 统计工作 Content-Type：用来表名request的内容类型。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1。 GET方式 POST方式 请求空行 空行，用于分割请求头和请求体。请求体 封装POST请求消息的请求参数的 GET方式 POST方式 响应消息数据格式响应行 协议/版本 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1xx 指示信息：表示请求已接收，但没有完成，需要继续处理。 2xx 成功：表示请求已被成功接收、理解、接受。 3xx 重定向：要完成请求必须进行更进一步的操作。 302：重定向 304：访问缓存 4xx 客户端错误：请求有语法错误或请求无法实现。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx 服务器端错误：服务器未能实现合法的请求。 响应头 Content-Type：响应体数据格式以及编码格式 text/html;charset=UTF-8 Content-disposition：打开响应体数据的格式 in-line：在当前页面内打开（默认值） attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行响应体 传输的数据]]></content>
      <categories>
        <category>&lt;b&gt;Java&lt;/b&gt;</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费的开放源代码的Web应用服务器：Tomcat]]></title>
    <url>%2F2019%2F07%2F11%2FJava%20Web%2FTomcat%2F</url>
    <content type="text"><![CDATA[web相关概念回顾软件架构 C/S 客户端/服务器端 B/S 浏览器/服务器端 资源分类 静态资源 所有用户访问后，得到的结果都是一样的。静态资源可以直接被浏览器解析。 如： html，css，JavaScript 动态资源 每个用户访问相同资源后，得到的结果可能不一样。动态资源被访问后，需要先转换为静态资源，再返回给浏览器。 如：servlet/jsp，php，asp 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议 TCP：安全协议，三次握手； 速度稍慢。 UDP：不安全协议；速度快。 web服务器软件 服务器 安装了服务器软件的计算机。 服务器软件 接收用户的请求，处理请求，做出响应。 web服务器软件 在web服务器软件中，部署web项目，让用户通过浏览器来访问项目。 同时，接收用户的请求，处理请求，做出响应。 动态资源依赖于web服务器软件，只能运行在web服务器中。 常见的java相关的web服务器软件 webLogic oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 webSphere IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 Tomcat Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat安装软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格。 卸载 删除目录就行了。 启动： bin/startup.bat 访问 http://localhost:8080 （本地） http://IP地址:8080 （外部） Tomcat目录结构 bin 可执行文件 conf 配置文件 lib 依赖jar包 logs 日志文件 temp 临时文件 webapps web项目 work 运行时的数据 启动软件问题一： 黑窗口一闪而过 解决办法：配置环境变量 假设Tomcat安装路径为：D:\Tomcat\apache-tomcat-8.0.47 打开 [控制面板]–[系统和安全]–[系统]–[计算机名、域和工作组设置]–[更改设置] 在打开的窗口 [系统属性]中，[高级]–[环境变量]–[用户变量]–[新建] 新建变量名：CATALINA_BASE，变量值：D:\Tomcat\apache-tomcat-8.0.47 新建变量名：CATALINA_HOME，变量值：D:\Tomcat\apache-tomcat-8.0.47 打开变量Path，添加变量值：%CATALINA_HOME%\lib 打开变量Path，添加变量值： %CATALINA_HOME%\bin 检验环境变量是否配置成功 第一步，打开命令提示符，输入startup，按回车键，启动tomcat 第二步，打开浏览器，输入http://localhost:8080 ，启动tomcat 问题一：启动报错 解决办法一：结束程序进程 打开命令提示符，输入netstat -ano，获得PID值（进程ID） 打开任务管理器，查看进程，选项显示PID，按照PID值结束程序进程 解决办法二：修改端口号 conf 目录下，找到 server.xml 修改其中的端口号，避免端口冲突。（慎用！） 关于端口号 &lt;Connector port=”8080” protocol=”HTTP/1.1”connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 一般会我们会将tomcat的默认端口号修改为80，端口号80是http协议的默认端口号。这样我们在访问时，就不用输入端口号了。 关闭 正常关闭： 在bin目录下，运行shutdown.bat 在启动的窗口中，按 ctrl+c 强制关闭： 直接关闭启动的窗口 部署web项目 放置项目目录下 直接将项目放置到webapps目录下 项目的访问路径 （虚拟目录）：localhost:8080/web/index.html 简化部署 将项目打成一个war包，再将war包放置到webapps目录下。 放置war包，自动解压缩出文件；删除war包，文件自动删除。 配置文件 在conf 目录下，找到 server.xml 在标签体中配置 &lt;Context docBase=”D:\web” path=”/w” /&gt; docBase:项目存放的路径 path：虚拟目录 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html 创建文件 在conf\Catalina\localhost目录下，创建任意名称的xml文件。 在xml文件中配置 w.xml &lt;Context docBase=”D:\hello” /&gt; 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html web项目目录结构 java动态项目的目录结构 项目的根目录 WEB-INF目录 web.xml web项目的核心配置文件 classes目录 放置字节码文件的目录 lib目录 放置依赖的jar包]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>web服务器</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用于存数数据的可扩展标记语言：XML]]></title>
    <url>%2F2019%2F07%2F10%2FJava%20Web%2FXML%2F</url>
    <content type="text"><![CDATA[概念 XML（ Extensible Markup Language），即 可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 可扩展语言的精华在于其”Extensible”，即 在XML中的标签都是自定义的。 功能存储数据 配置文件 在网络中传输 xml与html的区别 HTML 标签预定义； 语法松散； 功能为展示数据。 XML 标签自定义； 语法严格； 功能为存储数据。 语法基本语法 后缀名 .xml 文档声明 必须在第一行 根标签 有且仅有一个 属性值 必须使用引号(单双都可)引起来 标签 必须正确关闭 标签名称 区分大小写 快速入门1234567891011121314&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分文档声明格式&lt;?xml 属性列表 ?&gt; 属性列表 version：版本号（必须的属性） 一般值：1.0 encoding：编码方式。 告知解析引擎当前文档使用的字符集 默认值：ISO-8859-1 （不支持中文） standalone：是否独立 yes：不依赖其他文件 no：依赖其他文件 指令（结合css） &lt;?xml-stylesheet type=”text/css” href=”a.css” ?&gt; 标签（自定义） 定义规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性属性值唯一 文本 CDATA区（原样展示数据） 格式： &lt;![CDATA[ 数据 ]]&gt; 约束 约束规定了ml文档的书写规则。 DTD约束技术DTD是一种简单的约束技术。我们可以通过dtd文件控制标签和标签的属性，但是对于标签内容的控制我们无能为力。而schema约束技术恰巧弥补了这一缺陷，关于schema约束技术在下一节会详细展开。 外部dtd引入 将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt; 外部dtd：dtd文件 1234567891011121314&lt;!-- ELEMENT元素（定义标签）--&gt; &lt;!-- students标签 （包含student标签 0个或者多个） --&gt;&lt;!ELEMENT students (student*) &gt; &lt;!-- student标签 （包含name标，age标签，sex标签 只能有一个） --&gt;&lt;!ELEMENT student (name,age,sex)&gt; &lt;!-- name标签 （字符串）--&gt;&lt;!ELEMENT name (#PCDATA)&gt; &lt;!-- age标签 （字符串）--&gt;&lt;!ELEMENT age (#PCDATA)&gt; &lt;!-- sex标签 （字符串）--&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!-- ATTLIST元素（定义属性）--&gt; &lt;!-- student标签 number属性 属性类型为ID #并且必需出现 --&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 外部dtd：xml文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 内部引入DTD文档 --&gt;&lt;!DOCTYPE students SYSTEM "student.dtd"&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 内部dtd 引入 将约束规则定义在xml文件中 内部dtd：xml文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 引入DTD文档 --&gt;&lt;!DOCTYPE students [ &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; Schema约束技术Schema是一种复杂的约束技术。它本身是一个xml文档，但文件后缀名以.xsd结尾。 引入实例 schema文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns="http://www.itcast.cn/xml" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itcast.cn/xml" elementFormDefault="qualified"&gt; &lt;!-- element元素 &#123;自定义标签(1):students 自定义类型(1):studentsType&#125; --&gt; &lt;xsd:element name="students" type="studentsType"/&gt; &lt;!-- complexType元素 &#123;自定义类型(1):studentsType&#125; --&gt; &lt;!-- sequence元素（按顺序） --&gt; &lt;!-- element元素 &#123;自定义标签(1-1):student 自定义类型(1-1):studentType 最少出现:0次 最多出现:无限制&#125; --&gt; &lt;xsd:complexType name="studentsType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="student" type="studentType" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;!-- complexType元素 &#123;自定义类型(1-1):studentType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-1):name 基本类型:xsd:string&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-2):age 自定义类型(1-1-2):ageType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-3):sex 自定义类型(1-1-3):sexType&#125; --&gt; &lt;!-- attribute元素 &#123;定义属性:number 自定义类型(1-1-4):numberType #必需&#125; --&gt; &lt;xsd:complexType name="studentType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="name" type="xsd:string"/&gt; &lt;xsd:element name="age" type="ageType" /&gt; &lt;xsd:element name="sex" type="sexType" /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name="number" type="numberType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-2)：sexType &#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 可选值：male --&gt; &lt;!-- 可选值：female --&gt; &lt;xsd:simpleType name="sexType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:enumeration value="male"/&gt; &lt;xsd:enumeration value="female"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-3)：ageType&#125; --&gt; &lt;!-- 基本类型：integer --&gt; &lt;!-- 最小值：0 --&gt; &lt;!-- 最大值：256 --&gt; &lt;xsd:simpleType name="ageType"&gt; &lt;xsd:restriction base="xsd:integer"&gt; &lt;xsd:minInclusive value="0"/&gt; &lt;xsd:maxInclusive value="256"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-4):numberType&#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 格式化：Cat_后跟四个数字 --&gt; &lt;xsd:simpleType name="numberType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:pattern value="Cat_\d&#123;4&#125;"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; xml文件 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. xsi:schemaLocation=”http://www.itcast.cn/xml student.xsd” 为每一个xsd约束声明一个前缀,作为标识 xmlns:xxx=”http://www.itcast.cn/xml&quot; 不写为默认前缀 xmlns=”http://www.itcast.cn/xml&quot; 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;students xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.itcast.cn/xml student.xsd" xmlns="http://www.itcast.cn/xml" &gt; &lt;student number="Cat_0001"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 解析操作xml文档，将文档中的数据读取到内存中。 操作xml文档 解析(读取)：将文档中的数据读取到内存中。 写入：将内存中的数据保存到xml文档中。 解析xml文档DOM DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树。 优点：操作方便，能对文档进行CRUD的所有操作。 缺点：因为形成了DOM树，所以DOM比较占内存，不适用于内存较小的设备。 SAX SAX：基于事件驱动，逐行读取，读取一行释放一行。 优点：不占内存，适用于内存较小的设备。 缺点：只能读取，不能增删改。 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想。但是性能低，基本没有人使用。 DOM4J：一款非常优秀的解析器。 PULL：Android操作系统内置的解析器，支持sax思想。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoupjsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 步骤 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 快速入门1234567891011121314151617181920// 1.导入jar包// 2.根据xml文件，获取Document对象 // * 获取 DTD约束的student.xml文件路径 // * 解析 xml文档，获取DOM树（Document对象）,抛出异常 /* 通过本类的字节码文件，找到类加载器；再通过类加载器，找到文件路径；最后得到文件路径的字符串形式 */ String path = A_Jsoup.class.getClassLoader().getResource("DTD/student.xml").getPath(); Document ducument = Jsoup.parse(new File(path),"utf-8");// 3.获取Element元素对象 name Elements names = ducument.getElementsByTag("name");// 输出所有name元素 System.out.println(names);// 输出第一个name元素 Element name1 = names.get(0); String nameStr1 = name1.text(); System.out.println(nameStr1); 对象Jsoup工具类 获取Document对象 parse(File in, String charsetName)：解析xml、html文件 parse(String html)：解析xml、html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html、xml的文档对象 Java文件：解析html文件 123456789101112131415161718192021 /* 解析xml、html文件 */ String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/test.html").getPath(); Document document = Jsoup.parse(new File(path),"utf-8"); System.out.println(document);/* 解析xml、html字符串 */ Document document2 = Jsoup.parse("&lt;!DOCTYPE html&gt;\n" + "&lt;html lang=\"en\"&gt;\n" + "&lt;head&gt;\n" + " &lt;meta charset=\"UTF-8\"&gt;\n" + " &lt;title&gt;Title&lt;/title&gt;\n" + "&lt;/head&gt;\n" + "&lt;body&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"); System.out.println(document2);/* 通过网络路径获取指定的html、xml的文档对象 */ URL url = new URL("https://www.baidu.com/"); Document document3 = Jsoup.parse( url, 3000); System.out.println(document3); Document文档对象 获取Element对象（任意） getElementById(String id)：根据id属性值，获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称，获取元素对象集合 getElementsByAttribute(String key)：根据属性名称，获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值，获取元素对象集合 html文件 1234567&lt;body&gt; &lt;div id="div1"&gt; &lt;div class="div2" align="left"&gt;&lt;/div&gt; &lt;div class="div2" align="center"&gt;&lt;/div&gt; &lt;div class="div2" align="right"&gt;&lt;/div&gt; &lt;/div&gt; Java文件：解析html文件 123456789101112131415161718String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/C_test.html").getPath();Document document = Jsoup.parse(new File(path),"utf-8");/*根据id属性值，获取唯一的element对象*/ Element id = document.getElementById("div1"); System.out.println(id);/*根据标签名称，获取元素对象集合*/ Elements tag = document.getElementsByTag("div"); System.out.println(tag);/*根据属性名称，获取元素对象集合*/ Elements attribute = document.getElementsByAttribute("align"); System.out.println(attribute);/*根据对应的属性名和属性值，获取元素对象集合*/ Elements attributeValue = document.getElementsByAttributeValue("align", "center"); System.out.println(attributeValue); Elements集合Elements是元素Element对象的集合，相当于一个 ArrayList&lt;Element&gt;。 Element：元素对象 获取Element对象（当前元素的子标签） getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) html文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="attributeValue"&gt; &lt;span&gt;文本内容&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; java文件 1234567891011121314151617181920//获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/D_test.html").getPath();//获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");//获取 Elements对象 Elements tags = document.getElementsByTag("div");//获取 Element对象 Element div = tags.get(0);/* 根据属性名称获取属性值 */ String att = div.attr("id"); System.out.println(att);/* 根据属性名称获取属性值 */ String text = div.text(); System.out.println(text);/* 获取标签体的所有内容(包括字标签的字符串内容) */ String html = div.html(); System.out.println(html); Node：节点对象 Node是Document和Element的父类。 查询快捷查询方式： selector：选择器 XPath：XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。selector 方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 html文件 123456 &lt;div&gt; &lt;div id="div"&gt; &lt;div class="div"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; java文件 1234567891011121314151617181920212223242526272829303132333435// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");/* 选择所有div标签 */ Elements selector1 = document.select("div"); for (Element element : selector1) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的标签*/ Elements selector3 = document.select("#div"); for (Element element : selector3) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有class属性值为div的标签*/ Elements selector2 = document.select(".div"); for (Element element : selector2) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ Elements elements = document.select("div[id='div'] &gt; div"); for (Element element : elements) &#123; System.out.println(element); System.out.println(); &#125; XPath 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 注意：在填写xpath时，引号内不允许有空格。 java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");// 获取 JXDocument对象 JXDocument jxDocument = new JXDocument(document);/* 选择所有div标签 */ List&lt;JXNode&gt; jxNodes = jxDocument.selN("//div"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的div标签 */ List&lt;JXNode&gt; jxNodes2 = jxDocument.selN("//div[@id='div']"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择id属性值的所有值*/ List&lt;JXNode&gt; jxNodes3 = jxDocument.selN("//@id"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的div标签 */ List&lt;JXNode&gt; jxNodes4 = jxDocument.selN("//div/div"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的所有带class属性的div标签 */ List&lt;JXNode&gt; jxNodes5 = jxDocument.selN("//div/div[@class]"); for (JXNode jxNode : jxNodes5) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ List&lt;JXNode&gt; jxNodes6 = jxDocument.selN("//div[@id=div]/div"); for (JXNode jxNode : jxNodes6) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>DTD</tag>
        <tag>Schame</tag>
        <tag>Jsoup</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[目前最受欢迎的前端框架：BootStrap]]></title>
    <url>%2F2019%2F07%2F09%2FJava%20Web%2FBootStrap%2F</url>
    <content type="text"><![CDATA[概念Bootstrap是一个前端开发的框架，来自 Twitter，是目前最受欢迎的前端框架。它基于 HTML、CSS、JavaScript ，具有简洁、直观、强悍的优点，使得 Web 开发更加快捷。 优势 响应式设计，能够自适应于台式机、平板电脑、手机，确保了适当的绘制和触屏缩放，同时可以设置禁止缩放功能，使网站看上去感觉更像原生应用。 包含了功能强大的内置组件（css样式和js插件），我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 快速入门 下载Bootstrap框架Bootstrap官网下载 将Bootstrap框架引入项目直接将解压后的文件复制进项目即可 HTML文件模板任何bootstrap页面都是基于这样的一个模板 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt;&lt;!-- 下面的3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;&lt;!-- Bootstrap --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 响应式布局 响应式布局就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。 响应式布局的实现，依赖于栅格系统。 栅格系统栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 栅格系统，简单来说，就是将页面一行平均分成12个格子，根据不同的终端对元素设定不同的格子。 在PC端每张图片设定占4个格子，那么PC端页面每一行显示3张图片 在平板电脑每张图片设定占6个格子，那么平板电脑端页面每一行只显示2张图片。 在手机端每张图片设定占12个格子，那么手机端页面每一行则只显示1张图片。 步骤 定义容器 container（固定宽度） container-fluid（100% 宽度） 定义行 row 定义元素 col-设备代号-格子数目 设备代号 xs 超小屏幕 手机 (&lt;768px) sm 小屏幕 平板 (≥768px) md 中等屏幕 桌面显示器 (≥992px) lg 大屏幕 大桌面显示器 (≥1200px) 注意 如果设定的格子数目超过12，超出部分自动换行。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 栅格类属性可以向上兼容。 只设定手机端图片占4个格子，那么手机端、平板端和PC端页面每行都显示3张图片。 案例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 定义了div的边框 --&gt; &lt;style&gt; .inner&#123; border: 1px solid #1c7430 ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义容器 --&gt; &lt;div class="container-fluid"&gt; &lt;!-- 定义行 --&gt; &lt;div class="row"&gt; &lt;!-- 定义元素 --&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;CSS样式 按钮 预定样式 12345678910111213&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt; 尺寸 12345678910111213141516&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-lg"&gt;（大按钮）Large button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary"&gt;（默认尺寸）Default button&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-sm"&gt;（小按钮）Small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt; 图片 图片在任意尺寸都占100% 1&lt;img src="..." class="img-responsive" alt="Responsive image"&gt; 图片形状 ​ 123&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt; 表格 表格实例 123&lt;table class="table"&gt; ...&lt;/table&gt; 条纹状表格 123&lt;table class="table table-striped"&gt; ...&lt;/table&gt; 带边框的表格 123&lt;table class="table table-bordered"&gt; ...&lt;/table&gt; 鼠标悬停 123&lt;table class="table table-hover"&gt; ...&lt;/table&gt; 响应式表格12345&lt;div class="table-responsive"&gt;&lt;table class="table"&gt; ...&lt;/table&gt;&lt;/div&gt; 表单 表单实例 123456789101112131415161718192021&lt;form&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt;&lt;/div&gt;&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt;&lt;/div&gt;&lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 水平排列的表单 12345678910111213141516171819202122232425262728 &lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 组件导航条 导航条实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 反色的导航条 123&lt;nav class=&quot;navbar navbar-inverse&quot;&gt; ...&lt;/nav&gt; 分页条 分页条实例 12345678910111213141516171819&lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 插件 Carousel（轮播图） 轮播图实例1234567891011121314151617181920212223242526272829303132333435&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>&lt;b&gt;前端开发&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量标记语言：Markdown]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2FMarkdown%2F</url>
    <content type="text"><![CDATA[*语法手册* 功能 markdown语法 快捷键 转义字符 \ 分割线 -– 标题 # ## ### ctrl + 1~6 斜体 * ctrl + I 粗体 ** ctrl + B 下划线 ctrl + U 删除线 ~~ alt + shift +5 引用 &lt; ctrl + shift + Q 超链接 \ ctrl + K 代码片段 · ctrl + shift + ` 代码块 ··· ctrl + shift + K 图片 [ ]( “”) ctrl + shift + I 有序列表 1. 2. 3. ctrl + shift + [ 无序列表 - + * ctrl + shift + ] 表格 ctrl + T 清除样式 ctrl + \ 源代码模式 ctrl + / 目录 [toc] 脚注 [^ ]: 第1章 标题123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 第2章 字体12345*斜体* **粗体** ***粗斜体*** &lt;u&gt;下划线&lt;/u&gt; ~~删除线~~ 斜体粗体粗斜体下划线 删除线 第3章 引用123&gt;引用 &gt;&gt;引用&gt;&gt;&gt;引用 引用 引用 引用 第4章 超链接1[百度](http://baidu.com &quot;title&quot;) 百度 ​ * 默认在本页面打开 第5章 引用链接12345[百度][id][id]: http://baidu.com &quot;title&quot;[百度][][百度]: http://baidu.com &quot;title&quot; [百度][id][id]: http://baidu.com “title” 百度 第6章 分割线1234-------******** 第7章 代码12代码片段 代码块 代码片段 12&gt; 代码块&gt; 第8章 图片1![panda](http://pvpv3a462.bkt.clouddn.com/StudyNotes/BootStrap/pic01.jpg &apos;&apos;panda&apos;&apos;) 第9章 列表123456789101. 有序 2. 有序3. 有序- 无序- 无序+ 无序+ 无序* 无序* 无序 有序 有序 有序 无序 无序 无序 无序 无序 无序 第10章 任务列表123[] 洗衣服[] 吃饭[] 睡觉 洗衣服 吃饭 睡觉 第11章 表格1234567 姓名 | 技能 | 排行 -- | :--: | --: 刘备 | 哭 | 大哥 关羽 | 打 | 二哥 张飞 | 骂 | 三弟* 左对齐 -- 居中 :--: 右对齐 --: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 第12章 脚注123[^1]:a note at the bottom of the page in a book.This is a footnote[^1] [^1]:a note at the bottom of the page in a book.This is a footnote.[^1] 第13章 表情123:cat::dog::rat: :cat::dog::rat: 第148章 上标下标12H~2~OX^2^ H2OX^2^ 附录Typora官方文档* Markdown链接默认本窗口打开]]></content>
      <categories>
        <category>&lt;b&gt;开发工具&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络06 —— 应用层]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F6.%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络05 —— 运输层]]></title>
    <url>%2F2019%2F06%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F5.%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络03 —— 数据链路层]]></title>
    <url>%2F2019%2F06%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络04 —— 网络层]]></title>
    <url>%2F2019%2F06%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F4.%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络02 —— 物理层]]></title>
    <url>%2F2019%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F2.%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的基本概念物理层：如何在连接计算机的传输媒体（光纤、双绞线、无线）上传输比特流。 物理层的主要任务为：规定传输媒体接口的一些特性： 机械特性：例如接口形状、接口大小、引线数目。 电气特性：例如电压范围（-5V~+5V）。 功能特性：例如-5V表示0，+5V表示1。 过程特性：建立连接时各个相关部件的工作步骤。 数据通信基础数据通信模型​ 网线通过改变电压来模拟数字信号。比如0V表示0,5V表示1。或者-5V表示0，+5V表示1。 常用术语​ 信息：通信的目的是传送信息。 ​ 数据：将信息进行编码后变成数据，再进行传输。 ​ 信号：在通信线路上，数据需要变成电信号或光信号。 ​ 模拟信号：消息参数的取值是连续的。比如：1,2,3,4,5,6,7,8,9…………. 模拟信号在传输过程中如果出现信息干扰，导致波形变化，很难纠正。 ​ 数字信号：消息参数的取值是离散的。 比如：1和0，1,2,3,4,5，1,2,3,4,5,6,7,8。数字信号通过再生中继器可以修复指针的波形。 ​ 模拟信号转换成数字信号： ​ 码元：数字信号波形中的一个基本单位。码元可以携带不同的信息量，比如模拟数字转化图中，图3的一个码元携带了3bit信息，图4的一个码元携带了1bit。 信道​ 信道：信息传输的通道。一条传输介质上可以有多条信道（多路复用）。 ​ 单向通信（单工通信）：信号只能向一个方向传送，并且不能改变传送方向。比如：无线电广播、有线电视广播。 ​ 双向交替通信（半双工通信）：信号可以双向传送，但是必须交替进行，同一时间只能向一个方向传送。比如：对讲机。 ​ 双向同时通信（全双工通信）：信号可以双向传送，并且同时传送。比如：电话、手机。 调制​ 基带信号：来自信源的信号。比如，电台主播发出的声音，网页显示的内容。 ​ 带通信号：将基带信息经过载波调制后的信号。比如：电台发出的电波，网络传输的数据。 ​ 调制分为基带调制和带通调制两大类。 基带调制​ 基带调制（编码）：将一种数字信号转换成另一种数字信号。编码仅对基带信号的波形进行变换，使它能与信道特性相适应，变化后的信号仍然是基带信号。比如，主机中的网页数据转换成显示屏画面。 ​ 单极性归零码：01110表现为 0 01 01 01 0 ​ 双极性归零码：-1111-1表现为 0-10 010 010 010 0-10 ​ 单极性不归零码：01110表现为 0 1 1 1 0 ​ 双极性不归零码：-1111-1表现为 -1 1 1 1 -1 ​ 曼彻斯特编码：低-高表示0，高-低表示1。 ​ 差分曼彻斯特编码：bit-bit之间有信号跳变表示0，bit-bit之间无信号跳变表示1 带通调制​ 带通调制：将数字信号转换成带通信号。通过载波调制，将基带信号的频率范围搬移到较高的频段，以便在信道中传输。比如，将网页的内容转换成数据传输到主机上。 ​ 带通调制的方法： ​ 调幅（AM）：无振幅表示0，有振幅表示1。 ​ 调频（FM）：低频表示0，高频表示1。 ​ 调相（PM）：正弦波表示0，余弦波表示1。 信道极限容量​ 实际的信道带宽一定存在噪声，噪声会使得信号波形发生改变。 ​ 信道带宽 = 最高频率 - 对低频率 奈式准则​ 奈氏准则：在理想条件下，码元传输的速率有上限值，否则就会出现码间串扰问题。​ 理想条件下的极限数据传输率=2Wlog2V（b/s） ;​ W：信道带宽，单位HZ​ V：几种码元/码元的离散电平数目 香农公式​ 信噪比：信号的平均功率S和噪声的平均功率N之比，常记为S/N或SNR，单位为分贝dB。​ SNR=10×log10(S/N)（dB） ​ 香农定理：在带宽受限的有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。​ C=W log2(1+S/N)（b/s或bps） ​ C：信道的极限数据传输速率​ w：带宽，单位HZ​ S/N：信噪比 ​ 香农公式表明 : 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。 香农定理得出的为信道的极限信息传输速率，实际信道能达到的传输速率要比它低不少。 物理层下面的传输媒体导向传输媒体​ 导向传输媒体，指电磁波沿着固体媒体传播。 双绞线 无屏蔽双绞线 UTP：将两根铜线缠绕起来，可以降低两根铜线之间的电磁干扰。 屏蔽双绞线 STP：屏蔽层可以屏蔽外界的电磁干扰。 同轴电缆（有线电视） 50Ω同轴电缆（基带同轴电缆）：用于数字传输，多用于基带传输。 75Ω同轴电缆（宽带同轴电缆）：用于模拟传输，多用于带通传输。 网线​ 不同设备用直通线（T568B-T568B），相同设备交叉线（T568B-T568A）。 光纤​ 优点： 通信容量非常大 传输损耗小，中继距离长。（远距离传输非常经济） 抗雷电和电磁干扰性能好。（在大电流脉冲干扰环境下尤为重要） 无串音干扰，保密性好，不易被窃听或截取数据。 体积小，重量轻。 ​ 单模光纤：使用昂贵的半导体激光器，衰耗较小。 ​ 多模光纤：使用便宜的发光二极管，衰耗较大。 非导向传输媒体非导向传输主要指无线传输 无线电频段 短波通信​ 短波通信即高频通信，主要依靠电离层的内射，通信质量较差。 微波通信​ 微波通信，主要是直线传播，延迟比较大。 物理层设备集线器​ 集线器：只起到信号放大和重发的作用。​ 其目的是扩大网络的传输范围，但不具备信号的定向传送能力。因为集线器只要接受到信号，就会向所有连接到该集线器的网线传送信号。 ​ 并且在集线器传送数据时，其他网线无法传送信号到集线器，所以说集线器是一个大的冲突域。（物理层设备，毫无智商可言） 中继器​ 中继器：中继器对在线路上的信号具有放大再生的功能。用于扩展局域网网段的长度（仅用于连接相同的局域网网段）。 信道复用技术​ 单独使用信道浪费资源。 频分复用 FDM​ 频分复用 ：在带宽中给，每个用户分配一个固定的频带。 频分复用的实现过程： 时分复用 TDM​ 时分复用：将时间划分为一段等长的时分复用帧（TDM帧）。在每一个TDM帧中，给每个用户分配一个固定序号的时隙。 ​ 但是时分复用会造成资源浪费： ​ 于是出现了统计时分复用，在数据上加上了标记： 波分复用​ 波分复用：实际上就是光的频分复用。光使用波长表示，而不是频率表示。 宽带接入技术xDSL​ 铜线宽带接入技术（x Digital Subscriber Line）：也就是数字用户线路的总称，是使用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 ADSL​ 非对称数字用户线路（Asymmetric Digital Subscriber Line）：亦可称作非对称数字用户环路，也是使用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 ​ ADSL 考路了用户访问互联网的主要目的是获取网络资源，所以需要更多的下载流量，较少的上行流量。因此 ADSL 上行下行的带宽被设计成了不对称的形式。 ​ ADSL接入网络的组成： HFC​ 光纤同轴混合网（Hybrid Fiber Coax）：是在覆盖面非常广的有线电视网CATV的基础上开发的一种居民宽带接入网。 ​ HFC接入网络的组成： 光纤接入技术​ 从技术上讲，光纤到户是最好的选择。就是把光纤一直铺设到用户家中，在用户家中才将光信号转换成电信号，这样用户可以得到更高的上网速率。 根据光线到用户的距离来分类： 光纤到小区 FTTZ（Fiber To The Zone） 光纤到路边 FTTC（Fiber To The Curb） 光纤到大楼 FTTB（Fiber To The Building） 光纤到户 FTTH（Fiber To The Home） 光纤到桌面 FTTD（Fiber To The Desk） 移动互联网接入技术​ 移动互联网：就是将移动通信和互联网二者结合起来，成为一体。 ​ 4G IP网络：]]></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络01 —— 概述]]></title>
    <url>%2F2019%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[局域网 互联网 OIS参考模型 应用层：所有产生网络流量的程序。 表示层：在传输之前，数据是否进行压缩或加密处理。处理编码问题。 会话层：当需要传输大量的数据时，数据被分割成许多个数据包，此时数据包需要按照顺序来传输。并且有可能某个程序运行了多个任务，需要不同的数据。所以传输数据的前提是建立了会话。 传输层：可靠传输、流量控制、不可靠传输（一个数据包就能搞定不需要建立会话，比如QQ聊天，查询域名） 网络层：选择最佳路径、规划IP地址。 数据链路层：帧的开始与结束、透明传输、差错校验（校验和） 物理层：接口标准、电器标准、传输速度。 OSI参考模型排错 网络层：配置错误IP地址、子网掩码、网关，路由器没有配置到达目标网络的路由 数据链路层：MAC地址冲突，ADSL欠费，网速协商不一致，计算机连接到错误VLAN 物理层：只接不收，只收不接，网线问题 TCP协议和OSI参考模型 OSI参考模型 实际模型 TCP/IP协议栈 应用层 应用层 HTTP / FTP / DNS 表示层 应用层 HTTP / FTP / DNS 会话层 应用层 HTTP / FTP / DNS 传输层 传输层 TCP / UDP 网络层 网络层 ARP / IP / ICMP / IGMP 数据链路层 数据链路层 ATM / FrameRelay 物理层 物理层 ATM / FrameRelay 数据封装 计算机网络性能指标 速率：联网的主机在数字信道上传送数据位数的速率。 网络运营商标明的4M 单位是 Mbit，应用显示的网速 400k 单位是 KByte。 带宽：数字信道所能传送的最高数据率。 吞吐量：单位时间内通过某个网络的数据量。 时延：发送、传播、处理、排队时延。 光纤的传输速率为：20万/公里，因为光纤利用的是光的全反射，所以光实际走的距离要大于光纤的长度。铜线的传输速率为：23万/公里，比光纤快。但是铜线不支持较高的发送带宽，并且传输损耗较大。 时延带宽积： 等于时延乘以带宽。实际上是指线路上能传输的数据量。 往返时间：从发送方发送数据开始，到发送方收到接收方确认结束。 利用率：信道利用率，等于有数据通过的时间/整个连接时间。网络利用率，等于信道利用率之和。时延随着网络利用率的增加而指数增加。]]></content>
      <categories>
        <category>&lt;b&gt;计算机网络&lt;/b&gt;</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的留言]]></title>
    <url>%2F2000%2F01%2F01%2F%E7%BD%AE%E9%A1%B6%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的博客 ㄟ(≧◇≦)ㄏ 此博客用于不定期地更新一些我总结的学习笔记或者我自己创作的学习资料 (⊙ᗜ⊙) 如果我的博客对你产生了帮助的话，希望你可以留言跟我互动 (^o^)／ 如果我的博客有不足或者时错误的地方，希望你可以指出来凸( •̀_•́ )凸 （评论模块我可是花了不少心思，不要让它孤零零的呀） 标签和分类模块是获取相关博客的最好途径，我也花了不少心思。当然搜索模块更加精准，如果搜索模块还不能让你获取想要的博客，那表示我真的没有写这方面的博客，欢迎你给我留言 ლ ( ◕ ᗜ ◕ ) ლ 另外，由于本博客是通过GitHub搭建的，访问速度极其慢，多多包涵 o(╥﹏╥)o]]></content>
  </entry>
</search>
