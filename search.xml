<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM框架整合（5）——MyBatis框架环境搭建]]></title>
    <url>%2F2019%2F10%2F03%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%885%20MyBatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[MyBatis框架数据库表1234567891011CREATE DATABASE ssm;USE ssm;CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), money DOUBLE(4,2));INSERT INTO account VALUES (NULL,&apos;cat&apos;,9.16),(NULL,&apos;dog&apos;,11.27); 结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） test TestMyBatis（测试类） resources SqlMapConfig.xml（数据库连接配置文件） 数据库连接配置文件方式一jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee314jdbc.username=rootjdbc.password=1234 SqlMapConfig.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 加载 连接数据库的信息 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定 映射文件位置 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 方式二SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///ssm"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入 映射配置文件 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层 采用注解的方式 AccountDao1234567891011121314151617181920package cn.water.dao;import cn.water.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ @Select("select * from account") public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ @Insert("insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)") public abstract void add(Account account);&#125; 测试类TestMyBatis123456789101112131415161718192021222324252627282930313233343536373839package cn.water.test;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; @Test public void run01() throws Exception &#123; /* 加载 配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 建造者对象，获取 工厂对象 */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂对象，获取 Session对象 */ SqlSession sqlSession = sqlSessionFactory.openSession(); /* 通过 Session对象，获取 代理对象 */ AccountDao mapper = sqlSession.getMapper(AccountDao.class); /* 调用 持久层 */ List&lt;Account&gt; all = mapper.findAll(); /* 遍历 */ for (Account account : all) &#123; System.out.println(account); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果12Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（4）——Spring框架 整合 SpringMVC框架]]></title>
    <url>%2F2019%2F09%2F28%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%884%20SpringMVC%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring 整合 SpringMVC结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 监听器 配置 监听器（ContextLoaderListener） 配置 服务器启动时，加载配置文件（contextConfigLocation） 前端控制器 过滤器 web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 监听器 --&gt; &lt;!-- 服务器启动时，加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 前端控制器 --&gt; &lt;!-- 服务器启动时，DispatcherServlet对象被创建，加载SpringMVC配置文件 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 表现层 通过依赖反转获取 业务层对象，并执行业务层的方法，到达Spring与SpringMVC的整合。 AccountController.java123456789101112131415161718192021222324package cn.water.controller;import cn.water.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("accountController")public class AccountController &#123; @Autowired private AccountService service; @RequestMapping("findAll") public String findAll()&#123; /* 表现层 */ System.out.println("表现层：查询所有用户信息"); /* 业务层 */ service.findAll(); return "list"; &#125;&#125; 执行结果点击 index.jsp 页面，执行表现层中的findAll()，和业务层的findAll()，最后跳转到 list.jsp 页面。 12表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（3）——SpringMVC框架环境搭建]]></title>
    <url>%2F2019%2F09%2F27%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%883%20SpringMVC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SpringMVC框架结构目录 java controller AccountController.java（表现层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 前端控制器 配置 前端控制器（DispatcherServlet） 配置 创建前端控制器时，加载配置文件（contextConfigLocation） 配置 服务器启动时，立即创建前端控制器（1） 配置 映射/作用范围（/） 过滤器 配置 过滤器（CharacterEncodingFilter） 配置 编码（UTF-8） 配置 映射/作用范围（/*） web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC配置文件 开启 注解扫描（context：component-scan） 只扫描表现层注解 配置 视图解析器（InternalResourceViewResolver） 配置 前端控制器（mvc：resource） 开启 SpringMVC注解支持（mvc：annotation-driven） springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启 注解扫描 --&gt; &lt;context:component-scan base-package="cn.water.controller"/&gt; &lt;!-- 配置 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 前端控制器 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 开启 SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 表现层AccountController.java 返回：list 12345678910111213141516171819package cn.water.controller;import cn.water.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping("accountController")public class AccountController &#123; @RequestMapping("findAll") public String findAll()&#123; System.out.println("表现层：查询所有用户信息"); return "list"; &#125;&#125; jsp页面index.jsp 执行表现层的方法，获得返回值“/WEB-INF/pages/list.jsp”，跳转页面 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; jsp页面 展示 list.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; #]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（2）——Spring框架环境搭建]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%882%20Spring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring框架结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） test TestSpring.java（测试文件） resources applicationContext.xml（Spring配置文件） Spring配置文件 开启注解扫描 忽略表现层注解 applicationContext.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;/beans&gt; JavaBean对象Accont.java12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 持久层 MyBatis框架生成代理对象，我们不需要创建实现类 AccountDao.java123456789101112131415package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; 业务层AccountService.java123456789101112131415package cn.water.service;import cn.water.domain.Account;import java.util.List;public interface AccountService &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; AccountServiceImp.java1234567891011121314151617181920212223package cn.water.service;import cn.water.domain.Account;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层：查询所有用户"); return null; &#125; /** 添加用户 */ @Override public void add(Account account) &#123; System.out.println("业务层：添加用户"); &#125;&#125; 测试TestSpring.java12345678910111213141516171819package cn.water.test;import cn.water.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void run01() &#123;// 加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");// 获取对象 AccountService as = (AccountService) ac.getBean("accountService");// 调用方法 as.findAll(); &#125;&#125; 运行结果1业务层：查询所有用户]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（6）——Spring框架 整合 MyBatis框架]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%886%20MyBatis%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring 整合 MyBatis结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） Spring配置文件 开启注解扫描 忽略表现层注解 Spring 整合 MyBatis 配置 连接池（ComboPooledDataSource） 配置 SqlSessionFactoryBean 配置 持久层接口的包 Spring 声明式事务管理 配置 事务管理（DataSourceTransactionManager） 配置 事务通知（tx：advice） 配置 AOP增强（aop：config） applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring 整合 MyBatis --&gt; &lt;!-- 配置 连接池 --&gt; &lt;bean id="comboPooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 SqlSessionFactoryBean --&gt; &lt;bean id="sessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 持久层接口的包 --&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.water.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring 声明式事务管理 --&gt; &lt;!-- 配置 事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 查询方法：只读 --&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;!-- --&gt; &lt;tx:method name="*" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置 AOP增强 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.water.service.*SErviceImp.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 业务层 业务层调用持久层 AccountServiceImp.java123456789101112131415161718192021222324252627282930313233package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; @Autowired private AccountDao dao; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; /* 业务层 */ System.out.println("业务层：查询所有用户"); /* 持久层 */ return dao.findAll(); &#125; /** 添加用户 */ @Override public void addAccount(Account account) &#123; /* 业务层 */ System.out.println("业务层：添加用户"); /* 持久层 */ dao.addAccount(account); &#125;&#125; jsp页面index.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt; &lt;form action="accountController/addAccount" method="post"&gt; 姓名：&lt;input type="text" name="name"&gt; 金额：&lt;input type="text" name="money"&gt; &lt;input type="submit" value="保存"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp页面list.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt; &lt;h2&gt;$&#123;accounts&#125;&lt;/h2&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account"&gt; &lt;h3&gt;$&#123;account.id&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.name&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.money&#125;&lt;/h3&gt; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 运行结果页面展示1234567891011121314151617用户信息列表[Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;, Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;, Account&#123;id=3, name=&apos;rat&apos;, money=14.87&#125;, Account&#123;id=4, name=&apos;water&apos;, money=11.11&#125;]1cat9.162dog11.273rat14.874water11.11 控制台1234表现层：查询所有用户信息业务层：添加用户表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM整合</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%880%2F</url>
    <content type="text"><![CDATA[SSM框架整合 SSM框架 Spring框架 SpringMVC框架 SpringMVC框架整合 MyBatis框架 MyBatis框架整合 SSM框架结构目录 java resources log4j.properties（日志文件） pom.xml（Maven项目配置文件） Maven项目配置文件 Spring框架 spring-beans spring-core spring-context spring-context-support spring-aop aspectjweaver spring-org spring-test spring-tx SpringMVC框架 spring-web spring-webmvc 前端 servlet-api jsp-api jstl MyBatis框架 mybatis mybatis-spring 数据库 mysql-connector-java c3p0 日志 log4j slf4j slf4j-log4j12 测试 junit pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 核心（包括spring-core,spring-beans,spring-aop,spring-expression） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将第三方库整合进 Spring 应用上下文 提供支持（如缓存 caching , 邮件mailing , 计划任务scheduling） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP（动态代理 注解） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring 事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JSP标准标签库（EL表达式、JSTL标签） --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis（SSM整合） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; log日志文件 记录日志 log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n Spring框架结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） test TestSpring.java（测试文件） resources applicationContext.xml（Spring配置文件） Spring配置文件 开启注解扫描 忽略表现层注解 applicationContext.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;/beans&gt;` JavaBean对象Accont.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125;` 持久层 MyBatis框架生成代理对象，我们不需要创建实现类 AccountDao.java123456789101112131415161718package cn.water.dao;import cn.water.domain.Account;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125;` 业务层AccountService.java123456789101112131415package cn.water.service;import cn.water.domain.Account;import java.util.List;public interface AccountService &#123; /** 查询所有用户 */ public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ public abstract void add(Account account);&#125; AccountServiceImp.java1234567891011121314151617181920212223package cn.water.service;import cn.water.domain.Account;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层：查询所有用户"); return null; &#125; /** 添加用户 */ @Override public void add(Account account) &#123; System.out.println("业务层：添加用户"); &#125;&#125; 测试TestSpring.java123456789101112131415161718192021package cn.water.test;import cn.water.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void run01() &#123;// 加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");// 获取对象 AccountService as = (AccountService) ac.getBean("accountService");// 调用方法 as.findAll(); &#125;&#125;` 运行结果1业务层：查询所有用户 SpringMVC框架结构目录 java controller AccountController.java（表现层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 前端控制器 配置 前端控制器（DispatcherServlet） 配置 创建前端控制器时，加载配置文件（contextConfigLocation） 配置 服务器启动时，立即创建前端控制器（1） 配置 映射/作用范围（/） 过滤器 配置 过滤器（CharacterEncodingFilter） 配置 编码（UTF-8） 配置 映射/作用范围（/*） web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC配置文件 开启 注解扫描（context：component-scan） 只扫描表现层注解 配置 视图解析器（InternalResourceViewResolver） 配置 前端控制器（mvc：resource） 开启 SpringMVC注解支持（mvc：annotation-driven） springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启 注解扫描 --&gt; &lt;context:component-scan base-package="cn.water.controller"/&gt; &lt;!-- 配置 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 前端控制器 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 开启 SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 表现层AccountController.java 返回：list 12345678910111213141516171819package cn.water.controller;import cn.water.domain.Account;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping("accountController")public class AccountController &#123; @RequestMapping("findAll") public String findAll()&#123; System.out.println("表现层：查询所有用户信息"); return "list"; &#125;&#125; jsp页面index.jsp 执行表现层的方法，获得返回值“/WEB-INF/pages/list.jsp”，跳转页面 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; jsp页面 展示 list.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Spring 整合 SpringMVC结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） web配置文件 监听器 配置 监听器（ContextLoaderListener） 配置 服务器启动时，加载配置文件（contextConfigLocation） 前端控制器 过滤器 web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 监听器 --&gt; &lt;!-- 服务器启动时，加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 前端控制器 --&gt; &lt;!-- 服务器启动时，DispatcherServlet对象被创建，加载SpringMVC配置文件 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 表现层 通过依赖反转获取 业务层对象，并执行业务层的方法，到达Spring与SpringMVC的整合。 AccountController.java123456789101112131415161718192021222324package cn.water.controller;import cn.water.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("accountController")public class AccountController &#123; @Autowired private AccountService service; @RequestMapping("findAll") public String findAll()&#123; /* 表现层 */ System.out.println("表现层：查询所有用户信息"); /* 业务层 */ service.findAll(); return "list"; &#125;&#125; 执行结果点击 index.jsp 页面，执行表现层中的findAll()，和业务层的findAll()，最后跳转到 list.jsp 页面。 12表现层：查询所有用户信息业务层：查询所有用户 MyBatis框架数据库表1234567891011CREATE DATABASE ssm;USE ssm;CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), money DOUBLE(4,2));INSERT INTO account VALUES (NULL,&apos;cat&apos;,9.16),(NULL,&apos;dog&apos;,11.27); 结构目录 java dao AccountDao.java（持久层） domain Account.java（JavaBean对象） test TestMyBatis（测试类） resources SqlMapConfig.xml（数据库连接配置文件） 数据库连接配置文件方式一jdbcConfig.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee314jdbc.username=rootjdbc.password=1234 SqlMapConfig.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 加载 连接数据库的信息 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定 映射文件位置 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 方式二SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///ssm"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 引入 映射配置文件 --&gt; &lt;mappers&gt; &lt;package name="cn.water.dao"/&gt; &lt;!-- &lt;mapper class="cn.water.dao.AccountDao"/&gt; --&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层 采用注解的方式 AccountDao1234567891011121314151617181920package cn.water.dao;import cn.water.domain.Account;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import java.util.List;public interface AccountDao &#123; /** 查询所有用户 */ @Select("select * from account") public abstract List&lt;Account&gt; findAll(); /** 添加用户 */ @Insert("insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)") public abstract void add(Account account);&#125; 测试类TestMyBatis123456789101112131415161718192021222324252627282930313233343536373839package cn.water.test;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; @Test public void run01() throws Exception &#123; /* 加载 配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 通过 建造者对象，获取 工厂对象 */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); /* 通过 工厂对象，获取 Session对象 */ SqlSession sqlSession = sqlSessionFactory.openSession(); /* 通过 Session对象，获取 代理对象 */ AccountDao mapper = sqlSession.getMapper(AccountDao.class); /* 调用 持久层 */ List&lt;Account&gt; all = mapper.findAll(); /* 遍历 */ for (Account account : all) &#123; System.out.println(account); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 运行结果12Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125; Spring 整合 MyBatis结构目录 java controller AccountController.java（表现层） dao AccountDao.java（持久层） domain Account.java（JavaBean对象） service AccountService.java（业务层） AccountServiceImp.java（业务层） resources applicationContext.xml（Spring配置文件） springmvc.xml（SpringMVC配置文件） webapp WEB-INF pages list.jsp（jsp页面文件） web.xml（web配置文件） index.jsp（jsp页面文件） Spring配置文件 开启注解扫描 忽略表现层注解 Spring 整合 MyBatis 配置 连接池（ComboPooledDataSource） 配置 SqlSessionFactoryBean 配置 持久层接口的包 Spring 声明式事务管理 配置 事务管理（DataSourceTransactionManager） 配置 事务通知（tx：advice） 配置 AOP增强（aop：config） applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;!-- 使用Spring框架处理业务层（service）和持久层（dao），不处理表现层（Controller） --&gt; &lt;context:component-scan base-package="cn.water"&gt; &lt;!-- 配置不扫描的注解类 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- Spring 整合 MyBatis --&gt; &lt;!-- 配置 连接池 --&gt; &lt;bean id="comboPooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 SqlSessionFactoryBean --&gt; &lt;bean id="sessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 持久层接口的包 --&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.water.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring 声明式事务管理 --&gt; &lt;!-- 配置 事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 事务通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 查询方法：只读 --&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;!-- --&gt; &lt;tx:method name="*" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置 AOP增强 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.water.service.*SErviceImp.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 业务层 业务层调用持久层 AccountServiceImp.java123456789101112131415161718192021222324252627282930313233package cn.water.service;import cn.water.dao.AccountDao;import cn.water.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Service("accountService")public class AccountServiceImp implements AccountService&#123; @Autowired private AccountDao dao; /** 查询所有用户 */ @Override public List&lt;Account&gt; findAll() &#123; /* 业务层 */ System.out.println("业务层：查询所有用户"); /* 持久层 */ return dao.findAll(); &#125; /** 添加用户 */ @Override public void addAccount(Account account) &#123; /* 业务层 */ System.out.println("业务层：添加用户"); /* 持久层 */ dao.addAccount(account); &#125;&#125; jsp页面index.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="accountController/findAll"&gt;findAll&lt;/a&gt;&lt;/h3&gt; &lt;form action="accountController/addAccount" method="post"&gt; 姓名：&lt;input type="text" name="name"&gt; 金额：&lt;input type="text" name="money"&gt; &lt;input type="submit" value="保存"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp页面list.jsp1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户信息列表&lt;/h1&gt; &lt;h2&gt;$&#123;accounts&#125;&lt;/h2&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account"&gt; &lt;h3&gt;$&#123;account.id&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.name&#125;&lt;/h3&gt; &lt;h3&gt;$&#123;account.money&#125;&lt;/h3&gt; &lt;br&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 运行结果页面展示1234567891011121314151617用户信息列表[Account&#123;id=1, name=&apos;cat&apos;, money=9.16&#125;, Account&#123;id=2, name=&apos;dog&apos;, money=11.27&#125;, Account&#123;id=3, name=&apos;rat&apos;, money=14.87&#125;, Account&#123;id=4, name=&apos;water&apos;, money=11.11&#125;]1cat9.162dog11.273rat14.874water11.11 控制台1234表现层：查询所有用户信息业务层：添加用户表现层：查询所有用户信息业务层：查询所有用户]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合（1）——SSM框架环境搭建]]></title>
    <url>%2F2019%2F09%2F25%2FSSM%E6%A1%86%E6%9E%B6%2FSSM%E6%95%B4%E5%90%88%2FSSM%E6%95%B4%E5%90%881%20SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[SSM框架整合结构目录 java resources log4j.properties（日志文件） pom.xml（Maven项目配置文件） Maven项目配置文件 Spring框架 spring-beans spring-core spring-context spring-context-support spring-aop aspectjweaver spring-org spring-test spring-tx SpringMVC框架 spring-web spring-webmvc 前端 servlet-api jsp-api jstl MyBatis框架 mybatis mybatis-spring 数据库 mysql-connector-java c3p0 日志 log4j slf4j slf4j-log4j12 测试 junit pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 核心（包括spring-core,spring-beans,spring-aop,spring-expression） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将第三方库整合进 Spring 应用上下文 提供支持（如缓存 caching , 邮件mailing , 计划任务scheduling） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP（动态代理 注解） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring 事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JSP标准标签库（EL表达式、JSTL标签） --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis（SSM整合） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; log日志文件 记录日志 log4j.properties123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 异常处理]]></title>
    <url>%2F2019%2F09%2F22%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%207%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目结构 java controller InterceptorController.java（Java文件） interceptor TestInterceptor01.java（JavaBean文件） TestInterceptor02.java（JavaBean文件） TestInterceptor03.java（JavaBean文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） error.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置拦截器（&lt;mvc:interceptors&gt;） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 执行代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section05_Interceptor&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section05_Interceptor Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section05_Interceptor&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/*"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor03"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;!-- 设置不拦截的方法 --&gt; &lt;!-- &lt;mvc:exclude-mapping path="/**"/&gt;--&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; InterceptorController.java12345678910111213141516171819202122232425package cn.water.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @author Water * @date 2019/10/3 - 20:51 */@Controller@RequestMapping("/Interceptor")public class InterceptorController &#123; @RequestMapping("/test01") public String test01()&#123; System.out.println("Controller01..."); return "success"; &#125; @RequestMapping("/test02") public String test02()&#123; System.out.println("Controller02..."); return "success"; &#125;&#125; TestInterceptor01.java123456789101112131415161718192021222324252627282930313233343536package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor01 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ /* true：放行。（执行下一个拦截器，或者执行Controller方法） * false：不放行。（通过Request和Response跳转） * */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125;&#125; TestInterceptor02.java123456789101112131415161718192021222324252627282930313233package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor02 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125;&#125; TestInterceptor03.java12345678910111213141516171819202122232425262728293031323334package cn.water.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water * @date 2019/10/3 - 20:57 */public class TestInterceptor03 implements HandlerInterceptor &#123; /* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("--preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("--postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("--afterCompletion"); System.out.println("-----------------"); &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="Interceptor/test01"&gt;拦截器放行&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="Interceptor/test02"&gt;拦截器不放行&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;访问成功！！！&lt;/h1&gt; &lt;% System.out.println("success.jsp..."); %&gt;&lt;/body&gt;&lt;/html&gt; error.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;访问失败！！！&lt;/h2&gt; &lt;% System.out.println("error.jsp..."); %&gt;&lt;/body&gt;&lt;/html&gt; 拦截器——放行 配置拦截器 12345678&lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; Controller的方法 12345@RequestMapping("/test01")public String test01()&#123; System.out.println("Controller01..."); return "success";&#125; 运行结果 12345----preHandle...Controller01...----postHandle...success.jsp...----afterCompletion 拦截器——不放行 配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; Controller的方法 12345@RequestMapping("/test02")public String test02()&#123; System.out.println("Controller02..."); return "success";&#125; 运行结果 1error.jsp... 多个拦截器 配置拦截器 123456789101112131415161718192021222324&lt;!-- 配置拦截器（拦截器执行的顺序按照排列顺序来） --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/*"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor03"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test01"/&gt; &lt;!-- &lt;mvc:mapping path="/**"/&gt; --&gt; &lt;!-- 设置不拦截的方法 --&gt; &lt;!-- &lt;mvc:exclude-mapping path="/**"/&gt;--&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 设置拦截的方法 --&gt; &lt;mvc:mapping path="/Interceptor/test02"/&gt; &lt;!-- 配置拦截器对象 --&gt; &lt;bean class="cn.water.interceptor.TestInterceptor02"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器的方法 12345678910111213141516171819/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("--preHandle..."); return true;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("--postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("--afterCompletion"); System.out.println("-----------------");&#125; 放行 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("----preHandle..."); return true; &#125; /* 后处理（Controller方法后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle..."); &#125; /* 终处理（jsp页面跳转后） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion"); &#125; 运行结果 123456789====preHandle...----preHandle...Controller01...----postHandle...====postHandle...success.jsp...----afterCompletion====afterCompletion=================== 不放行 拦截器的方法 123456789101112131415161718/* 预处理（Controller方法前） */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; request.getRequestDispatcher("/WEB-INF/pages/error.jsp" ).forward(request,response); return false;&#125;/* 后处理（Controller方法后） */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("----postHandle...");&#125;/* 终处理（jsp页面跳转后） */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("----afterCompletion");&#125; 运行结果 1234====preHandle...error.jsp...====afterCompletion===================]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 异常处理]]></title>
    <url>%2F2019%2F09%2F20%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%206%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[项目结构 java controller TestException.java（Java文件） exception ExceptionController.java（Java文件） TestExceptionResolver.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages error.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置异常处理器（TestExceptionResolver） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 执行代码 需求：在index.jsp页面，点击的超链接，跳转到error.jsp页面，并且在页面输出响应消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section04_Exception&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section04_Exception Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section04_Exception&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置异常处理器 --&gt; &lt;bean id="testExceptionResolver" class="cn.water.exception.TestExceptionResolver"&gt;&lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; ExceptionController.java1234567891011121314151617181920212223242526272829package cn.water.controller;import cn.water.exception.TestException;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * @author Water 自定义异常类 * @date 2019/10/3 - 19:47 */@Controller@RequestMapping("/exception")public class ExceptionController &#123; @RequestMapping("/test01") public String test01() throws TestException&#123; System.out.println("方法执行了"); try &#123; int error = 10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new TestException("出现TestException错误！"); &#125; return "success"; &#125;&#125; index.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="exception/test01/"&gt;异常处理&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; error.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;$&#123;errorMessage&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 异常处理 当Controller类出现异常时 123456789101112@RequestMapping("/test01") public String test01() throws TestException&#123; System.out.println("方法执行了"); try &#123; int error = 10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new TestException("出现TestException错误！"); &#125; return "success"; &#125; 自定义异常类 12345678910111213141516171819202122package cn.water.exception;public class TestException extends Exception &#123; /* 存储提示信息 */ private String message; /* Getter */ @Override public String getMessage() &#123; return message; &#125; /* Setter */ public void setMessage(String message) &#123; this.message = message; &#125; /* 构造方法（提供提示信息） */ public TestException(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器 123456789101112131415161718192021222324252627282930313233343536package cn.water.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Water 自定义异常处理器 * @date 2019/10/3 - 20:01 */public class TestExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; /* 判断异常对象 */ TestException te = null; if (e instanceof TestException) &#123; te = (TestException)e; &#125;else &#123; te = new TestException("出现未知错误！"); &#125; /* 创建ModelAndView对象 */ ModelAndView mv = new ModelAndView(); /* 存储键值对 */ mv.addObject("errorMessage", te.getMessage()); /* 跳转到 error.jsp 页面 */ mv.setViewName("error"); /* 返回 */ return mv; &#125;&#125; 配置异常处理器 12 &lt;!-- 配置异常处理器 --&gt;&lt;bean id="testExceptionResolver" class="cn.water.exception.TestExceptionResolver"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 文件上传]]></title>
    <url>%2F2019%2F09%2F15%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%205%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[项目结构（文件服务器） webapp uploads（图片存储位置） WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） 项目结构（应用服务器） java controller FileUploadController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api commons-fileupload commons-io jersey-core jersey-client web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） HttpServletRequest MultipartFile JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：通过服务器将图片上传至服务器端 在“应用服务器”中，上传图片。图片通过跨服务器操作，被存储到“文件服务器”中。 “文件服务器”只需要新建一个模板，并且配置一个tomcat服务器，在此需求中其配置文件不需要设置。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section03_FileUpload&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section03_FileUpload Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 跨服务器上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section03_FileUpload&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建DispatcherServlet --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建DispatcherServlet时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件解析器 --&gt; &lt;!-- 此id必须为multipartResolver --&gt; &lt;!-- 配置了文件解析器后，通过commons-fileupload组件的方法可以访问，无法上传。 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 配置上传文件字节数的最大值 --&gt; &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; FileUploadController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package cn.water.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;@Controller@RequestMapping("/fileUpload")public class FileUploadController &#123; /* 传统方式：通过 commons-fileupload组件 解析消息正文 */ @RequestMapping("/test01") public String testFileUpload(HttpServletRequest request,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 解析消息正文，获取上传文件项 */ DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List&lt;FileItem&gt; fileItems = upload.parseRequest(request); /* 判断是否为上传文件项 */ for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField())&#123; /* 表单项 */ &#125;else &#123; /* 上传文件项 */ /* 设置唯一的文件名称 */ String name = fileItem.getName(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ fileItem.write(new File(realPath,name)); /* 删除临时文件 */ fileItem.delete(); &#125; &#125; return "success"; &#125; /* SpringMVC传统方法：文件解析器来解析，我们只需要获取 MultipartFile对象 */ @RequestMapping("/test02") public String test02( HttpServletRequest request, MultipartFile picture,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 设置唯一的文件名称 */ String name = picture.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ picture.transferTo(new File(file,name)); return "success"; &#125; /* SpringMVC跨服务器上传 */ @RequestMapping("/test03") public String test03(MultipartFile picture,String picname) throws Exception &#123; /* 定义上传文件服务器的路径 */ String path = "http://localhost:9090/uploads/"; /* 设置唯一的文件名称 */ System.out.println(picture); String name = picture.getOriginalFilename();// String uuid = UUID.randomUUID().toString().replace("-", "");// name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(path); System.out.println(name); /* 创建客服端对象 */ Client client = Client.create(); /* 和图片服务器进行连接 */ WebResource resource = client.resource(path + name); /* 上传文件 */ resource.put(picture.getBytes()); return "success"; &#125;&#125; index.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;文件上传&lt;/h1&gt; &lt;hr&gt; &lt;h2&gt;传统方式：通过 commons-fileupload组件&lt;/h2&gt; &lt;form action="fileUpload/test01" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt; &lt;h2&gt;SpringMVC传统方法：文件解析器&lt;/h2&gt; &lt;form action="fileUpload/test02" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;%-- 和Controller中方法的MultipartFile参数的名称必须一致 --%&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt; &lt;h2&gt;SpringMVC跨服务器方法&lt;/h2&gt; &lt;form action="fileUpload/test03" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"&gt; &lt;br&gt; 选择图片：&lt;input type="file" name="picture"&gt; &lt;br&gt; &lt;%-- 和Controller中方法的MultipartFile参数的名称必须一致 --%&gt; &lt;input type="submit" value="上传文件"&gt; &lt;/form&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;访问成功！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 传统方式 传统的文件上传方式通过 commons-fileupload组件 maven配置文件 12345678910&lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; Controller 123456789101112131415161718192021222324252627282930313233@RequestMapping("/test01") public String testFileUpload(HttpServletRequest request,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 解析消息正文，获取上传文件项 */ DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List&lt;FileItem&gt; fileItems = upload.parseRequest(request); /* 判断是否为上传文件项 */ for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField())&#123; /* 表单项 */ &#125;else &#123; /* 上传文件项 */ /* 设置唯一的文件名称 */ String name = fileItem.getName(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ fileItem.write(new File(realPath,name)); /* 删除临时文件 */ fileItem.delete(); &#125; &#125; return "success"; &#125; SpringMVC方式 文件解析器来解析，我们只需要获取 MultipartFile对象 SpringMVC配置文件 1234567&lt;!-- 文件解析器 --&gt; &lt;!-- 此id必须为multipartResolver --&gt; &lt;!-- 配置了文件解析器后，通过commons-fileupload组件的方法可以访问，无法上传。 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 配置上传文件字节数的最大值 --&gt; &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt;&lt;/bean&gt; Controller 12345678910111213141516171819@RequestMapping("/test02")public String test02( HttpServletRequest request, MultipartFile picture,String picname) throws Exception &#123; /* 设置 文件上传的位置 */ String realPath = request.getSession().getServletContext().getRealPath("/uploads/"); System.out.println(realPath); /* 创建 文件夹 */ File file = new File(realPath); if (!file.exists())&#123; file.mkdirs(); &#125; /* 设置唯一的文件名称 */ String name = picture.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace("-", ""); name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(name); /* 在指定位置创建文件 */ picture.transferTo(new File(file,name)); return "success";&#125; 跨服务器上传 Maven配置文件 12345678910&lt;!-- 解析请求正文内容（Form表单的enctype属性取值为Mutilpart/form-date时） --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; SpringMVC配置文件 1234567891011&lt;!-- 跨服务器上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; Controller 1234567891011121314151617181920212223 @RequestMapping("/test03") public String test03(MultipartFile picture,String picname) throws Exception &#123; /* 定义上传文件服务器的路径 */ String path = "http://localhost:9090/uploads/"; /* 设置唯一的文件名称 */ System.out.println(picture); String name = picture.getOriginalFilename();// String uuid = UUID.randomUUID().toString().replace("-", "");// name = uuid +"_"+ picname +"_"+ name; // 唯一标识码 + 输入的名称 + 文件本身名称 System.out.println(path); System.out.println(name); /* 创建客服端对象 */ Client client = Client.create(); /* 和图片服务器进行连接 */ WebResource resource = client.resource(path + name); /* 上传文件 */ resource.put(picture.getBytes()); return "success"; &#125; tomcat配置文件 （D:\coding\Tomcat\apache-tomcat-8.5.45\conf\web.xml）123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 响应数据类型]]></title>
    <url>%2F2019%2F09%2F10%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%204%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[项目结构 java controller ResponseController.java（Java文件） domain User.java（JavaBean文件） resources springmvc.xml（springmvc配置文件） webapp css images js jquery.min.js（js文档） WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） jquery.jsp（web页面） response.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api jackson-databind jackson-core jackson-annotations web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置前端控制器（&lt;mvc:resource &gt;） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） HttpServletRequest：获取Request、Session，用于请求转发、获取Request URI HttpServletResponse：获取Response，用于重定向、设置中文乱码 JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在response.jsp页面，点击的超链接，跳转到success.jsp页面，并且在页面输出响应消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section02_Response&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section02_Response Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Jackson：用于Ajax异步请求，将Json类型数据转化为JavaBean类型 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section02_Response&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 前端控制器（设置免拦截的静态资源） --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"&gt;&lt;/mvc:resources&gt; &lt;!-- js --&gt; &lt;mvc:resources mapping="/images/**" location="/images/"&gt;&lt;/mvc:resources&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources mapping="/css/**" location="/css/"&gt;&lt;/mvc:resources&gt; &lt;!-- 样式 --&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; ResponseController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package cn.water.controller;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author Water * @date 2019/9/11 - 20:16 */@Controller@RequestMapping("/response")public class ResponseController &#123; /* 【返回值：String】 */ @RequestMapping("/testString") public String testString(Model model)&#123;// 获取用户对象 User user = new User(); user.setUsername("cat"); user.setPassword("111"); user.setAge(1);// 将用户对象添加至Request域中 model.addAttribute("user",user); return "success"; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid111") public void testVoid111(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 请求转发（不执行视图解析器） request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); return; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid222") public void testVoid222(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 重定向（不执行视图解析器，不能访问WEB-INF目录下页面） response.sendRedirect(request.getContextPath()+"/index.jsp"); return; &#125; /* 【返回值：void】 */ @RequestMapping("/testVoid333") public void testVoid333(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 设置中文乱码 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charaset=UTF-8");// 直接响应 response.getWriter().print("你好呀！"); return; &#125; /* 【返回值：ModelAndView】 */ @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response)&#123;// 获取对象 ModelAndView modelAndView = new ModelAndView();// 获取用户对象 User user = new User(); user.setUsername("dog"); user.setPassword("222"); user.setAge(2);// 将用户对象添加至Request域中 modelAndView.addObject("user",user);// 设置跳转页面（执行视图解析器） modelAndView.setViewName("success"); return modelAndView; &#125; /* 【关键字】 */ @RequestMapping("/testForward") public String testForward()&#123; System.out.println("forward"); return "forward:/WEB-INF/pages/success.jsp"; &#125; /* 【关键字】 */ @RequestMapping("/testRedirect") public String testRedirect(HttpServletRequest request)&#123; System.out.println("redirect"); String contextPath = request.getContextPath(); /* 原本我们是要加上项目路径，但是SpringMVC框架帮我们自动添加了，所以我们只需要填写文件名 */// return "redirect:"+contextPath+"/index.jsp"; return "redirect:/index.jsp"; &#125; /* 【Ajax异步请求】 */ @RequestMapping("/testAjax") public @ResponseBody User testAjax( @RequestBody User user)&#123; /* 获取网页发送的数据 */ System.out.println("用户对象："+user); /* 设置数据 */ user.setUsername("dog"); user.setPassword("222"); user.setAge(2); /* 将数据返回给网页 */ return user; &#125;&#125; User.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.domain;/** * @author Water * @date 2019/9/11 - 20:19 */public class User &#123; private String username; private String password; private Integer age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="response.jsp"&gt;响应消息页面&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a href="jquery.jsp"&gt;静态资源页面&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; response.jsp1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;%-- 引入js资源 --%&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; /* 绑定单击事件 */ $("#btn1").click(function () &#123; &lt;%-- 【发送Ajax请求】 --%&gt; $.ajax(&#123; url:"response/testAjax", /* 发送请求的地址 */ contentType:"application/json;charset=UTF-8", /* 发送信息至服务器时内容编码类型 */ data:'&#123;"username":"cat","password":"111","age":"1"&#125;', /* 发送到服务器的数据 */ dataType:"json", /* 预期服务器返回的数据类型 */ type:"post", /* 请求方式 */ success:function (data) &#123; document.write("&lt;h3&gt;"+data+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.username+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.password+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.age+"&lt;/h3&gt;"); &#125; /* 请求成功后的回调函数 */ &#125;) &#125;) /* 绑定单击事件 */ $("#btn2").click(function () &#123; &lt;%-- 【弹出提示信息】 --%&gt; alert("hello,Ajax."); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn2"&gt;弹出提示信息&lt;/button&gt; &lt;button id="btn1"&gt;发送Ajax请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jquery.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;&lt;a href="response/testString"&gt;String&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid111"&gt;void：请求转发&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid222"&gt;void：重定向&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testVoid333"&gt;void：直接响应&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testModelAndView"&gt;ModelAndView&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testForward"&gt;Forward&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href="response/testRedirect"&gt;Redirect&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功访问！！！&lt;/h1&gt; &lt;br&gt; &lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt; &lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;%-- requestScope可以省略 --%&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt; &lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 方法返回值：String 发起请求 1&lt;a href="response/testString"&gt;String&lt;/a&gt; 接收请求，发出响应 1234567891011 @RequestMapping("/testString") public String testString(Model model)&#123;// 获取用户对象 User user = new User(); user.setUsername("cat"); user.setPassword("111"); user.setAge(1);// 将用户对象添加至Request域中 model.addAttribute("user",user); return "success"; &#125; 响应页面 1234567&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：User&#123;username=&apos;cat&apos;, password=&apos;111&apos;, age=1&#125;获取用户名：cat获取密码：111获取年龄：1 方法返回值：void请求转发 发起请求 1&lt;a href="response/testVoid111"&gt;void：请求转发&lt;/a&gt; 接收请求，发起响应 123456 @RequestMapping("/testVoid111") public void testVoid111(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 请求转发（不执行视图解析器） request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); return; &#125; 响应结果 123456成功访问！！！获取Request域中的用户对象：获取用户名：获取密码：获取年龄： 重定向 发起请求 1&lt;a href="response/testVoid222"&gt;void：重定向&lt;/a&gt; 接收请求，发出响应 123456 @RequestMapping("/testVoid222") public void testVoid222(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;// 重定向（不执行视图解析器，不能访问WEB-INF目录下页面） response.sendRedirect(request.getContextPath()+"/index.jsp"); return; &#125; 响应结果 12响应消息页面静态资源页面 直接响应 发起请求 1&lt;a href="response/testVoid333"&gt;void：直接响应&lt;/a&gt; 接收请求 123456789 @RequestMapping("/testVoid333") public void testVoid333( HttpServletResponse response) throws IOException &#123;// 设置中文乱码 response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charaset=UTF-8");// 直接响应 response.getWriter().print("你好呀！"); return; &#125; 响应结果 1你好呀！ ModelAndView 发起请求 1&lt;a href="response/testModelAndView"&gt;ModelAndView&lt;/a&gt; 接收请求，发出响应 123456789101112131415 @RequestMapping("/testModelAndView") public ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response)&#123;// 获取对象 ModelAndView modelAndView = new ModelAndView();// 获取用户对象 User user = new User(); user.setUsername("dog"); user.setPassword("222"); user.setAge(2);// 将用户对象添加至Request域中 modelAndView.addObject("user",user);// 设置跳转页面（执行视图解析器） modelAndView.setViewName("success"); return modelAndView; &#125; 响应页面 1234567&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：User&#123;username=&apos;dog&apos;, password=&apos;222&apos;, age=2&#125;获取用户名：dog获取密码：222获取年龄：2 Spring框架关键字Forward 发起请求 1&lt;a href="response/testForward"&gt;Forward&lt;/a&gt; 接收请求，发出响应 12345@RequestMapping("/testForward")public String testForward()&#123; System.out.println("forward"); return "forward:/WEB-INF/pages/success.jsp";&#125; 响应页面 123456&lt;h1&gt;成功访问！！！&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;获取Request域中的用户对象：$&#123;requestScope.user&#125; &lt;/h3&gt;&lt;h3&gt;获取用户名：$&#123;user.username&#125; &lt;/h3&gt; &lt;%-- requestScope可以省略 --%&gt;&lt;h3&gt;获取密码：$&#123;user.password&#125; &lt;/h3&gt;&lt;h3&gt;获取年龄：$&#123;user.age&#125; &lt;/h3&gt; 响应结果 123456成功访问！！！获取Request域中的用户对象：获取用户名：获取密码：获取年龄： Redirect 发起请求 1&lt;a href="response/testRedirect"&gt;Redirect&lt;/a&gt; 接收请求，发出响应 12345678@RequestMapping("/testRedirect")public String testRedirect(HttpServletRequest request)&#123; System.out.println("redirect"); String contextPath = request.getContextPath(); /* 原本我们是要加上项目路径，但是SpringMVC框架帮我们自动添加了，所以我们只需要填写文件名 */ // return "redirect:"+contextPath+"/index.jsp"; return "redirect:/index.jsp";&#125; 响应结果 12响应消息页面静态资源页面 Ajax 异步请求 发起请求 123456789101112131415161718192021222324252627282930&lt;script&gt; $(function () &#123; /* 绑定单击事件 */ $("#btn1").click(function () &#123; &lt;%-- 【发送Ajax请求】 --%&gt; $.ajax(&#123; /* 发送请求的地址 */ url:"response/testAjax", /* 发送信息至服务器时内容编码类型 */ contentType:"application/json;charset=UTF-8", /* 发送到服务器的数据 */ data:'&#123;"username":"cat","password":"111","age":"1"&#125;', /* 预期服务器返回的数据类型 */ dataType:"json", /* 请求方式 */ type:"post", /* 请求成功后的回调函数 */ success:function (data) &#123; document.write("&lt;h3&gt;"+data+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.username+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.password+"&lt;/h3&gt;"); document.write("&lt;h3&gt;"+data.age+"&lt;/h3&gt;"); &#125; &#125;) &#125;) &#125;)&lt;/script&gt;&lt;body&gt; &lt;button id="btn1"&gt;发送Ajax请求&lt;/button&gt;&lt;/body&gt; 接收请求，发出响应 1234567891011@RequestMapping("/testAjax")public @ResponseBody User testAjax( @RequestBody User user)&#123; /* 获取网页发送的数据 */ System.out.println("用户对象："+user); /* 设置数据 */ user.setUsername("dog"); user.setPassword("222"); user.setAge(2); /* 将数据返回给网页 */ return user;&#125; 响应结果 1234[object Object]dog2222]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 参数绑定]]></title>
    <url>%2F2019%2F09%2F07%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%203%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[项目结构 java controller SessionController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） session.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） annotation.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 设置Session域的键值对（@SessionAttributes()） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） Model：用于存储键值对至Request域 ModelMap：用于获取Request域中的键值对 SessionStatus：用于清空Session域中的键值对 设置初始化方法（@ModelAttribute） 方法参数 获取请求参数（@RequestParam()） 二级目录：”/testRequestParam” 请求地址：”anno/testRequestParam?name=cat” 获取请求参数（@PathVariable()） 二级目录：”/testPathVariable/{name}” 请求地址：”anno/testPathVariable/cat” 获取请求体（@RequestBody） 获取请求头（@RequestHeader） 获取缓存（@CookieValue()） 获取底层Map集合的键值对（@ModelAttribute()） 设置Session域的键值对（@SessionAttributes()） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在annotation.jsp页面，点击的超链接，跳转到success.jsp页面，并且在控制台输出请求消息。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; AnnotationController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.water.controller;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.*;import org.springframework.web.bind.support.SessionStatus;import java.util.Map;/** * @author Water * @date 2019/9/10 - 10:48 */@Controller@RequestMapping("/anno")/* 将键值对存储到session域 */@SessionAttributes("message")public class AnnotationController &#123; /* 【获取请求参数】 */ @RequestMapping("/testRequestParam") public String testRequestParam(@RequestParam(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success"; &#125; /* 【获取请求参数】 */ @RequestMapping("/testPathVariable/&#123;name&#125;") public String testPathVariable(@PathVariable(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success"; &#125; /* 【获取请求体（GET请求方式没有请求体）】 */ @RequestMapping("/testRequestBody") public String testRequestBody(@RequestBody String body )&#123; System.out.println("请求体："+body); return "success"; &#125; /* 【获取请求头】 */ @RequestMapping("/testRequestHeader") public String testRequestHeader(@RequestHeader(value = "Accept") String header )&#123; System.out.println("请求头："+header); return "success"; &#125; /* 【Cookie】 */ @RequestMapping("/testCookieValue") public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue )&#123; System.out.println("Cookie："+cookieValue); return "success"; &#125; /* 【ModelAttribute】 */ /* 用于将表单提交的数据封装至JavaBean对象时，当时当数据不全时，使用ModelAttribute注释的方法将数据补全 */// [方法一]// @RequestMapping("/testModelAttribute")// public String testModelAttribute(User user)&#123;// System.out.println("testModelAttribute执行了...");// System.out.println(user);// return "success";// &#125;// @ModelAttribute /* 先执行 */// public User ModelAttributeMethod(String name)&#123;// System.out.println("ModelAttributeMethod执行了...");// User user = new User();// user.setName(name);// user.setAge("11");// return user;// &#125;// [方法二] @RequestMapping("/testModelAttribute") public String testModelAttribute(@ModelAttribute("user_name") User user)&#123; System.out.println("testModelAttribute执行了..."); System.out.println(user); return "success"; &#125; /* 将User对象存储进底层的Map集合中 */ @ModelAttribute /* 先执行 */ public void ModelAttributeMethod(String username, Map&lt;String,User&gt; map)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(username); user.setAge("11"); map.put("user_name",user); &#125; @RequestMapping("testSessionAttributes") public String testSessionAttributes(Model model)&#123; /* 将键值对存储到request域 */ model.addAttribute("message","Hello,Request Field!"); return "session"; &#125; @RequestMapping("getSessionAttributes") public String getSessionAttributes(ModelMap modelMap)&#123; /* 获取Session域中的值 */ Object message = modelMap.get("message"); System.out.println(message); return "session"; &#125; @RequestMapping("removeSessionAttributes") public String removeSessionAttributes(SessionStatus sessionStatus)&#123; /* 清空Session域中的值 */ sessionStatus.setComplete(); return "session"; &#125;&#125; index.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="controller/sayHello?username=cat"&gt;入门&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="parameters.jsp"&gt;参数绑定&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="annotation.jsp"&gt;注解&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; annotation.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%-- Created by IntelliJ IDEA. User: Water Date: 2019/9/19 Time: 14:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 请求参数 --%&gt; &lt;h3&gt;&lt;a href="anno/testRequestParam?name=cat&amp;name=dog&amp;name=rat"&gt;获取 请求参数（RequestParam）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 请求参数 --%&gt; &lt;%--&lt;a href="anno/testRequestParam?name=cat"&gt;请点击&lt;/a&gt;--%&gt; &lt;a href="anno/testPathVariable/cat"&gt;获取 请求参数（PathVariable）&lt;/a&gt; // "cat" &lt;br&gt; &lt;a href="anno/testPathVariable/cat&amp;dog"&gt;获取 请求参数（PathVariable）&lt;/a&gt; // "cat&amp;dog" &lt;hr&gt; &lt;%-- 请求体 --%&gt; &lt;form action="anno/testRequestBody" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; &lt;input type="submit" value="获取 请求体（RequestBody）"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 请求头 --%&gt; &lt;h3&gt;&lt;a href="anno/testRequestHeader"&gt;获取 请求头（RequestHeader）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 缓存 --%&gt; &lt;h3&gt;&lt;a href="anno/testCookieValue"&gt;获取 缓存（CookieValue）&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- ModelAttribute --%&gt; &lt;form action="anno/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; &lt;input type="submit" value="ModelAttribute"&gt; &lt;/form&gt; &lt;hr&gt; &lt;a href="anno/testSessionAttributes"&gt;设置，并在浏览器查看Request域和Session域中的message值&lt;/a&gt;&lt;br&gt; &lt;a href="anno/getSessionAttributes"&gt;在控制台查看Session域中的message值&lt;/a&gt;&lt;br&gt; &lt;a href="anno/removeSessionAttributes"&gt;删除，并在浏览器查看Session域中的message值&lt;/a&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; session.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Request域：&lt;/h1&gt;$&#123;requestScope.message&#125;&lt;br&gt; &lt;h1&gt;Session域：&lt;/h1&gt;$&#123;sessionScope&#125;&lt;/body&gt;&lt;/html&gt; @RequestParam 请求参数 发出请求 1&lt;a href="anno/testRequestParam?name=cat&amp;name=dog&amp;name=rat"&gt;获取 请求参数（RequestParam）&lt;/a&gt; 接收请求 12345@RequestMapping("/testRequestParam")public String testRequestParam(@RequestParam(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success";&#125; 运行结果 1请求参数：cat,dog,rat @PathVariable 请求参数 发出请求 12&lt;a href="anno/testPathVariable/cat"&gt;获取 请求参数（PathVariable）&lt;/a&gt; &lt;br&gt;&lt;a href="anno/testPathVariable/cat&amp;dog"&gt;获取 请求参数（PathVariable）&lt;/a&gt; 接收请求 12345@RequestMapping("/testPathVariable/&#123;name&#125;")public String testPathVariable(@PathVariable(name = "name") String username )&#123; System.out.println("请求参数："+username); return "success";&#125; 运行结果 12请求参数：cat请求参数：cat&amp;dog @RequestBody 请求体 发出请求 123456&lt;form action="anno/testRequestBody" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; &lt;input type="submit" value="获取 请求体（RequestBody）"&gt;&lt;/form&gt; 接收请求 123456/* 【GET请求方式没有请求体】 */@RequestMapping("/testRequestBody")public String testRequestBody(@RequestBody String body )&#123; System.out.println("请求体："+body); return "success";&#125; 运行结果 1请求体：username=cat&amp;password=111&amp;money=999 @RequestHeader 请求头 发出请求 1&lt;a href="anno/testRequestHeader"&gt;获取 请求头（RequestHeader）&lt;/a&gt; 接收请求 12345@RequestMapping("/testRequestHeader")public String testRequestHeader(@RequestHeader(value = "Accept") String header )&#123; System.out.println("请求头："+header); return "success";&#125; 运行结果 1请求头：text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 @CookieValue 缓存 发出请求 1&lt;a href="anno/testCookieValue"&gt;获取 缓存（CookieValue）&lt;/a&gt; 接收请求 12345@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue )&#123; System.out.println("Cookie："+cookieValue); return "success";&#125; 运行结果 1Cookie：93E4FB2388E1A6249DA4552C947FE2C2 @ModelAttribute 发出请求 1234&lt;form action="anno/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; &lt;input type="submit" value="ModelAttribute"&gt;&lt;/form&gt; 接收请求 12345678910111213141516@RequestMapping("/testModelAttribute") public String testModelAttribute(User user)&#123; System.out.println("testModelAttribute执行了..."); System.out.println(user); return "success";&#125;/* 直接返回User对象 */@ModelAttribute /* 先执行 */public User ModelAttributeMethod(String name)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(name); user.setAge("11"); return user;&#125; 运行结果 123ModelAttributeMethod执行了...testModelAttribute执行了...User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125; 方法二 接收请求123456789/* 将User对象存储进底层的Map集合中 */@ModelAttributepublic void ModelAttributeMethod(String username, Map&lt;String,User&gt; map)&#123; System.out.println("ModelAttributeMethod执行了..."); User user = new User(); user.setName(username); user.setAge("11"); map.put("user_name",user);&#125; 设置域 发出请求 1&lt;a href="anno/testSessionAttributes"&gt;设置，并在浏览器查看Request域和Session域中的message值&lt;/a&gt; 接收请求 123456@RequestMapping("testSessionAttributes")public String testSessionAttributes(Model model)&#123; /* 将键值对存储到request域 */ model.addAttribute("message","Hello,Request Field!"); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果12Request域：Hello,Request Field!Session域：&#123;message=Hello,Request Field!&#125; 查看域 发出请求 1&lt;a href="anno/getSessionAttributes"&gt;在控制台查看Session域中的message值&lt;/a&gt; 接收请求 1234567@RequestMapping("getSessionAttributes")public String getSessionAttributes(ModelMap modelMap)&#123; /* 获取Session域中的值 */ Object message = modelMap.get("message"); System.out.println(message); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果 12Request域：Hello,Request Field!Session域：&#123;message=Hello,Request Field!&#125; 运行结果 1Hello,Request Field! 删除域 发出请求 1&lt;a href="anno/removeSessionAttributes"&gt;删除，并在浏览器查看Session域中的message值&lt;/a&gt; 接收请求 123456@RequestMapping("removeSessionAttributes")public String removeSessionAttributes(SessionStatus sessionStatus)&#123; /* 清空Session域中的值 */ sessionStatus.setComplete(); return "session";&#125; 响应页面 12Request域：$&#123;requestScope.message&#125;&lt;br&gt;Session域：$&#123;sessionScope&#125; 响应结果12Request域：Session域：&#123;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 参数绑定]]></title>
    <url>%2F2019%2F09%2F03%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%202%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[项目结构 java controller ParameterController.java（Java文件） utils StringToData（自定义类型转换文件） domain User（JavaBean本件） Account（JavaBean本件） CCollection（JavaBean本件） DDate（JavaBean本件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） parameters.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） 过滤器（CharacterEncodingFilter） 配置一个过滤器（&lt;filter&gt;） 配置编码（&lt;init-param&gt;）：解决中文乱码 配置前端控制器的作用范围（&lt;filter-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 配置类型转换器（ConversionServiceFactoryBean） 注册自定义类型转换器 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） 参数列表（数据类型 请求参数名，数据类型 请求参数名） JSP文件 超链接（href=”一级目录/二级目录?请求参数=值&amp;请求参数=值”） 表单（&lt;form action=”一级目录/二级目录” method=”post”&gt;） 执行代码 需求：在parameters.jsp页面，点击的超链接，跳转到success.jsp页面，并且在控制台输出请求参数。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 类型转换器 --&gt; &lt;bean id="conversionServiceFactoryBean" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- Configure the set of custom converter objects that should be added --&gt; &lt;property name="converters"&gt; &lt;!-- Set集合 --&gt; &lt;set&gt; &lt;!-- 添加自定义实现类 --&gt; &lt;bean class="cn.water.utils.StringToDate"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"/&gt;&lt;/beans&gt; StringToDate.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.water.utils;import org.springframework.core.convert.converter.Converter;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Water * @date 2019/9/10 - 8:53 */public class StringToDate implements Converter&lt;String, Date&gt; &#123; /** * * @param source * @return */ @Override public Date convert(String source) &#123;// 判断输入数据是否为空 if (source == null)&#123; throw new RuntimeException("请您输入日期"); &#125; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");// 转换格式 try &#123; return dateFormat.parse(source); &#125; catch (Exception e) &#123; System.out.println("请您输入正确的日期格式（yyyy-MM-dd）"); throw new RuntimeException("请您输入正确的日期格式（yyyy-MM-dd）"); &#125; &#125;&#125; ParameterController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package cn.water.controller;import cn.water.domain.Account;import cn.water.domain.CCollection;import cn.water.domain.DDate;import cn.water.domain.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.List;import java.util.Map;@Controller@RequestMapping("/parameter")public class parameterController &#123; /* 获取数据 */ @RequestMapping("/testParameter") public String testParameter(String cat,String dog,String rat)&#123; System.out.println("1、方法执行了"); System.out.println("2、获取参数："+cat+dog+rat); return "success"; &#125; /* 获取数据，并封装至JavaBean（User）中。 */ @RequestMapping("/testJavaBean") public String testJavaBean(User user)&#123; System.out.println(user.toString() ); return "success"; &#125; /* 获取数据，并封装至JavaBean中，且此JavaBean（Account）含有其他JavaBean对象（User）。 */ @RequestMapping("/testJavaBean222") public String testJavaBean2(Account account)&#123; System.out.println(account.toString() ); return "success"; &#125; /* 获取数据，并封装至JavaBean中，且此JavaBean（Account）含有List集合、Map集合。 */ @RequestMapping("/testCollection") public String testCollection(CCollection cCollection)&#123; System.out.println(cCollection); return "success"; &#125; /* 获取字符串数据，自动转换为日期类型数据（Spring框架自动转换器） */ @RequestMapping("/testDate") public String testDate(DDate date)&#123; System.out.println("Date:"+date); return "success"; &#125; /* 获取Servlet原生API */ @RequestMapping("/testServlet") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123;// Request对象 System.out.println("【Request】"+request);// Response对象 System.out.println("【Response】"+response);// Session对象 HttpSession session = request.getSession(); System.out.println("【Session】"+session);// ServletContext对象 ServletContext servletContext = session.getServletContext(); System.out.println("【ServletContext】"+servletContext); return "success"; &#125;&#125; index.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="controller/sayHello?username=cat"&gt;入门&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="parameters.jsp"&gt;参数绑定&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;&lt;a href="annotation.jsp"&gt;注解&lt;/a&gt;&lt;/h2&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; parameters.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 普通类型 --%&gt; &lt;h3&gt;&lt;a href="parameter/testParameter?cat=11&amp;dog=22&amp;rat=33"&gt;封装至 普通数据类型&lt;/a&gt;&lt;/h3&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean --%&gt; &lt;form action="parameter/testJavaBean" method="post"&gt; &lt;%-- post请求方式中文会乱码，get请求方式不会 --%&gt; 姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有JavaBean --%&gt; &lt;form action="parameter/testJavaBean222" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; 用户姓名：&lt;input type="text" name="user.name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="user.age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有JavaBean"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有集合 --%&gt; &lt;form action="parameter/testCollection" method="post"&gt; &lt;%-- List&lt;User&gt; list[0]==User --%&gt; 用户姓名：&lt;input type="text" name="list[0].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="list[0].age" /&gt;&lt;br/&gt; &lt;%-- Map&lt;String,User&gt; 'one'==String --%&gt; 用户姓名：&lt;input type="text" name="map['one'].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="map['one'].age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有List集合和Map集合"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%-- 封装至JavaBean，含有Data类型 --%&gt; &lt;%-- 网页中input标签的Test属性的文本框中输入数据类型一定是字符串形式 --%&gt; &lt;%-- 默认配置下，String框架自动将请求的字符串格式自动转换为JavaBean中对应的格式，但是对于文本格式有所要求，例如日期 --%&gt; &lt;%-- 默认正确日期格式：2019/01/01 --%&gt; &lt;%-- 自定义正确日期格式：2019-01-01 --%&gt; &lt;form action="parameter/testDate" method="post"&gt; 日期：&lt;input type="text" name="date" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 日期类型"&gt; &lt;/form&gt; &lt;hr&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 获取请求数据封装至 普通数据类型普通数据类型 发送请求 1&lt;a href="parameter/testParameter?cat=11&amp;dog=22&amp;rat=33"&gt;封装至 普通数据类型&lt;/a&gt; 接收请求 123456@RequestMapping("/testParameter")public String testParameter(String cat,String dog,String rat)&#123; System.out.println("1、方法执行了"); System.out.println("2、获取参数："+cat+dog+rat); return "success";&#125; 运行结果 121、方法执行了2、获取参数：112233 封装至 JavaBean类型JavaBean类型 数据类型 123456789101112131415161718192021222324252627282930313233package cn.water.domain;import java.io.Serializable;public class User implements Serializable &#123; private String name; private String age; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 发送请求 123456&lt;form action="parameter/testJavaBean" method="post"&gt; &lt;%-- post请求方式中文会乱码，get请求方式不会 --%&gt; 姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testJavaBean")public String testJavaBean(User user)&#123; System.out.println(user.toString() ); return "success";&#125; 运行结果 1User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125; 含有JavaBean 数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.water.domain;import java.io.Serializable;public class Account implements Serializable &#123; private String username; private String password; private Double money; private User user; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String toString() &#123; return "Account&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", money=" + money + ", user=" + user + '&#125;'; &#125;&#125; 发送请求 12345678&lt;form action="parameter/testJavaBean222" method="post"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="text" name="password" /&gt;&lt;br/&gt; 金额：&lt;input type="text" name="money" /&gt;&lt;br/&gt; 姓名：&lt;input type="text" name="user.name" /&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="user.age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有JavaBean"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testJavaBean222")public String testJavaBean2(Account account)&#123; System.out.println(account.toString() ); return "success";&#125; 运行结果 1Account&#123;username=&apos;cat&apos;, password=&apos;123695&apos;, money=999.0, user=User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125;&#125; 含有List集合和Map集合 数据类型 1234567891011121314151617181920212223242526272829303132333435package cn.water.domain;import java.io.Serializable;import java.util.List;import java.util.Map;public class CCollection implements Serializable &#123; private List&lt;User&gt; list; private Map&lt;String,User&gt; map; @Override public String toString() &#123; return "CCollection&#123;" + "list=" + list + ", map=" + map + '&#125;'; &#125; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125;&#125; 发送请求 123456789&lt;form action="parameter/testCollection" method="post"&gt; &lt;%-- List&lt;User&gt; list[0]==User --%&gt; 用户姓名：&lt;input type="text" name="list[0].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="list[0].age" /&gt;&lt;br/&gt; &lt;%-- Map&lt;String,User&gt; 'one'==String --%&gt; 用户姓名：&lt;input type="text" name="map['one'].name" /&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="map['one'].age" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 JavaBean类型 含有List集合和Map集合"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testCollection")public String testCollection(CCollection cCollection)&#123; System.out.println(cCollection); return "success";&#125; 运行结果 1CCollection&#123;list=[User&#123;name=&apos;cat&apos;, age=&apos;11&apos;&#125;], map=&#123;one=User&#123;name=&apos;dog&apos;, age=&apos;22&apos;&#125;&#125;&#125; 封装至 日期类型日期类型 数据类型 12345678910111213141516171819202122232425package cn.water.domain;import java.io.Serializable;import java.util.Date;public class DDate implements Serializable &#123; private Date date; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Override public String toString() &#123; return "DDate&#123;" + "date=" + date + '&#125;'; &#125;&#125; 自定义类型转换器 1234567891011121314151617181920212223242526272829package cn.water.utils;import org.springframework.core.convert.converter.Converter;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class StringToDate implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123;// 判断输入数据是否为空 if (source == null)&#123; throw new RuntimeException("请您输入日期"); &#125; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");// 转换格式 try &#123; return dateFormat.parse(source); &#125; catch (Exception e) &#123; throw new RuntimeException("请您输入正确的日期格式（yyyy-MM-dd）"); &#125; &#125;&#125; 发送请求 12345678&lt;%-- 网页中input标签的Test属性的文本框中输入数据类型一定是字符串形式 --%&gt;&lt;%-- 默认配置下，String框架自动将请求的字符串格式自动转换为JavaBean中对应的格式，但是对于文本格式有所要求，例如日期 --%&gt;&lt;%-- 正确日期格式：2019/01/01 --%&gt;&lt;%-- 错误日期格式：2019-01-01; 2019：01：01 --%&gt;&lt;form action="parameter/testDate" method="post"&gt; 日期：&lt;input type="text" name="date" /&gt;&lt;br/&gt; &lt;input type="submit" value="封装至 日期类型"&gt;&lt;/form&gt; 接收请求 12345@RequestMapping("/testDate")public String testDate(DDate date)&#123; System.out.println("Date:"+date); return "success";&#125; 运行结果 12输入：2011-9-1 10:25:45结果：Date:DDate&#123;date=Thu Sep 01 10:25:45 CST 2011&#125; 获取Servlet原生APIRequestResponseSessionServletContext 发送请求 1&lt;a href="parameter/testServlet"&gt;请点击&lt;/a&gt; 接收请求 123456789101112131415 @RequestMapping("/testServlet") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123;// Request对象 System.out.println("【Request】"+request);// Response对象 System.out.println("【Response】"+response);// Session对象 HttpSession session = request.getSession(); System.out.println("【Session】"+session);// ServletContext对象 ServletContext servletContext = session.getServletContext(); System.out.println("【ServletContext】"+servletContext); return "success"; &#125; 运行结果 1234【Request】org.apache.catalina.connector.RequestFacade@736f0cc【Response】org.apache.catalina.connector.ResponseFacade@3755e816【Session】org.apache.catalina.session.StandardSessionFacade@56651c25【ServletContext】org.apache.catalina.core.ApplicationContextFacade@4dc6868]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 入门案例]]></title>
    <url>%2F2019%2F09%2F01%2FSSM%E6%A1%86%E6%9E%B6%2FSpringMVC%2FSpringMVC%201%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[项目结构 java controller HelloController.java（Java文件） resources springmvc.xml（springmvc配置文件） webapp WEB-INF pages success.jsp（web页面） web.xml（web配置文件） index.jsp（web页面） pom.xml（maven项目配置文件） maven项目配置文件 配置maven项目需要的依赖 spring-context spring-web spring-webmvc servlet-api jsp-api web配置文件 前端控制器（DispatcherServlet） 配置一个前端控制器（&lt;servlet&gt;） 创建前端控制器时，加载Spring配置文件（&lt;init-param&gt;） 启动服务器时，创建前端控制器（&lt;\load-on-startup&gt;） 配置前端控制器的作用范围（&lt;servlet-mapping&gt;） springmvc配置文件 导入名称空间（&lt;beans xmlns=””&gt;） 开启注解扫描（&lt;context:component-scan base-package=””&gt;） 配置视图解析器（InternalResourceViewResolver） 配置前缀（prefix -&gt; “/WEB-INF/pages”） 配置后缀（suffix -&gt; “.jsp”） 开启SpringMVC注解支持（&lt;mvc:annotation-driven&gt;） Java文件 表现层 类 添加进IoC核心容器（@Controller） 设置请求映射（@RequestMapping()） 一级目录（path=””） 设置允许访问的请求方法（method=””） 设置必需的参数和参数值（params=””） 设置必需的请求头（headers=””） 方法 设置请求映射（@RequestMapping()） 二级目录（path=””） 返回值（return “success”;） JSP文件 超链接（href=”一级目录/二级目录”） 执行代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;section01_Introduction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;section01_Introduction Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖注入 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;section01_Introduction&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 【Filter】 --&gt; &lt;filter&gt; &lt;!-- 创建过滤器 --&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 配置编码 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 映射 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 【Servlet】 --&gt; &lt;servlet&gt; &lt;!-- 创建前端控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 创建前端控制器时，加载spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动服务器时，创建前端控制器 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.water"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" &gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springMVC框架注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"/&gt;&lt;/beans&gt; HellowController.java12345678910111213141516171819package cn.water.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller /* 将此类添加进IoC核心容器 */@RequestMapping(path = "/controller",method = &#123;RequestMethod.GET&#125;,params = &#123;"username=cat"&#125;,headers = &#123;"Accept"&#125;) /* 设置一级目录 */ /* 设置允许访问的请求方法 */ /* 设置必需的参数和值 */ /* 设置必需的请求头 */public class HelloController &#123; @RequestMapping("/sayHello") /* 设置二级目录 */ public String sayHello()&#123; System.out.printf("Hello StringMVC"); return "success"; &#125;&#125; index.jsp12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门&lt;/h3&gt; &lt;a href="controller/sayHello?username=cat"&gt;请点击&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;访问成功！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务管理 案例]]></title>
    <url>%2F2019%2F08%2F20%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_TransactionTest%2F</url>
    <content type="text"><![CDATA[简介 本文将在 Spring 框架中，分别使用使用“XML”，“XML+注释”和“注解+Java”三种方式来演示数据库的转账操作。 数据源 创建数据库eesy_spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE eesy_spring;# 使用数据库USE eesy_spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); 基于XML配置文件 整个程序基于一下四大块： domain：用于存放实体类。 service：用于存放业务层的接口和实现类。 dao：用于存放持久层的接口和实现类。 test：用于测试。 实体类 domian 实体类根据数据库表中的列属性来设置成员变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.xml.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service12345678910111213141516171819package cn.water.xml.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId, Float money);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.xml.service;import cn.water.xml.dao.AccountDao;import cn.water.xml.domain.Account;/** * 【业务层接口实现】 */public class AccountServiceImp implements AccountService &#123; /** * [持久层接口] */ private AccountDao dao; /*Setter方法*/ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.update(source); /* (-1).异常 */// int i = 2/0; dao.update(target); &#125;;&#125; 持久层 dao12345678910111213141516171819202122232425262728293031package cn.water.xml.dao;import cn.water.xml.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回账户对象的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ Account findById(Integer id); /** * 【更新】 * @param account 新的账户信息 */ void update(Account account);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.water.xml.dao;import cn.water.xml.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import java.util.List;/** * 【持久层接口实现】 * 继承JdbcSupport类，获取JdbcTemplate，从而获取Connection对象 */public class AccountDaoImp extends JdbcDaoSupport implements AccountDao &#123; /** * 【查询】 * @return 返回账户对象的List集合 */ public List&lt;Account&gt; findAll() &#123; /* query方法：SELECT BeanPropertyRowMapper对象：Account */ List&lt;Account&gt; accountList = super.getJdbcTemplate().query( "SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accountList; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ public Account findById(Integer id) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ Account account = super.getJdbcTemplate().queryForObject( "SELECT * FROM account WHERE id = ? ;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); return account; &#125; /** * 【更新】 * @param account 新的账户信息 */ public void update(Account account) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ super.getJdbcTemplate().update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId() ); &#125;&#125; xml配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--【AOP】--&gt; &lt;aop:config&gt; &lt;!--[pointcut]--&gt; &lt;aop:pointcut id="selectAll" expression="execution(* cn.water.xml.service.*.*(..))"&gt;&lt;/aop:pointcut&gt; &lt;!-- [通知] --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="selectAll"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;!--【通知：连接事务管理器】--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- [属性] isolation属性：事务的隔离级别。默认值为DEFAULT。 propagation属性：事务的转播行为。默认值为REQUIRED（增删改）；SUPPORTS（查询）。 read-only属性：事务是否只读。默认值为false（增删改）；true（查询）。 timeout属性：事务的超时时间。默认值-1（永不超时）；指定数值，以秒为单位。 rollback-for属性：指定执行回滚的异常，其他异常不回滚。不指定异常，任何异常都回滚。 no-rollback-for属性：指定不执行回滚的异常，其他异常回滚。不指定异常，任何异常都回滚。 --&gt; &lt;!-- 增删改方法 --&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;!-- 查询方法 --&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--【事务管理器】--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- serviceImp --&gt; &lt;bean id="serviceImp" class="cn.water.xml.service.AccountServiceImp"&gt; &lt;!-- DaoImp --&gt; &lt;property name="dao" ref="daoImp" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DaoImp --&gt; &lt;bean id="daoImp" class="cn.water.xml.dao.AccountDaoImp"&gt; &lt;!-- DriverManagerDataSource：给父类 --&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 test123456789101112131415161718192021222324252627282930package cn.water.xml;import cn.water.xml.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/* 【Spring Junit】 */@RunWith(SpringJUnit4ClassRunner.class)/* 【配置XML文件】 */@ContextConfiguration(locations = "classpath:xml/Beans.xml")public class AccountTest &#123; @Autowired @Qualifier("serviceImp") private AccountService service; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125; 基于XML配置文件和注解实体类 domain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.xml_anno.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service12345678910111213141516171819package cn.water.xml_anno.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId, Float money);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.water.xml_anno.service;import cn.water.xml_anno.dao.AccountDao;import cn.water.xml_anno.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 【业务层接口实现】 */@Service("serviceImp")/* 事务支持(查询方法) */@Transactional(propagation = Propagation.SUPPORTS ,readOnly = true)public class AccountServiceImp implements AccountService &#123; /** * [持久层接口] */ @Autowired private AccountDao dao; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ /* 事务支持(增删改方法) */ @Transactional(propagation = Propagation.REQUIRED ,readOnly = false) public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.update(source); /* (-1).异常 */// int i = 2/0; dao.update(target); &#125;;&#125; 持久层 dao12345678910111213141516171819202122232425262728293031package cn.water.xml_anno.dao;import cn.water.xml_anno.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回账户对象的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ Account findById(Integer id); /** * 【更新】 * @param account 新的账户信息 */ void update(Account account);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.water.xml_anno.dao;import cn.water.xml_anno.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Repository;import java.util.List;/** * 【持久层接口实现】 */@Repository("daoImp")public class AccountDaoImp implements AccountDao &#123; /*** * [jdbcTemplate] */ @Autowired private JdbcTemplate jdbcTemplate; /** * 【查询】 * @return 返回账户对象的List集合 */ public List&lt;Account&gt; findAll() &#123; /* query方法：SELECT BeanPropertyRowMapper对象：Account */ List&lt;Account&gt; accountList = jdbcTemplate.query( "SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accountList; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ public Account findById(Integer id) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ Account account = jdbcTemplate.queryForObject( "SELECT * FROM account WHERE id = ? ;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); return account; &#125; /** * 【更新】 * @param account 新的账户信息 */ public void update(Account account) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ jdbcTemplate.update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId() ); &#125;&#125; xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- [事务管理器] --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 【开启注解事务支持】 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"&gt;&lt;/tx:annotation-driven&gt; &lt;!-- 【注解扫描】 --&gt; &lt;context:component-scan base-package="cn.water.xml_anno"&gt;&lt;/context:component-scan&gt; &lt;!-- [JdbcTemplate] --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- DataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 test123456789101112131415161718192021222324252627282930package cn.water.xml_anno;import cn.water.xml_anno.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/* 【Spring Junit】 */@RunWith(SpringJUnit4ClassRunner.class)/* 【配置XML文件】 */@ContextConfiguration(locations = "classpath:xml_anno/Beans.xml")public class AccountTest &#123; @Autowired @Qualifier("serviceImp") private AccountService service; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125; 基于Java配置文件和注解实体类 domain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.java_anno.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service12345678910111213141516171819package cn.water.java_anno.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId, Float money);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.water.java_anno.service;import cn.water.java_anno.dao.AccountDao;import cn.water.java_anno.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 【业务层接口实现】 */@Service("serviceImp")/* 事务支持(查询方法) */@Transactionalpublic class AccountServiceImp implements AccountService &#123; /** * [持久层接口] */ @Autowired private AccountDao dao; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.update(source); /* (-1).异常 */ int i = 2/0; dao.update(target); &#125;;&#125; 持久层 dao12345678910111213141516171819202122232425262728293031package cn.water.java_anno.dao;import cn.water.java_anno.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回账户对象的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ Account findById(Integer id); /** * 【更新】 * @param account 新的账户信息 */ void update(Account account);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.water.java_anno.dao;import cn.water.java_anno.domain.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;/** * 【持久层接口实现】 */@Repository("daoImp")public class AccountDaoImp implements AccountDao &#123; /*** * [jdbcTemplate] */ @Autowired private JdbcTemplate jdbcTemplate; /** * 【查询】 * @return 返回账户对象的List集合 */ public List&lt;Account&gt; findAll() &#123; /* query方法：SELECT BeanPropertyRowMapper对象：Account */ List&lt;Account&gt; accountList = jdbcTemplate.query( "SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accountList; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回账户对象 */ public Account findById(Integer id) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ Account account = jdbcTemplate.queryForObject( "SELECT * FROM account WHERE id = ? ;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); return account; &#125; /** * 【更新】 * @param account 新的账户信息 */ public void update(Account account) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ jdbcTemplate.update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId() ); &#125;&#125; properties配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_springjdbc.username=rootjdbc.password=root java配置文件12345678910111213141516171819202122232425package cn.water.java_anno.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.context.annotation.PropertySource;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * 【Spring的配置】 *//* 【配置文件】 */@Configuration/* 【扫描注释】 */@ComponentScan("cn.water.java_anno")/* 【配置子文件】 */@Import(&#123;JdbcConfig.class, TransactionConfig.class&#125;)/* 【读取文件】 */@PropertySource("classpath:java_anno/jdbcConfig.properties")/* 【开启事务管理器】 */@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125; JdbcConfig配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.water.java_anno.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;/** * 【连接数据库的配置】 */public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 【创建】 * @param dataSource 数据库连接池 * @return JdbcTemplate */ @Bean(name = "jdbcTemplate") public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; /** * 【创建】 * @return 数据库连接池 */ @Bean(name = "dataSource") public DataSource getDataSource()&#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; TransactionConfig配置文件12345678910111213141516171819202122232425package cn.water.java_anno.config;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.sql.DataSource;/** * 【数据库事务的配置】 */public class TransactionConfig &#123; /** * 【创建】 * @param dataSource 数据库连接对象 * @return */ @Bean(name = "transactionManager") public PlatformTransactionManager getTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 测试类 test12345678910111213141516171819202122232425262728293031package cn.water.java_anno;import cn.water.java_anno.config.SpringConfiguration;import cn.water.java_anno.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/* 【Spring Junit】 */@RunWith(SpringJUnit4ClassRunner.class)/* 【配置Java文件】 */@ContextConfiguration(classes = SpringConfiguration.class)public class AccountTest &#123; @Autowired @Qualifier("serviceImp") private AccountService service; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务管理]]></title>
    <url>%2F2019%2F08%2F20%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_Transaction%2F</url>
    <content type="text"><![CDATA[事务管理 一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 ACID： 原子性：事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。 一致性：这表示数据库的引用完整性的一致性，表中唯一的主键等。 隔离性：可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。 持久性：一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。 一个真正的 RDBMS 数据库系统将为每个事务保证所有的四个属性。使用 SQL 发布到数据库中的事务的简单视图如下： 使用 begin transaction 命令开始事务。 使用 SQL 查询语句执行各种删除、更新或插入操作。 如果所有的操作都成功，则执行提交操作，否则回滚所有操作。 局部事物 vs. 全局事务局部事务是特定于一个单一的事务资源，如一个 JDBC 连接，而全局事务可以跨多个事务资源事务，如在一个分布式系统中的事务。 局部事务管理在一个集中的计算环境中是有用的，该计算环境中应用程序组件和资源位于一个单位点，而事务管理只涉及到一个运行在一个单一机器中的本地数据管理器。局部事务更容易实现。 全局事务管理需要在分布式计算环境中，所有的资源都分布在多个系统中。在这种情况下事务管理需要同时在局部和全局范围内进行。分布式或全局事务跨多个系统执行，它的执行需要全局事务管理系统和所有相关系统的局部数据管理人员之间的协调。 编程式 vs. 声明式 Spring 支持两种类型的事务管理: 编程式事务管理 ：这意味着你在编程的帮助下有管理事务。这给了你极大的灵活性，但却很难维护。 声明式事务管理 ：这意味着你从业务代码中分离事务管理。你仅仅使用注释或 XML 配置来管理事务。 声明式事务管理比编程式事务管理更可取，尽管它不如编程式事务管理灵活，但它允许你通过代码控制事务。但作为一种横切关注点，声明式事务管理可以使用 AOP 方法进行模块化。Spring 支持使用 Spring AOP 框架的声明式事务管理。 Spring 声明式事务管理声明式事务管理方法允许你在配置的帮助下而不是源代码硬编程来管理事务。这意味着你可以将事务管理从事务代码中隔离出来。你可以只使用注释或基于配置的 XML 来管理事务。 bean 配置会指定事务型方法。下面是与声明式事务相关的步骤： 我们使用标签，它创建一个事务处理的建议，同时，我们定义一个匹配所有方法的切入点，我们希望这些方法是事务型的并且会引用事务型的建议。 如果在事务型配置中包含了一个方法的名称，那么创建的建议在调用方法之前就会在事务中开始进行。 目标方法会在 try / catch 块中执行。 如果方法正常结束，AOP 建议会成功的提交事务，否则它执行回滚操作。 #]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring JDBC 案例]]></title>
    <url>%2F2019%2F08%2F19%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_JDBCTest%2F</url>
    <content type="text"><![CDATA[概述 使用Spring JDBC 完成 查询操作。 主要的问题在于：如何获取 JdbcTemplate 案例一：创建 JdbcTemplate 案例二：继承 JdbcDaoSupport 配置数据源 我们在 MySQL 数据库 eesy_spring 中创建一个数据库表 account。假设你正在使用 MySQL 数据库，如果你使用其他数据库，那么你可以改变你的 DDL 和相应的 SQL 查询。 1234567891011121314151617# 创建数据库CREATE DATABASE eesy_spring;# 使用数据库USE eesy_spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); Maven项目环境12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;spring_JDBC&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring JDBC框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建 JdbcTemplateDomain 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.demo.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; Dao 持久层1234567891011121314151617181920212223242526package cn.water.demo.dao;import cn.water.demo.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.demo.dao;import cn.water.demo.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.util.List;/** * 【持久层接口实现】 */@Component("accountImp")public class AccountDaoImp implements AccountDao &#123; /*** * [DataSource] */ private DataSource dataSource; /* Setter */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; /* query方法：SELECT BeanPropertyRowMapper对象：Account */ List&lt;Account&gt; accountList = new JdbcTemplate(dataSource).query( "SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accountList; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ Account account = new JdbcTemplate(dataSource).queryForObject( "SELECT * FROM account WHERE id = ? ;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); return account; &#125;&#125; XML配置文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DaoImp --&gt; &lt;bean id="daoImp" class="cn.water.demo.dao.AccountDaoImp"&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_spring" &gt;&lt;/property&gt; &lt;property name="username" value="root" &gt;&lt;/property&gt; &lt;property name="password" value="root" &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.water.demo;import cn.water.demo.dao.AccountDao;import cn.water.demo.domain.Account;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class DaoTest &#123; /** * [成员变量] */ private ApplicationContext appCon; private AccountDao dao; /** * 【初始化方法】 */ @Before public void init()&#123; /* 获取容器 */ appCon = new ClassPathXmlApplicationContext("demo/Beans.xml"); /* 获取业务层对象 */ dao = appCon.getBean("daoImp", AccountDao.class); &#125; /** * 【测试查询所有方法】 */ @Test public void testFindAll()&#123; List&lt;Account&gt; all = dao.findAll(); for (Account account : all) &#123; System.out.println(account); &#125; &#125; /** * 【测试查询方法】 */ @Test public void testFindOne()&#123; Account account = dao.findById(1); System.out.println(account); &#125;&#125; 继承 JdbcDaoSupportDomain 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.jdbc.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; Dao 持久层1234567891011121314151617181920212223242526package cn.water.jdbc.dao;import cn.water.jdbc.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.water.jdbc.dao;import cn.water.jdbc.domain.Account;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Component;import java.util.List;/** * 【持久层接口实现】 * 继承JdbcSupport类，获取JdbcTemplate，从而获取Connection对象 */@Component("accountImp")public class AccountDaoImp extends JdbcDaoSupport implements AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; /* query方法：SELECT BeanPropertyRowMapper对象：Account */ List&lt;Account&gt; accountList = super.getJdbcTemplate().query( "SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); return accountList; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; /* queryForObject方法：SELECT BeanPropertyRowMapper对象：Account*/ Account account = super.getJdbcTemplate().queryForObject( "SELECT * FROM account WHERE id = ? ;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id ); return account; &#125;&#125; JdbcSupport 父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.water.jdbc.dao;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;/** * 【为子类提供JdbcTemplate】 * Spring为我们提供了JdbcDaoTemplate。 * 我们只是模仿JdbcDaoTemplate，并没有真的继承这个类。 */public class JdbcSupport &#123; /*** * [JdbcTemplate] */ private JdbcTemplate template; /* Setter */ public JdbcTemplate getTemplate() &#123; return template; &#125; /* Getter */ public void setTemplate(JdbcTemplate template) &#123; this.template = template; &#125; /** * 【检查成员变量JdbcTemplate是否为空】 * @param dataSource 数据库连接池 */ public void setDataSource(DataSource dataSource)&#123; if (template == null)&#123; /* 调用createJdbcTemplate方法 */ template = createJdbcTemplate(dataSource); &#125; &#125; /** * 【创建JdbcTemplate对象】 * @param dataSource 数据库连接池 * @return JdbcTemplate对象 */ public JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125;&#125; XML配置文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- DaoImp --&gt; &lt;bean id="daoImp" class="cn.water.jdbc.dao.AccountDaoImp"&gt; &lt;!-- DriverManagerDataSource：给父类 --&gt; &lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_spring" &gt;&lt;/property&gt; &lt;property name="username" value="root" &gt;&lt;/property&gt; &lt;property name="password" value="root" &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package water.jdbc;import cn.water.jdbc.dao.AccountDao;import cn.water.jdbc.domain.Account;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class DaoTest &#123; /** * [成员变量] */ private ApplicationContext appCon; private AccountDao dao; /** * 【初始化方法】 */ @Before public void init()&#123; /* 获取容器 */ appCon = new ClassPathXmlApplicationContext("jdbc/Beans.xml"); /* 获取业务层对象 */ dao = appCon.getBean("daoImp", AccountDao.class); &#125; /** * 【测试查询所有方法】 */ @Test public void testFindAll()&#123; List&lt;Account&gt; all = dao.findAll(); for (Account account : all) &#123; System.out.println(account); &#125; &#125; /** * 【测试查询方法】 */ @Test public void testFindOne()&#123; Account account = dao.findById(1); System.out.println(account); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP 转账案例]]></title>
    <url>%2F2019%2F08%2F19%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_AOPTest%2F</url>
    <content type="text"><![CDATA[简介 本文的三个案例是为了更好的理解 Spring AOP 的机制，以及复习数据库事务管理。具体的功能是实现数据库的转账操作，核心知识主要分为三部分：数据库的连接、事务管理、依赖注入和功能测试。 案例一 数据库的管理问题：通过Connection工具类来实现 事务管理：通过 Transaction 工具类，在业务层中实现 依赖注入：通过XML配置文件 测试：通过Junit测试 案例二 数据库的管理问题：通过Connection工具类来实现 事务管理：通过 Transaction 工具类，在 BeanFactory 代理类中实现。（获取增强过的业务层接口） 依赖注入：通过 XML 配置文件 测试：通过 Junit 测试 案例三 数据库的管理问题：通过Connection工具类来实现 事务管理：完全通过 Transaction 工具类实现（AOP，高内聚） 依赖注入：主要通过注释 测试：通过 Spring Junit 测试 整个程序基于一下六大块： domain：用于存放实体类。 service：用于存放业务层的接口和实现类。 dao：用于存放持久层的接口和实现类。（具体的CRUD操作代码） factory：用于自定义代理类。 Utils：用于存放工具类。 test：用于测试。 数据库代码 创建数据库eesy_spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE eesy_spring;# 使用数据库USE eesy_spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); 业务层实现事务Connection 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.demo.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 【Connection工具类】 */public class ConnectionUtils &#123; /* 【ThreadLocal】 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); /* 【DataSource】 */ private DataSource dataSource; /* Setter方法 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** * 【返回或设置 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public Connection getThreadConnection() &#123; try &#123; /* (1).从当前线程上，获取数据库连接 */ Connection connection = threadLocal.get(); /* (2).判断该线程是否存在数据库连接 */ if (connection == null) &#123; /* (3).从数据库连接池中，获取数据库连接 */ connection = dataSource.getConnection(); /* (4).将数据库连接设置到该线程 */ threadLocal.set(connection); &#125; /* (5).返回数据库连接 */ return connection; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【销毁 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; Transaction 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.water.demo.utils;import java.sql.SQLException;/** * 【事务控制】 */public class TransactionManager &#123; /** * [数据库连接工具类] * 用于事务控制 */ private ConnectionUtils connectionUtils; /* Setter方法*/ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 【开启事务】 */ public void turnONTransaction()&#123; try &#123; /* 设置自动提交为false */ connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【提交事务】 */ public void commitTransaction()&#123; try &#123; /* 提交事务 */ connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【回滚事务】 */ public void rollbackTransaction()&#123; try &#123; /* 回滚事务 */ connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【关闭事务】 */ public void closeTransaction()&#123; try &#123; /* 返回至数据库连接池 */ connectionUtils.getThreadConnection().close(); /* 销毁 当前线程上的数据库连接对象 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Domain 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.demo.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; Service 业务层1234567891011121314151617package cn.water.demo.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId, Float money);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.water.demo.service;import cn.water.demo.dao.AccountDao;import cn.water.demo.domain.Account;import cn.water.demo.utils.TransactionManager;/** * 【业务层接口实现】 * 由于此案例是为了操作数据库的CRUD方法 * 所以业务层并没有实现其他功能 * 而只是注入了持久层接口，调用了持久层方法 */public class AccountServiceImp implements AccountService &#123; /** * [持久层接口] */ private AccountDao dao; /* Setter方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** * [事务控制工具类] */ private TransactionManager transactionManager; /* Setter方法 */ public void setTransactionManager(TransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; try &#123; /* 【开启事务】 */ transactionManager.turnONTransaction(); /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.updateAccount(source); dao.updateAccount(target); /* (-1).异常 */// int i = 2/0; /* 【提交事务】 */ transactionManager.commitTransaction(); &#125;catch (Exception e)&#123; /* 【回滚事务】 */ transactionManager.rollbackTransaction(); &#125;finally &#123; /* 【释放连接】 */ transactionManager.closeTransaction(); &#125; &#125;;&#125; Dao 持久层1234567891011121314151617181920212223242526272829303132package cn.water.demo.dao;import cn.water.demo.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.water.demo.dao;import cn.water.demo.domain.Account;import cn.water.demo.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */public class AccountDaoImp implements AccountDao &#123; /** * [数据库操作类] */ private QueryRunner queryRunner; /* Setter方法*/ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; /** * [数据库连接工具类] * 调用QueryRunner类时，传入Connection对象，用于事务控制。 */ private ConnectionUtils connectionUtils; /* Setter方法*/ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; Connection对象：事务控制 */ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account Connection对象：事务控制*/ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE * Connection对象：事务控制*/ queryRunner.update( connectionUtils.getThreadConnection(), "UPDATE account SET money=? WHERE id=? ;", account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; XML 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- [业务层接口实现] --&gt; &lt;bean id="serviceImp" class="cn.water.demo.service.AccountServiceImp"&gt; &lt;!-- 持久层接口实现 --&gt; &lt;property name="dao" ref="daoImp" &gt;&lt;/property&gt; &lt;!-- TransactionManager --&gt; &lt;property name="transactionManager" ref="transactionManager"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [TransactionManager] --&gt; &lt;bean id="transactionManager" class="cn.water.demo.utils.TransactionManager"&gt; &lt;!-- ConnectionUtils --&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [持久层接口实现] --&gt; &lt;bean id="daoImp" class="cn.water.demo.dao.AccountDaoImp"&gt; &lt;!-- QueryRunner --&gt; &lt;property name="queryRunner" ref="runner"&gt;&lt;/property&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [QueryRunner] --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;&lt;/bean&gt; &lt;!-- [ConnectionUtils] --&gt; &lt;bean id="connectionUtils" class="cn.water.demo.utils.ConnectionUtils"&gt; &lt;!-- DataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Test 测试类123456789101112131415161718192021222324252627282930313233343536373839package cn.water.demo;import cn.water.demo.service.AccountService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class AccountTest &#123; /** * [成员变量] */ private ApplicationContext appCon; private AccountService service; /** * 【初始化方法】 */ @Before public void init()&#123; /* 获取容器 */ appCon = new ClassPathXmlApplicationContext("demo/Beans.xml"); /* 获取业务层对象 */ service = appCon.getBean("serviceImp",AccountService.class); &#125; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125; 代理类实现事务Connection 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.proxy.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 【Connection工具类】 */public class ConnectionUtils &#123; /* 【ThreadLocal】 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); /* 【DataSource】 */ private DataSource dataSource; /* Setter方法 */ public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** * 【返回或设置 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public Connection getThreadConnection() &#123; try &#123; /* (1).从当前线程上，获取数据库连接 */ Connection connection = threadLocal.get(); /* (2).判断该线程是否存在数据库连接 */ if (connection == null) &#123; /* (3).从数据库连接池中，获取数据库连接 */ connection = dataSource.getConnection(); /* (4).将数据库连接设置到该线程 */ threadLocal.set(connection); &#125; /* (5).返回数据库连接 */ return connection; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【销毁 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; Transaction 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.water.proxy.utils;import java.sql.SQLException;/** * 【事务控制】 */public class TransactionManager &#123; /** * [数据库连接工具类] * 用于事务控制 */ private ConnectionUtils connectionUtils; /* Setter方法*/ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 【开启事务】 */ public void turnONTransaction()&#123; try &#123; /* 设置自动提交为false */ connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【提交事务】 */ public void commitTransaction()&#123; try &#123; /* 提交事务 */ connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【回滚事务】 */ public void rollbackTransaction()&#123; try &#123; /* 回滚事务 */ connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【关闭事务】 */ public void closeTransaction()&#123; try &#123; /* 返回至数据库连接池 */ connectionUtils.getThreadConnection().close(); /* 销毁 当前线程上的数据库连接对象 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Domain 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.proxy.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; Service 业务层12345678910111213141516171819package cn.water.proxy.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId ,Float money);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.proxy.service;import cn.water.proxy.dao.AccountDao;import cn.water.proxy.domain.Account;import cn.water.proxy.utils.TransactionManager;/** * 【业务层接口实现】 */public class AccountServiceImp implements AccountService&#123; /** * [持久层接口] */ private AccountDao dao; /* Setter方法 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** * [事务控制工具类] */ private TransactionManager transactionManager; /* Setter方法 */ public void setTransactionManager(TransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.updateAccount(source); dao.updateAccount(target); /* (-1).异常 */// int i = 2/0; &#125;;&#125; Dao 持久层123456789101112131415161718192021222324252627282930313233package cn.water.proxy.dao;import cn.water.proxy.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package cn.water.proxy.dao;import cn.water.proxy.domain.Account;import cn.water.proxy.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */public class AccountDaoImp implements AccountDao&#123; /** * [数据库操作类] */ private QueryRunner queryRunner; /* Setter方法*/ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; /** * [数据库连接工具类] * 调用QueryRunner类时，传入Connection对象，用于事务控制。 */ private ConnectionUtils connectionUtils; /* Setter方法*/ public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; Connection对象：事务控制 */ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account Connection对象：事务控制*/ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE * Connection对象：事务控制*/ queryRunner.update( connectionUtils.getThreadConnection(), "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; BeanFactory 代理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.water.proxy.factory;import cn.water.proxy.service.AccountService;import cn.water.proxy.utils.TransactionManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 【代理类】 * 创建代理Service类，让Service专注于业务层代码，由代理类来管理事务控制。 */public class BeanFactory &#123; /** * [持久层接口] */ private AccountService service; public void setService(AccountService service) &#123; this.service = service; &#125; /** * [事务控制工具类] */ private TransactionManager transactionManager; public void setTransactionManager(TransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; /*** * 【获取代理对象】 */ public AccountService getAccountService()&#123; return (AccountService) Proxy.newProxyInstance( service.getClass().getClassLoader(), service.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /* (1).设置返回值 */ Object rtValue = null; try &#123; /* 【开启事务】 */ transactionManager.turnONTransaction(); /* (2).根据参数，执行方法，获取返回值 */ rtValue = method.invoke(service, args); /* 【提交事务】 */ transactionManager.commitTransaction(); /* (3).返回结果 */ return rtValue; &#125; catch (Exception e) &#123; /* 【回滚事务】 */ transactionManager.rollbackTransaction(); throw new RuntimeException(e); &#125; finally &#123; /* 【释放连接】 */ transactionManager.closeTransaction(); &#125; &#125; &#125; ); &#125;&#125; XML 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- [代理业务层接口] --&gt; &lt;bean id="service_proxy" factory-bean="beanFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; &lt;!-- [BeanFactory] --&gt; &lt;bean id="beanFactory" class="cn.water.proxy.factory.BeanFactory"&gt; &lt;!-- 业务层接口实现 --&gt; &lt;property name="service" ref="serviceImp"&gt;&lt;/property&gt; &lt;!-- TransactionManager --&gt; &lt;property name="transactionManager" ref="transactionManager"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [业务层接口实现] --&gt; &lt;bean id="serviceImp" class="cn.water.proxy.service.AccountServiceImp"&gt; &lt;!-- 持久层接口 --&gt; &lt;property name="dao" ref="daoImp" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [TransactionManager] --&gt; &lt;bean id="transactionManager" class="cn.water.proxy.utils.TransactionManager"&gt; &lt;!-- ConnectionUtils --&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [持久层接口实现] --&gt; &lt;bean id="daoImp" class="cn.water.proxy.dao.AccountDaoImp"&gt; &lt;!-- QueryRunner --&gt; &lt;property name="queryRunner" ref="runner"&gt;&lt;/property&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [QueryRunner] --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;&lt;/bean&gt; &lt;!-- [ConnectionUtils] --&gt; &lt;bean id="connectionUtils" class="cn.water.proxy.utils.ConnectionUtils"&gt; &lt;!-- DataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Test 测试类123456789101112131415161718192021222324252627282930package cn.water.proxy;import cn.water.proxy.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:proxy/Beans.xml")public class AccountTest &#123; @Autowired @Qualifier("service_proxy") private AccountService service; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125; 工具类实现事务（AOP）Connection 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.water.aop.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 【Connection工具类】 */@Component("connectionUtils")public class ConnectionUtils &#123; /* 【ThreadLocal】 */ private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); /* 【DataSource】 */ @Autowired private DataSource dataSource; /** * 【返回或设置 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public Connection getThreadConnection() &#123; try &#123; /* (1).从当前线程上，获取数据库连接 */ Connection connection = threadLocal.get(); /* (2).判断该线程是否存在数据库连接 */ if (connection == null) &#123; /* (3).从数据库连接池中，获取数据库连接 */ connection = dataSource.getConnection(); /* (4).将数据库连接设置到该线程 */ threadLocal.set(connection); &#125; /* (5).返回数据库连接 */ return connection; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【销毁 当前线程上的数据库连接对象】 * @return 数据库连接对象 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; Transaction 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package cn.water.aop.utils;import org.aspectj.lang.annotation.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.sql.SQLException;/** * 【事务控制】 */@Component("transactionManager")@Aspectpublic class TransactionManager &#123; /** * [数据库连接工具类] * 用于事务控制 */ @Autowired private ConnectionUtils connectionUtils; /** * 【切入点】 */ @Pointcut("execution(* cn.water.aop.service.*.*(..))") private void selectAll()&#123;&#125; /** * 【开启事务】 */ @Before("selectAll()") public void turnONTransaction()&#123; try &#123; /* 设置自动提交为false */ connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【提交事务】 */ @AfterReturning("selectAll()") public void commitTransaction()&#123; try &#123; /* 提交事务 */ connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【回滚事务】 */ @AfterThrowing("selectAll()") public void rollbackTransaction()&#123; try &#123; /* 回滚事务 */ connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 【关闭事务】 */ @After("selectAll()") public void closeTransaction()&#123; try &#123; /* 返回至数据库连接池 */ connectionUtils.getThreadConnection().close(); /* 销毁 当前线程上的数据库连接对象 */ connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Domain 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.aop.domain;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; Service 业务层12345678910111213141516171819package cn.water.aop.service;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ void transfer(Integer sourceId, Integer targetId, Float money);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.water.aop.service;import cn.water.aop.dao.AccountDao;import cn.water.aop.domain.Account;import cn.water.aop.utils.TransactionManager;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * 【业务层接口实现】 */@Component("serviceImp")public class AccountServiceImp implements AccountService &#123; /** * [持久层接口] */ @Autowired private AccountDao dao; /** * [事务控制工具类] */ @Autowired private TransactionManager transactionManager; /** * 【转账】 * @param sourceId 转出账号 * @param targetId 转入账号 * @param money 金额 */ public void transfer(Integer sourceId, Integer targetId ,Float money)&#123; /* (1).根据账号，获取账户 */ Account source = dao.findById(sourceId); Account target = dao.findById(targetId); /* (2).设置账户信息 */ source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); /* (3).更新账户信息 */ dao.updateAccount(source); dao.updateAccount(target); /* (-1).异常 */// int i = 2/0; &#125;;&#125; Dao 持久层123456789101112131415161718192021222324252627282930313233package cn.water.aop.dao;import cn.water.aop.domain.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package cn.water.aop.dao;import cn.water.aop.domain.Account;import cn.water.aop.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */@Component("accountImp")public class AccountDaoImp implements AccountDao &#123; /** * [数据库操作类] */ @Autowired private QueryRunner queryRunner; /** * [数据库连接工具类] */ @Autowired private ConnectionUtils connectionUtils; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; Connection对象：事务控制 */ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account Connection对象：事务控制*/ return queryRunner.query( connectionUtils.getThreadConnection(), "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE * Connection对象：事务控制*/ queryRunner.update( connectionUtils.getThreadConnection(), "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; XML 配置文件1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置spring容器扫描的包 --&gt; &lt;context:component-scan base-package="cn.water.aop"&gt;&lt;/context:component-scan&gt; &lt;!-- [QueryRunner] --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;&lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Test 测试类12345678910111213141516171819202122232425262728package cn.water.aop;import cn.water.aop.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:aop/Beans.xml")public class AccountTest &#123; @Autowired @Qualifier("serviceImp") private AccountService service; /** * 【测试方法】 */ @Test public void test()&#123; service.transfer(2,1,100f); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring JDBC]]></title>
    <url>%2F2019%2F08%2F19%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_JDBC%2F</url>
    <content type="text"><![CDATA[JDBC 框架概述 在使用普通的 JDBC 数据库时，就会很麻烦的写不必要的代码来处理异常，打开和关闭数据库连接等。 但 Spring JDBC 框架负责所有的低层细节，从开始打开连接，准备和执行 SQL 语句，处理异常，处理事务，到最后关闭连接。 所以当从数据库中获取数据时，你所做的是定义连接参数，指定要执行的 SQL 语句，每次迭代完成所需的工作。 Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 JdbcTemplate 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。 JdbcTemplate 类 JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。 JdbcTemplate 类的实例是线程安全配置的。所以你可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。 使用 JdbcTemplate 类时常见的做法是在你的 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。 配置数据源 我们在 MySQL 数据库 eesy_spring 中创建一个数据库表 account。假设你正在使用 MySQL 数据库，如果你使用其他数据库，那么你可以改变你的 DDL 和相应的 SQL 查询。 1234567891011121314151617# 创建数据库CREATE DATABASE eesy_spring;# 使用数据库USE eesy_spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); 现在，我们需要提供一个数据源到 JdbcTemplate 中，所以它可以配置本身来获得数据库访问。你可以在 XML 文件中配置数据源，其中一段代码如下所示： 1234567&lt;bean id="dataSource"class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/TEST"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="password"/&gt;&lt;/bean&gt; 数据访问对象（DAO）DAO 代表常用的数据库交互的数据访问对象。DAOs 提供一种方法来读取数据并将数据写入到数据库中，它们应该通过一个接口显示此功能，应用程序的其余部分将访问它们。 在 Spring 中，数据访问对象(DAO)支持很容易用统一的方法使用数据访问技术，如 JDBC、Hibernate、JPA 或者 JDO。 Maven项目环境12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;spring_JDBC&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring JDBC框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 原始方法（1）测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package water.vs_jdbc;import cn.water.demo.domain.Account;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import java.sql.*;import java.util.List;/** * 比较几种JDBC操作的方式 */public class DaoTest &#123; /** * 【原始】 */ @Test public void testJdbc() throws SQLException, ClassNotFoundException &#123; /* (1).注册驱动 */ Class.forName("com.mysql.jdbc.Driver"); /* (2).获取数据库连接对象 */ Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy_spring", "root", "root"); /* (3).定义SQL语句 */ String s = "SELECT * FROM account;"; /* (4).获取执行SQL的对象Statement */ Statement statement = connection.createStatement(); /* (5).执行SQL */ ResultSet resultSet = statement.executeQuery(s); /* (6).处理结果 */ while (resultSet.next()) &#123;// 3.获取数据 int id = resultSet.getInt(1); String name = resultSet.getString(2); Float money = resultSet.getFloat(3);// 4.输出数据 System.out.println(id + "---" + name + "---" + money); &#125; /* (7).释放资源 */ statement.close(); connection.close(); &#125;&#125; Spring JDBC（1）测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package water.vs_jdbc;import cn.water.demo.domain.Account;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import java.sql.*;import java.util.List;/** * 比较几种JDBC操作的方式 */public class DaoTest &#123; /** * 【Spring JDBC 】 */ @Test public void testSpringJdbc() &#123; /* (1).创建连接池对象 */ DriverManagerDataSource dataSource = new DriverManagerDataSource(); /* (2).设置参数 */ dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/eesy_spring"); dataSource.setUsername("root"); dataSource.setPassword("root"); /* (3).创建JdbcTemplate对象 */ JdbcTemplate template = new JdbcTemplate(); /* (4).设置连接池对象 */ template.setDataSource(dataSource); /* (5).执行方法 */ List&lt;Account&gt; accountList = template.query("SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); /* (6).遍历集合 */ for (Account account : accountList) &#123; System.out.println(account); &#125; &#125;&#125; Spring JDBC + IoC（1）XML 配置文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DriverManagerDataSource --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_spring" &gt;&lt;/property&gt; &lt;property name="username" value="root" &gt;&lt;/property&gt; &lt;property name="password" value="root" &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; （2）测试类 1234567891011121314151617181920212223242526272829303132333435363738394041package water.vs_jdbc;import cn.water.demo.domain.Account;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import java.sql.*;import java.util.List;/** * 比较几种JDBC操作的方式 */public class DaoTest &#123; /** * 【Spring JDBC + Spring IoC】 */ @Test public void testSpringJdbcIoc() &#123; /* (1).创建容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("vs_jdbc/Beans.xml"); /* (2).获取对象 */ JdbcTemplate jdbcTemplate = applicationContext.getBean("jdbcTemplate", JdbcTemplate.class); /* (3).调用方法 */ List&lt;Account&gt; accountList = jdbcTemplate.query("SELECT * FROM account;", new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); /* (4).遍历结果集 */ for (Account account : accountList) &#123; System.out.println(account); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC 增删改查案例]]></title>
    <url>%2F2019%2F08%2F17%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_IoCTest%2F</url>
    <content type="text"><![CDATA[简介 本文将在 Spring 框架中，分别使用使用“XML”，“XML+注释”和“注解+Java”三种方式来实现数据库的CRUD操作。 数据库代码 创建数据库eesy_spring，在数据库中创建 Account表。 1234567891011121314151617# 创建数据库CREATE DATABASE eesy_spring;# 使用数据库USE eesy_spring;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT)CHARACTER SET utf8 COLLATE utf8_general_ci;# 插入数据INSERT INTO account(NAME,money) VALUES(&apos;Cat&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Dog&apos;,1000);INSERT INTO account(NAME,money) VALUES(&apos;Rat&apos;,1000); 基于XML配置文件 整个程序基于一下四大块： domain：用于存放实体类。 service：用于存放业务层的接口和实现类。 dao：用于存放持久层的接口和实现类。（具体的CRUD操作代码） test：用于测试。 实体类 domian 实体类根据数据库表中的列属性来设置成员变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.case_xml.domian;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service 由于此案例是为了演示操作数据库的CRUD方法，所以业务层并没有实现具体功能，而只是注入了持久层接口，调用了持久层方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.case_xml.service;import cn.water.case_xml.domian.Account;import java.util.List;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.water.case_xml.service;import cn.water.case_xml.dao.AccountDao;import cn.water.case_xml.domian.Account;import java.util.List;/** * 【业务层接口实现】 */public class AccountServiceImp implements AccountService&#123; /* 成员变量：持久层接口 */ private AccountDao dao; /* Setter方法：Spring依赖注入 */ public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; return dao.findById(id); &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; dao.saveAccount(account); &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; dao.updateAccount(account); &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; dao.deleteAccount(); &#125;&#125; 持久层 dao123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.water.case_xml.dao;import cn.water.case_xml.domian.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package cn.water.case_xml.dao;import cn.water.case_xml.domian.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */public class AccountDaoImp implements AccountDao&#123; /* 成员变量：持久层接口 */ private QueryRunner queryRunner; /* Setter方法：Spring依赖注入 */ public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; */ return queryRunner.query( "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account */ return queryRunner.query( "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; try &#123; /* query方法：INSERT */ queryRunner.update( "INSERT INTO account VALUES(?,?,?);", account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE */ queryRunner.update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; try &#123; /* query方法：DELETE */ queryRunner.update("DELETE FROM account WHERE id&gt;3 ;"); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; xml配置文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- [业务层接口实现] --&gt; &lt;bean id="serviceImp" class="cn.water.case_xml.service.AccountServiceImp"&gt; &lt;!-- 持久层接口实现 --&gt; &lt;property name="dao" ref="daoImp" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [持久层接口实现] --&gt; &lt;bean id="daoImp" class="cn.water.case_xml.dao.AccountDaoImp"&gt; &lt;!-- QueryRunner --&gt; &lt;property name="queryRunner" ref="runner"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- [QueryRunner] --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;!-- DataSource --&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package cn.water.case_xml;import cn.water.case_xml.domian.Account;import cn.water.case_xml.service.AccountService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class ServiceTest &#123; /** * 成员变量 */ private ApplicationContext appCon; private AccountService service; /** * 初始化方法 */ @Before public void init()&#123; /* 获取容器 */ appCon = new ClassPathXmlApplicationContext("case_xml/bean.xml"); /* 获取业务层对象 */ service = appCon.getBean("serviceImp",AccountService.class); &#125; /** * 【查询所有用户】 */ @Test public void testFindAll()&#123; List&lt;Account&gt; all = service.findAll(); for (Account account : all) &#123; System.out.println(account); &#125; &#125; /** * 【根据id查询用户】 */ @Test public void testFindOne()&#123; Account account = service.findById(1); System.out.println(account); &#125; /** * 【保存】 */ @Test public void testSave()&#123; Account account = new Account(4,"Bee",1000f); service.saveAccount(account); &#125; /** * 【更新】 */ @Test public void testUpdate()&#123; Account account = new Account(4,"newBee",2000f); service.updateAccount(account); &#125; /** * 【删除id大于3的用户】 */ @Test public void testDelete()&#123; service.deleteAccount(); &#125;&#125; 基于XML配置文件和注解实体类 domain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.case_xml_anno.domian;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.case_xml_anno.service;import cn.water.case_xml_anno.domian.Account;import java.util.List;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.water.case_xml_anno.service;import cn.water.case_xml_anno.dao.AccountDao;import cn.water.case_xml_anno.domian.Account;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.List;/** * 【业务层接口实现】 */@Component("serviceImp_xa")public class AccountServiceImp implements AccountService &#123; @Resource(name = "daoImp_xa") private AccountDao dao; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; return dao.findById(id); &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; dao.saveAccount(account); &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; dao.updateAccount(account); &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; dao.deleteAccount(); &#125;&#125; 持久层 dao123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.water.case_xml_anno.dao;import cn.water.case_xml_anno.domian.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package cn.water.case_xml_anno.dao;import cn.water.case_xml_anno.domian.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */@Component("daoImp_xa")public class AccountDaoImp implements AccountDao &#123; @Resource(name = "runner") private QueryRunner queryRunner; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; */ return queryRunner.query( "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account */ return queryRunner.query( "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; try &#123; /* query方法：INSERT */ queryRunner.update( "INSERT INTO account VALUES(?,?,?);", account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE */ queryRunner.update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; try &#123; /* query方法：DELETE */ queryRunner.update("DELETE FROM account WHERE id&gt;3 ;"); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; xml配置文件1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 【注释扫描】 --&gt; &lt;context:component-scan base-package="cn.water.case_xml_anno"&gt;&lt;/context:component-scan&gt; &lt;!-- [QueryRunner] --&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;!-- DataSource --&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- [DataSource] --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy_spring"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.water.case_xml_anno;import cn.water.case_xml_anno.domian.Account;import cn.water.case_xml_anno.service.AccountService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class ServiceTest &#123; /** * 成员变量 */ private ApplicationContext appCon; private AccountService service; /** * 初始化方法 */ @Before public void init()&#123; /* 获取容器 */ appCon = new ClassPathXmlApplicationContext("case_xml_anno/bean.xml"); /* 获取业务层对象 */ service = appCon.getBean("serviceImp_xa",AccountService.class); &#125; /** * 【查询所有用户】 */ @Test public void testFindAll()&#123; List&lt;Account&gt; all = service.findAll(); for (Account account : all) &#123; System.out.println(account); &#125; &#125; /** * 【根据id查询用户】 */ @Test public void testFindOne()&#123; Account account = service.findById(1); System.out.println(account); &#125; /** * 【保存】 */ @Test public void testSave()&#123; Account account = new Account(4,"Bee",1000f); service.saveAccount(account); &#125; /** * 【更新】 */ @Test public void testUpdate()&#123; Account account = new Account(4,"newBee",2000f); service.updateAccount(account); &#125; /** * 【删除id大于3的用户】 */ @Test public void testDelete()&#123; service.deleteAccount(); &#125;&#125; 基于Java配置文件和注解实体类 domain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.water.case_java_anno.domian;/** * 实体类 */public class Account &#123; /** * 成员变量 */ private Integer id; private String name; private Float money; /** * 无参构造 */ public Account() &#123; &#125; /** * 带参构造 * @param id * @param name * @param money */ public Account(Integer id, String name, Float money) &#123; this.id = id; this.name = name; this.money = money; &#125; /*** * toString方法 * @return */ @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; /*** * Setter、Getter方法 */ public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 业务层 service1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.water.case_java_anno.service;import cn.water.case_java_anno.domian.Account;import java.util.List;/** * 【业务层接口】 */public interface AccountService &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.water.case_java_anno.service;import cn.water.case_java_anno.dao.AccountDao;import cn.water.case_java_anno.domian.Account;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.List;/** * 【业务层接口实现】 */@Component("serviceImp_ja")public class AccountServiceImp implements AccountService &#123; @Resource(name = "daoImp_ja") private AccountDao dao; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; return dao.findById(id); &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; dao.saveAccount(account); &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; dao.updateAccount(account); &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; dao.deleteAccount(); &#125;&#125; 持久层 dao123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.water.case_java_anno.dao;import cn.water.case_java_anno.domian.Account;import java.util.List;/** * 【持久层接口】 */public interface AccountDao &#123; /** * 【查询】 * @return 返回Account的List集合 */ List&lt;Account&gt; findAll(); /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ Account findById(Integer id); /** * 【保存】 * @param account 根据用户信息 Account */ void saveAccount(Account account); /** * 【更新】 * @param account 根据用户信息 Account */ void updateAccount(Account account); /** * 【删除】 * 删除所有id大于3的用户 */ void deleteAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package cn.water.case_java_anno.dao;import cn.water.case_java_anno.domian.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.sql.SQLException;import java.util.List;/** * 【持久层接口实现】 */@Component("daoImp_ja")public class AccountDaoImp implements AccountDao &#123; @Autowired private QueryRunner queryRunner; /** * 【查询】 * @return 返回Account的List集合 */ public List&lt;Account&gt; findAll() &#123; try &#123; /* query方法：SELECT BeanListHandler对象：List&lt;Account&gt; */ return queryRunner.query( "SELECT * FROM account;", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /*** * 【查询】 * @param id 根据用户 id * @return 返回 Account */ public Account findById(Integer id) &#123; try &#123; /* query方法：SELECT BeanHandler对象：Account */ return queryRunner.query( "SELECT * FROM account WHERE id = ? ;", new BeanHandler&lt;Account&gt;(Account.class) ,id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【保存】 * @param account 根据用户信息 Account */ public void saveAccount(Account account) &#123; try &#123; /* query方法：INSERT */ queryRunner.update( "INSERT INTO account VALUES(?,?,?);", account.getId(), account.getName(), account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【更新】 * @param account 根据用户信息 Account */ public void updateAccount(Account account) &#123; try &#123; /* query方法：UPDATE */ queryRunner.update( "UPDATE account SET name=?,money=? WHERE id=? ;", account.getName(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 【删除】 * 删除所有id大于3的用户 */ public void deleteAccount() &#123; try &#123; /* query方法：DELETE */ queryRunner.update("DELETE FROM account WHERE id&gt;3 ;"); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; properties配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesy_springjdbc.username=rootjdbc.password=root java配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.water.case_java_anno.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbutils.QueryRunner;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.*;import javax.sql.DataSource;import java.beans.PropertyVetoException;@Configuration /* 指定Java配置文件 */@ComponentScan("cn.water.case_java_anno") /* 注释扫描 */@PropertySource("classpath:case_java_anno/jdbcConfig.properties") /* 指定properties文件 */public class SpringConfiguration &#123; /** * [QueryRunner] */ @Bean @Scope("prototype") public QueryRunner getQR(@Qualifier("dataSource_ja") DataSource getDS)&#123; return new QueryRunner(getDS()); &#125; /** * [DataSource] */ @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean("dataSource_ja") /* 如果有第二个getDS方法，@Bean("dataSource_ja") */ public DataSource getDS()&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); try &#123; dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return dataSource; &#125;&#125; 测试类 test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.water.case_java_anno;import cn.water.case_java_anno.config.SpringConfiguration;import cn.water.case_java_anno.domian.Account;import cn.water.case_java_anno.service.AccountService;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class ServiceTest &#123; @Resource(name = "serviceImp_ja") private AccountService service; /** * 【查询所有用户】 */ @Test public void testFindAll()&#123; List&lt;Account&gt; all = service.findAll(); for (Account account : all) &#123; System.out.println(account); &#125; &#125; /** * 【根据id查询用户】 */ @Test public void testFindOne()&#123; Account account = service.findById(1); System.out.println(account); &#125; /** * 【保存】 */ @Test public void testSave()&#123; Account account = new Account(4,"Bee",1000f); service.saveAccount(account); &#125; /** * 【更新】 */ @Test public void testUpdate()&#123; Account account = new Account(4,"newBee",2000f); service.updateAccount(account); &#125; /** * 【删除id大于3的用户】 */ @Test public void testDelete()&#123; service.deleteAccount(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 注解]]></title>
    <url>%2F2019%2F08%2F16%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_Anno%2F</url>
    <content type="text"><![CDATA[Spring 基于注解的配置 在使用基于注解的注入依赖之前，我们需要在 Spring 配置文件中指定需要 Spring 去自动扫描出注解配置的文件的包。 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置需要扫描的包：告知spring在创建容器时需要扫描的包。--&gt; &lt;context:component-scan base-package="cn.water.Annotation"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 一旦 被配置后，你就可以开始注解你的代码，表明 Spring 会自动连接值到属性，方法和构造函数。让我们来看看几个重要的注解，并且了解它们是如何工作的。 定义 @Component 注解：用于定义一个 Spring Bean。 Value属性：用于指定 Spring Bean 的 唯一标识 id。 默认为当前类名，首字母小写。 另外，和 @Component 注解功能相同的注解还有另外三个，除了定义 Spring Bean 的功能之外，它们主要用于标识三层构架： @Controller：表现层 @Service：业务层 @Repository：持久层 （1）POJO类 12345678package cn.water.Annotation.Component;import org.springframework.stereotype.Component;@Component("pojoBean")public class POJO &#123;&#125; （2）测试类 123456789101112131415161718192021package cn.water.Annotation.Component;import cn.water.spring_DI.constructor_based.User;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Annotation/Component/Beans.xml"); /* 2.获取对象 */ POJO pojo = applicationContext.getBean("pojoBean" , POJO.class); /* 3.输出对象 */ System.out.println(pojo); &#125;&#125; （3）运行结果 1cn.water.Annotation.Component.POJO@3b94d659 作用范围 @scope注解：用于指定Bean对象的作用范围。 Value属性：singleton单例（默认）、prototype多例 singleton单例（1）POJO类 12345678910package cn.water.Annotation.Scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component("pojoBean_singleton")@Scope("singleton")public class POJO &#123;&#125; （2）测试类 123456789101112131415161718192021package cn.water.Annotation.Scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo1 = applicationContext.getBean("pojoBean_singleton" , POJO.class); POJO pojo2 = applicationContext.getBean("pojoBean_singleton" , POJO.class); /* 3.输出对象 */ System.out.println(pojo1); System.out.println(pojo2); &#125;&#125; （3）运行结果 12cn.water.Annotation.Scope.POJO@7e9a5fbecn.water.Annotation.Scope.POJO@7e9a5fbe prototype多例（1）POJO类 12345678910package cn.water.Annotation.Scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component("pojoBean_prototype")@Scope("prototype")public class POJO02 &#123;&#125; （2）测试类 123456789101112131415161718192021package cn.water.Annotation.Scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp02 &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO02 pojo1 = applicationContext.getBean("pojoBean_prototype" , POJO02.class); POJO02 pojo2 = applicationContext.getBean("pojoBean_prototype" , POJO02.class); /* 3.输出对象 */ System.out.println(pojo1); System.out.println(pojo2); &#125;&#125; （3）运行结果 12cn.water.Annotation.Scope.POJO02@7e9a5fbecn.water.Annotation.Scope.POJO02@44a3ec6b 生命周期 @PreDestroy：用于指定Bean对象的销毁方法。 @PostConstruct：用于指定Bean对象的初始化方法。 （1）POJO类 12345678910111213141516171819202122package cn.water.Annotation.LifeCycle;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Component("pojoBean_life")public class POJO &#123; @PostConstruct public void init()&#123; System.out.println("初始化~~~"); &#125; @PreDestroy public void destroy()&#123; System.out.println("销毁!!!"); &#125;&#125; （2）测试类 12345678910111213141516171819package cn.water.Annotation.LifeCycle;import org.springframework.context.ApplicationContext;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ AbstractApplicationContext abstractAppContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo = abstractAppContext.getBean("pojoBean_life" , POJO.class); /* 3.释放容器 */ abstractAppContext.registerShutdownHook(); &#125;&#125; （3）运行结果 12初始化~~~销毁!!! 生命周期的作用范围单例（1）POJO类 1234567891011121314151617181920212223package cn.water.Annotation.Life_Scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Component("pojoBean_life_singleton")@Scope("singleton")public class POJO &#123; @PostConstruct public void init()&#123; System.out.println("初始化~~~"); &#125; @PreDestroy public void destroy()&#123; System.out.println("销毁!!!"); &#125;&#125; （2）测试类 123456789101112131415161718package cn.water.Annotation.Life_Scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */// POJO pojo1 = applicationContext.getBean("pojoBean_life_singleton" , POJO.class);// POJO pojo2 = applicationContext.getBean("pojoBean_life_singleton" , POJO.class); /* 3.释放资源 */ ((ClassPathXmlApplicationContext)applicationContext).close(); &#125;&#125; （3）运行结果 1234初始化~~~初始化~~~销毁!!!销毁!!! 立即加载非常符合单例模式的特点，ApplicationContext就属于立即加载，所以会立即加载所有的POJO对象，即使我们还没有获取对象。 所以一旦我们创建 ApplicationContext 容器，POJO对象就创建了；一旦我们注销 ApplicationContext 容器，POJO对象就销毁了。 多例（1）POJO类 123456789101112131415161718192021222324package cn.water.Annotation.Life_Scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Component("pojoBean_life_prototype")@Scope("prototype")public class POJO02 &#123; @PostConstruct public void init()&#123; System.out.println("初始化~~~"); &#125; @PreDestroy public void destroy()&#123; System.out.println("销毁!!!"); &#125;&#125; （2）测试类 12345678910111213141516171819package cn.water.Annotation.Life_Scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp02 &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO02 pojo1 = applicationContext.getBean("pojoBean_life_prototype" , POJO02.class); POJO02 pojo2 = applicationContext.getBean("pojoBean_life_prototype" , POJO02.class); /* 3.释放资源 */ ((ClassPathXmlApplicationContext)applicationContext).close(); &#125;&#125; （3）运行结果 123456初始化~~~初始化~~~初始化~~~初始化~~~销毁!!!销毁!!! 作用范围是多例模式时，运行结果有一些奇怪，让我们来分析一下。 前面我们讲到了单例模式的特点，一旦我们创建 ApplicationContext 容器，POJO对象就创建了；一旦我们注销 ApplicationContext 容器，POJO对象就销毁了。 但多例模式不同，因为多例模式更符合延迟加载，也就是 BeanFactory 容器。而此处如果我们还是使用 ApplicationContext 容器的话，那么 ApplicationContext 容器 的特点就会失效，并且改成 BeanFactory 容器的特点。 就是说，只有我们从容器中获取POJO对象时，POJO对象才会被创建；而且只有POJO对象被销毁时，销毁方法才会执行。 所以前两条初始化和后两条销毁，是由于创建了 ApplicationContext 容器，所以创建了上一个实例中单例模式的POJO类。 而多例模式的POJO类在我们从容器中获取对象时，执行了初始化方法；而对象的销毁需要通过 Java JVM 的回收机制来控制，不是由 ApplicationContext 容器 控制的。 依赖注入 基于注解的依赖注入，不需要构造方法或者Setter方法。 @Resource注释：直接按照Bean对象的Id注入。 name属性：通过 @Component 的 Value 属性来 工作原理 Spring IoC 容器的原理：Map集合。在 @Resource 注解中，Spring 框架先对应Bean的Key。 POJOBean Key：@Component 注释 Value属性值：pojoBean_resource Value：被 @Component 注释的类（包括父类和接口）：POJOBean POJO 对应Key：@Resource注解的name属性值：pojoBean_resource （1）POJOBean 123456789package cn.water.Annotation.Resource;import org.springframework.stereotype.Component;@Component("pojoBean_resource")public class POJOBean &#123;&#125; （2）POJO 123456789101112131415161718package cn.water.Annotation.Resource;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component("pojo_resource")public class POJO &#123; /* @Resource注解，依赖注入 */ @Resource(name = "pojoBean_resource") private POJOBean bean; /* Getter方法，测试是否注入成功 */ public POJOBean getBean() &#123; return bean; &#125;&#125; （3）测试类 12345678910111213141516171819package cn.water.Annotation.Resource;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ AbstractApplicationContext abstractAppContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo = abstractAppContext.getBean("pojo_resource" , POJO.class); /* 3.释放容器 */ System.out.println("POJO："+pojo); System.out.println("POJOBean："+pojo.getBean()); &#125;&#125; （4）运行结果 12POJO：cn.water.Annotation.Resource.POJO@f4168b8POJOBean：cn.water.Annotation.Resource.POJOBean@3bd94634 自动装配@Autowired 工作原理 在 @Autowired 注解中，Spring 框架先对应Bean的Value而不是Key。 POJOBean Key：@Component 注释 Value属性值：pojoBean_autowired Value：被 @Component 注释的类：POJOBean POJO 对应Value：被 @Autowired 注释的类成员的类型：POJOBean （1）POJOBean 123456789package cn.water.Annotation.Autowired;import org.springframework.stereotype.Component;@Component("pojoBean_autowired")public class POJOBean &#123;&#125; （2）POJO 12345678910111213141516171819package cn.water.Annotation.Autowired;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component("pojo_autowired")public class POJO &#123; /* @Resource注解，依赖注入 */ @Autowired private POJOBean bean; /* Getter方法，测试是否注入成功 */ public POJOBean getBean() &#123; return bean; &#125;&#125; （3）测试类 12345678910111213141516171819package cn.water.Annotation.Autowired;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ AbstractApplicationContext abstractAppContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo = abstractAppContext.getBean("pojo_autowired" , POJO.class); /* 3.释放容器 */ System.out.println("POJO："+pojo); System.out.println("POJOBean："+pojo.getBean()); &#125;&#125; （4）运行结果 12POJO：cn.water.Annotation.Autowired.POJO@f4168b8POJOBean：cn.water.Annotation.Autowired.POJOBean@3bd94634 @Qualifier @Qualifier：解决注入相同的数据类型，就不能使用相同的变量名的问题。 在类成员上使用时，必须和@Autowired一起使用。在方法上，可以单独使用。 相当于将发现相同Dao数据类型时，比较Key值（变量名）的事情，交给了Qualifier的Value属性。 （1）POJOBean 123456789package cn.water.Annotation.Qualifier;import org.springframework.stereotype.Component;@Component("pojoBean_qualifier")public class POJOBean &#123;&#125; （2）POJO 1234567891011121314151617181920package cn.water.Annotation.Qualifier;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;@Component("pojo_qualifier")public class POJO &#123; /* @Resource注解，依赖注入 */ @Autowired @Qualifier("pojoBean_qualifier") private POJOBean bean; /* Getter方法，测试是否注入成功 */ public POJOBean getBean() &#123; return bean; &#125;&#125; （3）测试类 12345678910111213141516171819package cn.water.Annotation.Qualifier;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ AbstractApplicationContext abstractAppContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo = abstractAppContext.getBean("pojo_qualifier" , POJO.class); /* 3.释放容器 */ System.out.println("POJO："+pojo); System.out.println("POJOBean："+pojo.getBean()); &#125;&#125; （4）运行结果 12POJO：cn.water.Annotation.Qualifier.POJO@40f08448POJOBean：cn.water.Annotation.Qualifier.POJOBean@276438c9 @Value @Value：自动按照类型注入。 它可以使用spring中SqEL表达式。 （1）POJOBean 1234567891011121314package cn.water.Annotation.Value;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component("pojoBean_value")public class POJOBean &#123; /* 成员变量权限修饰符：public */ @Value("#&#123;'Dog'&#125;") public String pojoBeanString;&#125; （2）POJO 123456789101112131415161718192021222324252627282930package cn.water.Annotation.Value;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component("pojo_value")public class POJO &#123; @Value("#&#123;'Cat'&#125;") private String string ; @Value("#&#123;999&#125;") private int i ; @Value("#&#123;pojoBean_value&#125;") private POJOBean pojoBean ; @Value("#&#123;pojoBean_value.pojoBeanString&#125;") private String pojoBeanString ; @Override public String toString() &#123; return "POJO&#123;" + "string='" + string + '\'' + ", i=" + i + ", pojoBean=" + pojoBean + ", pojoBeanString='" + pojoBeanString + '\'' + '&#125;'; &#125;&#125; （3）测试类 123456789101112131415161718package cn.water.Annotation.Value;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ AbstractApplicationContext abstractAppContext = new ClassPathXmlApplicationContext("Annotation/Beans.xml"); /* 2.获取对象 */ POJO pojo = abstractAppContext.getBean("pojo_value" , POJO.class); /* 3.释放容器 */ System.out.println("POJO："+pojo); &#125;&#125; （4）运行结果 1POJO：POJO&#123;string=&apos;Cat&apos;, i=999, pojoBean=cn.water.Annotation.Value.POJOBean@4461c7e3, pojoBeanString=&apos;Dog&apos;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 依赖注入]]></title>
    <url>%2F2019%2F08%2F15%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_DI%2F</url>
    <content type="text"><![CDATA[Spring 依赖注入 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。 每个基于应用程序的 java 多多少少都会使用几个对象，最后与这些对象一起工作来呈现出终端用户所看到的工作的应用程序。 依赖注入有助于把这些类粘合在一起，同时保持他们独立。 全面控制 假设你现在正在编写一个文本编辑器的应用程序，并且想要添加拼写检查的功能，那么你就需要在TextEditor类中使用SpellChecker类。 标准代码看起来是这样的：123456789public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor() &#123; spellChecker = new SpellChecker(); &#125; &#125; 控制反转 而在 Spring 框架中，我们需要做的则是创建一个 TextEditor 和 SpellChecker 之间的依赖关系。 在控制反转的场景中，我们反而会做这样的事情：12345678public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125; 结论 在 Spring 框架的控制下，TextEditor 不需要担心 SpellChecker 的实现。SpellChecker 将会独立实现，并且在 TextEditor 实例化的时候将提供给 TextEditor。 我们从 TextEditor 中删除了全面控制，并且把它保存到其他地方（即 XML 配置文件），且依赖关系通过类构造函数被注入到 TextEditor 类中。因此，控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。 对象不查找它的依赖关系，也不知道依赖关系的位置或类，而这一切都由 Spring 框架控制的。 Spring 基于构造函数的依赖注入 当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。 POJO类 接下来，我们将依然通过 TextEditor 和 SpellChecker 的示例来理解 Spring 基于构造函数的依赖注入。 本例中，我们首先在XML配置中，对 TextEditor 的构造参数中注入 SpellChecker。这样一来，一旦我们实例化 TextEditor ，Spring 就会在 TextEditor 的带参构造函数中传入其参数 SpellChecker 。 优点：在获取Bean对象时，必须注入构造参数，否则对象无法创建成功。 缺点：改变了Bean对象实例化的方式，我们在创建的对象时，用不到的数据，也必须提供。 （1）TextEditor 123456789101112131415161718package cn.water.spring_DI.constructor_based;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* 构造方法 */ public TextEditor(SpellChecker spellChecker) &#123; System.out.println("TextEditor constructor" ); this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker 1234567891011121314package cn.water.spring_DI.constructor_based;public class SpellChecker &#123; /* SpellChecker的构造方法 */ public SpellChecker()&#123; System.out.println("SpellChecker constructor" ); &#125; /* SpellChecker的成员方法 */ public void checkSpelling() &#123; System.out.println("checkSpelling..." ); &#125;&#125; （3）Beans.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- TextEditor constructor-arg标签：表示一个成员变量 ref属性：表示Bean容器的引用，值为Bean容器的id --&gt; &lt;bean id="textEditor" class="cn.water.spring_DI.constructor_based.TextEditor"&gt; &lt;!-- 构造函数 --&gt; &lt;constructor-arg ref="spellChecker"/&gt; &lt;/bean&gt; &lt;!-- SpellChecker --&gt; &lt;bean id="spellChecker" class="cn.water.spring_DI.constructor_based.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 1234567891011121314151617package cn.water.spring_DI.constructor_based;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_DI/constructor_based/Beans.xml"); /* 2.获取对象 */ TextEditor textEditor = applicationContext.getBean("textEditor" ,TextEditor.class); /* 3.调用方法 */ textEditor.spellCheck(); &#125;&#125; （5）结果 123SpellChecker constructorTextEditor constructorcheckSpelling... 基本数据类型（1）User 123456789101112131415161718192021package cn.water.spring_DI.constructor_based;public class User &#123; /* 成员变量 */ private Integer id; private String name; private Integer age; /* 构造函数 */ public User(Integer id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; &#125; /* 成员方法 */ public void show ()&#123; System.out.println("id："+id+",name:"+name+",age:"+age); &#125;&#125; （2）Beans.xml：方法一 123456789&lt;!-- User constructor-arg标签：表示一个成员变量 name属性：表示成员变量的名称 value属性：表示成员变量的值 --&gt;&lt;bean id="user1" class="cn.water.spring_DI.constructor_based.User"&gt; &lt;constructor-arg name="id" value="001"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="Cat"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="11"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; （2）Beans.xml：方法二 12345678&lt;!-- User index属性：指定成员变量的顺序 value属性：指定成员变量的值 --&gt;&lt;bean id="user2" class="cn.water.spring_DI.constructor_based.User"&gt; &lt;constructor-arg index="0" value="001"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="Cat"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="2" value="11"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; （3）测试类 1234567/* 1.获取容器 */ApplicationContext applicationContext= new ClassPathXmlApplicationContext("spring_DI/constructor_based/Beans.xml");/* 2.获取对象 */User user = applicationContext.getBean("user1" ,User.class);/* 3.调用方法 */user.show(); （5）结果 1id：1,name:Cat,age:11 Spring 基于设值函数的依赖注入 当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数Setter，基于设值函数的 DI 就完成了。 你应该注意定义在基于构造函数注入和基于设值函数注入中的 Beans.xml 文件的区别。唯一的区别就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的〈property〉元素。 第二个你需要注意的点是，如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。 优点：Bean对象实例化的方式不变，可以直接使用默认构造函数。 缺点：不能保证所有的类成员都被注入了，即使是必须有值的成员。 POJO类（1）TextEditor 12345678910111213141516171819package cn.water.spring_DI.setter_based;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* Setter方法 */ public void setSpellChecker(SpellChecker spellChecker) &#123; System.out.println("TextEditor setSpellChecker." ); this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker 1234567891011121314package cn.water.spring_DI.setter_based;public class SpellChecker &#123; /* SpellChecker的构造方法 */ public SpellChecker()&#123; System.out.println("SpellChecker constructor" ); &#125; /* SpellChecker的成员方法 */ public void checkSpelling() &#123; System.out.println("checkSpelling..." ); &#125;&#125; （3）Beans.xml 123456789&lt;!-- TextEditor--&gt;&lt;bean id="textEditor" class="cn.water.spring_DI.setter_based.TextEditor"&gt; &lt;!-- Setter方法 property标签：表示一个Setter方法 --&gt; &lt;property name="spellChecker" ref="spellChecker"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- SpellChecker --&gt;&lt;bean id="spellChecker" class="cn.water.spring_DI.setter_based.SpellChecker"&gt;&lt;/bean&gt; （4）测试类 1234567891011121314151617package cn.water.spring_DI.constructor_based;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_DI/setter_based/Beans.xml"); /* 2.获取对象 */ TextEditor textEditor = applicationContext.getBean("textEditor" ,TextEditor.class); /* 3.调用方法 */ textEditor.spellCheck(); &#125;&#125; （5）结果 123SpellChecker constructorTextEditor setSpellCheckercheckSpelling... 使用 p-namespace 实现 XML 配置标准 XML 配置文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 标签 --&gt; &lt;bean id="textEditor" class="cn.water.spring_DI.setter_based.TextEditor"&gt; &lt;propertyc name="spellChecker" ref="spellChecker"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="spellChecker" class="cn.water.spring_DI.setter_based.SpellChecker"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用 p-namespace 的 XML 配置文件 导入第四行另外的命名空间 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- p-namespace--&gt; &lt;bean id="textEditor2" class="cn.water.spring_DI.setter_based.TextEditor" p:spellChecker-ref="spellChecker" /&gt; &lt;bean id="spellChecker2" class="cn.water.spring_DI.setter_based.SpellChecker"/&gt;&lt;/beans&gt; Spring 注入内部 Beans 正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。 inner beans 不需要写 id属性，因为它无法被其他Bean对象访问。 （1）TextEditor （2）SpellChecker （3）Beans.xml 1234567&lt;!-- TextEditor--&gt;&lt;bean id="textEditor" class="cn.water.spring_DI.inner_based.TextEditor"&gt; &lt;property name="spellChecker"&gt; &lt;bean class="cn.water.spring_DI.inner_based.SpellChecker"/&gt; &lt;/property&gt;&lt;/bean&gt; （4）测试类 （5）结果 123SpellChecker constructorTextEditor setSpellCheckercheckSpelling... Spring 注入集合（1）JavaCollection 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.water.spring_DI.collection;import java.util.*;public class JavaCollection &#123; List addressList; Set addressSet; Map addressMap; Properties addressProp; // a setter method to set List public void setAddressList(List addressList) &#123; this.addressList = addressList; &#125; // prints and returns all the elements of the list. public List getAddressList() &#123; System.out.println("List Elements :" + addressList); return addressList; &#125; // a setter method to set Set public void setAddressSet(Set addressSet) &#123; this.addressSet = addressSet; &#125; // prints and returns all the elements of the Set. public Set getAddressSet() &#123; System.out.println("Set Elements :" + addressSet); return addressSet; &#125; // a setter method to set Map public void setAddressMap(Map addressMap) &#123; this.addressMap = addressMap; &#125; // prints and returns all the elements of the Map. public Map getAddressMap() &#123; System.out.println("Map Elements :" + addressMap); return addressMap; &#125; // a setter method to set Property public void setAddressProp(Properties addressProp) &#123; this.addressProp = addressProp; &#125; // prints and returns all the elements of the Property. public Properties getAddressProp() &#123; System.out.println("Property Elements :" + addressProp); return addressProp; &#125;&#125; （2）Beans.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- JavaCollection --&gt; &lt;bean id="javaCollection" class="cn.water.spring_DI.collection.JavaCollection"&gt; &lt;!-- List集合 --&gt; &lt;property name="addressList"&gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set集合（不允许重复） --&gt; &lt;property name="addressSet"&gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map集合 --&gt; &lt;property name="addressMap"&gt; &lt;map&gt; &lt;entry key="1" value="INDIA"/&gt; &lt;entry key="2" value="Pakistan"/&gt; &lt;entry key="3" value="USA"/&gt; &lt;entry key="4" value="USA"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Properties --&gt; &lt;property name="addressProp"&gt; &lt;props&gt; &lt;prop key="one"&gt;INDIA&lt;/prop&gt; &lt;prop key="two"&gt;Pakistan&lt;/prop&gt; &lt;prop key="three"&gt;USA&lt;/prop&gt; &lt;prop key="four"&gt;USA&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 1234567891011121314151617181920package cn.water.spring_DI.collection;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext context = new ClassPathXmlApplicationContext("spring_DI/collection/Beans.xml"); /* 2.获取对象 */ JavaCollection jc=(JavaCollection)context.getBean("javaCollection"); /* 3.执行方法 */ jc.getAddressList(); jc.getAddressSet(); jc.getAddressMap(); jc.getAddressProp(); &#125;&#125; （5）结果 1234List Elements :[INDIA, Pakistan, USA, USA]Set Elements :[INDIA, Pakistan, USA]Map Elements :&#123;1=INDIA, 2=Pakistan, 3=USA, 4=USA&#125;Property Elements :&#123;two=Pakistan, one=INDIA, three=USA, four=USA&#125; 注入 null 和空字符的值 如果你需要传递一个空字符串作为值，那么你可以传递它，如下所示： 相当于 Java 代码：exampleBean.setEmail(“”) 123&lt;bean id="..." class="exampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt; 如果你需要传递一个 NULL 值，那么你可以传递它，如下所示： 相当于 Java 代码：exampleBean.setEmail(null) 123&lt;bean id="..." class="exampleBean"&gt; &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 自动装配]]></title>
    <url>%2F2019%2F08%2F15%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_autowire%2F</url>
    <content type="text"><![CDATA[Spring Beans 自动装配 你已经学会如何使用&lt;bean&gt;元素来声明 bean 和通过使用 XML 配置文件中的&lt;constructor-arg&gt;和&lt;property&gt;元素来注入 。 而Spring 容器还可以在不使用&lt;constructor-arg&gt;和&lt;property&gt; 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。 自动装配模式 下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用&lt;bean&gt;元素的 autowire 属性为一个 bean 定义指定自动装配模式。 no 默认设置，它意味着没有自动装配，表示我们需要使用显式的bean引用来注入依赖。 byName 由属性名自动装配。 Spring 先匹配POJO类的类成员名称与配置文件中&lt;bean&gt;标签的id属性，如果名称相同，则匹配类型；类型相同，则配对成功。 byType 由属性数据类型自动装配。 Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 constructor 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 autodetect Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。 自动装配的局限性 当自动装配始终在同一个项目中使用时，它的效果最好。如果通常不使用自动装配，它可能会使开发人员混淆的使用它来连接只有一个或两个 bean 定义。 不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。 重写的可能性 你可以使用总是重写自动装配的 &lt;constructor-arg&gt;和 &lt;property&gt; 设置来指定依赖关系。 原始数据类型 你不能自动装配所谓的简单类型包括基本类型，字符串和类。 混乱的本质 自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。 Spring 自动装配 ‘byName’ 这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 auto-wire 属性设置为 byName。然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为自动装配 byName，并且它包含 spellChecker 属性（即，它有一个 setSpellChecker(…) 方法），那么 Spring 就会查找定义名为 spellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用 &lt;property&gt; 标签连接其余的属性。下面的例子将说明这个概念。 （1）TextEditor 12345678910111213141516171819202122package cn.water.spring_autowire.byName;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* Setter方法 */ public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; /* Getter方法 */ public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker 1234567891011121314package cn.water.spring_autowire.byName;public class SpellChecker &#123; /* 构造函数 */ public SpellChecker()&#123; System.out.println("SpellChecker constructor" ); &#125; /* 成员方法 */ public void checkSpelling() &#123; System.out.println("checkSpelling..." ); &#125;&#125; （3）Beans.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- TextEditor --&gt; &lt;bean id="textEditor" class="cn.water.spring_autowire.byName.TextEditor" autowire="byName"&gt; &lt;/bean&gt; &lt;!-- SpellChecker id属性：类成员名称 --&gt; &lt;bean id="spellChecker" class="cn.water.spring_autowire.byName.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 12345678910111213141516package cn.water.spring_autowire.byName;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; /* 1.获取容器 */ ApplicationContext context = new ClassPathXmlApplicationContext("spring_autowire/byName/Beans.xml"); /* 2.获取对象 */ TextEditor editor = (TextEditor) context.getBean("textEditor"); /* 3.调用方法 */ editor.spellCheck(); &#125;&#125; （5）结果 12SpellChecker constructorcheckSpelling... Spring 自动装配 ‘byType’ 这种模式由属性类型指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire 属性设置为 byType。然后，如果它的 type 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为自动装配 byType*，并且它包含 *SpellChecker 类型的 spellChecker 属性，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用&lt;property&gt; 标签连接其余属性。下面的例子将说明这个概念，你会发现和上面的例子没有什么区别，除了 XML 配置文件已经被改变。 （1）TextEditor 1234567891011121314151617package cn.water.spring_autowire.byType;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* Setter方法 */ public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker（3）Beans.xml 1234567891011&lt;!-- TextEditor --&gt;&lt;bean id="textEditor" class="cn.water.spring_autowire.byType.TextEditor" autowire="byType"&gt;&lt;/bean&gt;&lt;!-- SpellChecker id属性：类型名称 --&gt;&lt;bean id="SpellChecker" class="cn.water.spring_autowire.byType.SpellChecker"&gt;&lt;/bean&gt; （4）测试类（5）结果 12SpellChecker constructorcheckSpelling... Spring 由构造函数自动装配 这种模式与 byType 非常相似，但它应用于构造器参数。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire属性设置为 constructor。然后，它尝试把它的构造函数的参数与配置文件中 beans 名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些 bean，否则，它会抛出异常。 例如，在配置文件中，如果一个 bean 定义设置为通过构造函数*自动装配，而且它有一个带有 *SpellChecker 类型的参数之一的构造函数，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并用它来设置构造函数的参数。你仍然可以使用 &lt;constructor-arg&gt; 标签连接其余属性。下面的例子将说明这个概念。 （1）TextEditor 将Setter方法变为构造方法 1234567891011121314151617package cn.water.spring_autowire.byName;public class TextEditor &#123; /* 成员变量 */ private SpellChecker spellChecker; /* 构造方法 */ public TextEditor( SpellChecker spellChecker ) &#123; this.spellChecker = spellChecker; &#125; /* 成员方法 */ public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; （2）SpellChecker （3）Beans.xml 除了autowire属性改成constructor之外，其他完全一样。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- TextEditor --&gt; &lt;bean id="textEditor" class="cn.water.spring_autowire.byName.TextEditor" autowire="constructor"&gt; &lt;/bean&gt; &lt;!-- SpellChecker --&gt; &lt;bean id="SpellChecker" class="cn.water.spring_autowire.byName.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; （4）测试类 （5）结果 12SpellChecker constructorcheckSpelling...]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC 容器]]></title>
    <url>%2F2019%2F08%2F13%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring_Ioc%2F</url>
    <content type="text"><![CDATA[高内聚低耦合在介绍Spring IoC容器之前，我们先要了解一下软件设计好坏的评判标准：耦合和内聚。 耦合 耦合性(Coupling)是对模块间关联程度的度量。 耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差。 高耦合 手机和充电线是高耦合，为什么呢？ 打个比方，苹果手机和安卓手机必须使用本机适配的充电线，而且在安卓手机中甚至还分为USB接口和Type-C接口。如果我使用苹果充电接口给安卓手机充电，那么苹果充电线无法正常输电，安卓手机也无法正常充电了。（忽略其他影响） 由此可见，手机和充电接口之间的依赖关系紧密，独立性差，所以属于高耦合。 低耦合 充电接口和充电接口是低耦合。 打个比方，不论是苹果充电接口还是安卓充电接口，都可以使用苹果充电接头，也都可以使用安卓充电接头。（忽略其他影响） 由此可见，充电接口和充电接头之间的依赖关系松散，独立性高，所以属于低耦合。 内聚 内聚（Cohesion）是一个模块内部各成分间关联程度的度量。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。 低内聚 职责混乱是低内聚。 打个比方，开发人员除了开发项目，还要参与需求分析；测试人员除了测试项目，还要参与开发。这表示每一个内聚模块都没有做好自己分内的事，因为如果每个内聚模块都做好了自己该做的事情，别的模块是不会有插手的余地的。 高内聚 各司其职是高内聚。 打个比方，软件开发人员完成项目开发，测试人员完成项目测试。这表示每一个内聚模块都做好了自己分内的事情，不需要别的内聚模块来插手，也不需要去别的内裤模块插手。 控制反转 IoC 我们在前面已经了解到“高内聚低耦合”是评判软件设计好坏的标准，以及“内聚”和“耦合”的定义。那么我们学习的 Spring 框架是否能帮助我们更好的设计出“高内聚低耦合”的软件呢？答案显然是肯定的。 但是，Spring 框架使得程序“低耦合”的特点更加突出。因为在 Spring 框架中，由于控制反转 IoC（Inversion of Control）的机制，软件之间的依赖关系由 Spring 框架帮我们管理，这样做有效的降低了对象之间的耦合性。 那控制反转又是什么呢？ 控制反转 IoC（Inversion of Control）就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。 换句话说，就是指new实例工作不再由程序员来做，而是交给Spring容器来做。new实例工作的控制权不再由程序员掌控。 依赖注入 我们知道 Spring 框架通过控制反转来帮助我们管理对象，从而降低程序间的耦合。 那么我们又是如何实现控制反转的呢？ 我们使用 Spring 最被认同的技术：控制反转的依赖注入模式。具体来说，我们需要通过依赖注入，来实现控制反转。 那么依赖注入又是什么呢？ 依赖注入 DI （Dependency Injection） 是一种设计模式，它是我们在使用 Spring 容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。 Spring IoC 容器 Spring 容器是 Spring 框架的核心。 Spring IoC 容器：是具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 Spring IoC 容器中的对象被称为 Spring Beans。 依赖注入的目标类，被称为JavaBeans。或者是POJO类（Plain Ordinary Java Object） Spring的工作流程： 通过阅读配置元数据提供的指令 容器对对象进行实例化，配置和组装。 Spring 环境配置pom.xml，注入Spring依赖（只需首次配置） 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Spring 配置元数据 Spring IoC 容器完全由实际编写的配置元数据的格式解耦。 把配置元数据提供给 Spring 容器的方法： 基于 XML 的配置文件 基于注解的配置 基于 Java 的配置 BeanFactory 容器 它是最简单的容器，给 DI 提供了基本的支持。 它用org.springframework.beans.factory.BeanFactory 接口来定义。（beans） XmlBeanFactory 接口实现（1）POJO类 1234567891011121314package cn.water.spring_ioc;public class POJO &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Your Message : " + message); &#125;&#125; （2）配置Beans.xml，将 POJO 类注入 Spring 容器 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- [POJO类] bean标签：表示创建一个Bean容器。 id属性：表示Bean容器的唯一标识符。 class属性：表示POJO类全类名。 --&gt; &lt;bean id="pojoBean" class="cn.water.spring_ioc.POJO" &gt; &lt;!-- [类成员] property标签：表示创建Bean容器的类成员。 name属性：表示类成员的唯一标识符。 value属性：表示类成员的值。 --&gt; &lt;property name="message" value="Hello World!!!!!!!!!!!!!!!!!"/&gt; &lt;/bean&gt;&lt;/beans&gt; （3）测试文件，通过 Spring 容器来实例化 POJO 对象 12345678910111213141516171819202122232425package cn.water.spring_ioc.BeanFactory;import cn.water.spring_ioc.POJO;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class Xml &#123; /** * BeanFactory接口 --&gt; XmlBeanFactory实现类 */ public static void main(String[] args) &#123; /* 1.根据 XMLBean配置文件的位置， 获取 配置的的内容 */ ClassPathResource resource = new ClassPathResource("spring_ioc/Beans.xml"); /* 2.创建 BeanFactory对象 ，初始化 所有Bean对象（Bean配置文件中配置的对象） */ BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); /* 4.根据 配置文件中的BeanId，获取 Bean对象 */ POJO pojo = (POJO) factory.getBean("pojoBean"); /* 5.执行 Bean对象的方法 */ pojo.getMessage(); &#125;&#125; ApplicationContext 容器 Application Context 是 BeanFactory 的子接口，也被称为 Spring 上下文。 Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。 该容器是由 org.springframework.context.ApplicationContext 接口定义。（context） ClassPathXmlApplicationContext 接口实现 ClassPathXmlApplicationContext 该容器从 XML 文件中加载已被定义的 bean。 在这里，你需要提供 CLASSPATH 环境变量。 （1）POJO类（2）Bean.xml（3）测试文件 1234567891011121314151617181920212223package cn.water.spring_ioc.ApplicationContext;import cn.water.spring_ioc.POJO;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ClassPathXml &#123; /** * ApplicationContext接口 --&gt; ClassPathXmlApplicationContext实现类 */ public static void main(String[] args) &#123; /* 1.根据 XML配置文件的位置， 获取 配置的的内容 */ /* 2.创建 ApplicationContext对象 ，初始化 所有Bean对象（Bean配置文件中配置的对象） */ ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_ioc/Beans.xml");// = new FileSystemXmlApplicationContext("C:/Users/water/IDEA-workspace/MySpring/spring_IoC/src/main/resources/spring_ioc/Bean.xml"); /* 3.根据 配置文件中的BeanId，获取 Bean对象 */ POJO pojo = (POJO) applicationContext.getBean("pojoBean"); /* 4.执行 Bean对象的方法 */ pojo.getMessage(); &#125;&#125; FileSystemXmlApplicationContext 接口实现 FileSystemXmlApplicationContext 该容器从 XML 文件中加载已被定义的 bean。 在这里，你需要提供给构造器 XML 文件的完整路径。 C:\\src\\main\\resources\\spring_ioc\\Bean.xml C:/src/main/resources/spring_ioc/Bean.xml （1）POJO类（2）Bean.xml（3）测试文件 123456789101112131415161718192021222324package cn.water.spring_ioc.ApplicationContext;import cn.water.spring_ioc.POJO;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class FileSystemXml &#123; /** * ApplicationContext接口 --&gt; ClassPathXmlApplicationContext实现类 */ public static void main(String[] args) &#123; /* 1.根据 XML配置文件的位置， 获取 配置的的内容 */ /* 2.创建 ApplicationContext对象 ，初始化 所有Bean对象（Bean配置文件中配置的对象） */ ApplicationContext applicationContext = new FileSystemXmlApplicationContext("C:\\Users\\water\\IDEA-workspace\\MySpring\\spring_IoC\\src\\main\\resources\\spring_ioc\\Beans.xml");// = new FileSystemXmlApplicationContext("C:/Users/water/IDEA-workspace/MySpring/spring_IoC/src/main/resources/spring_ioc/Bean.xml"); /* 3.根据 配置文件中的BeanId，获取 Bean对象 */ POJO pojo = (POJO) applicationContext.getBean("pojoBean"); /* 4.执行 Bean对象的方法 */ pojo.getMessage(); &#125;&#125; BeanFactory和ApplicantContext的区别 ApplicationContext 在构建核心容器时，创建对象采用立即加载的方式。一读取完配置文件，立马创建配置的对象。 由于只在读取配置文件时创建对象，所以适用于单例模式。 BeanFactory 在构建核心容器时，创建对象采用延迟的方式。什么时候根据id获取对象了，什么时候创建配置的对象。 由于每次获取对象时，都会创建对象，所以适用于多例模式。 （1）POJO类 12345678package cn.water.spring_ioc;public class POJO02 &#123; public POJO02() &#123; System.out.println("POJO对象创建了..."); &#125;&#125; （2）配置Bean.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- [POJO类] --&gt; &lt;bean id="pojoBean" class="cn.water.spring_ioc.POJO02"&gt;&lt;/bean&gt;&lt;/beans&gt; （3）测试文件 1234567891011public static void main(String[] args) &#123; /* ApplicationContext:立即加载 */ ApplicationContext applicationContext= new ClassPathXmlApplicationContext("spring_ioc/AppCon_BeanFa/Beans.xml"); /* BeanFactory：延迟加载 */ ClassPathResource resource = new ClassPathResource("spring_ioc/AppCon_BeanFa/Beans.xml"); BeanFactory factory = (BeanFactory) new XmlBeanFactory(resource); POJO02 pojo = (POJO02) factory.getBean("pojoBean"); &#125; （4）运行结果 12POJO对象创建了...POJO对象创建了... Spring Bean 容器 bean 对象是构成应用程序的支柱。 bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。 bean 是由用容器提供的配置元数据创建的。 定义构成每个 bean 定义的一组属性：| 属性 | 描述 || :————-: | :——————————–: || class | 强制属性，用来指定创建 bean 的类。 || name / id | 唯一的 bean 标识符。 || scope | 指定 bean 对象的作用域 || constructor-arg | 注入依赖关系（无参构造） || properties | 注入依赖关系 || destroy-method | 初始化方法 || init-method | 销毁方法 | 作用域 当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。 例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。 同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。 作用域 描述 singleton 仅存在一个Bean实例，Bean以单例方式存在（默认值） prototype 每次从容器中调用Bean时，都返回一个新的实例，（即每次调用getBean()时，相当于执行newXxxBean()） request 每次HTTP请求都会创建一个新的Bean（仅适用于WebApplicationContext环境） singleton 同一个HTTP Session共享一个Bean不同Session使用不同的Bean（仅适用于WebApplicationContext环境） global-session 一般用于Portlet应用环境（仅适用于WebApplicationContext环境） （1）POJO类（2）Bean.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- [POJO类]：单例 --&gt; &lt;bean id="pojoBean_singleton" class="cn.water.spring_ioc.POJO" scope="singleton"&gt;&lt;/bean&gt; &lt;!-- [POJO类]：多例 --&gt; &lt;bean id="pojoBean_prototype" class="cn.water.spring_ioc.POJO" scope="prototype"&gt;&lt;/bean&gt;&lt;/beans&gt; （3）测试文件 1234567891011121314151617181920212223242526272829303132333435package cn.water.spring_ioc.Scope;import cn.water.spring_ioc.POJO;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Scope &#123; public static void main(String[] args) &#123; /* 1.创建 容器 */ ApplicationContext context = new ClassPathXmlApplicationContext("spring_ioc/Beans.xml"); /* 2.获取 单例的POJO对象 */ System.out.println("单例：仅存在一个Bean实例"); POJO pojo1 = context.getBean("pojoBean_singleton", POJO.class); POJO pojo2 = context.getBean("pojoBean_singleton", POJO.class); POJO pojo3 = context.getBean("pojoBean_singleton", POJO.class); System.out.println(pojo1); System.out.println(pojo2); System.out.println(pojo3); /* 2.获取 多例的POJO对象 */ System.out.println("多例：每次从容器中调用Bean时，都返回一个新的Bean实例"); POJO pojo4 = context.getBean("pojoBean_prototype", POJO.class); POJO pojo5 = context.getBean("pojoBean_prototype", POJO.class); POJO pojo6 = context.getBean("pojoBean_prototype", POJO.class); System.out.println(pojo4); System.out.println(pojo5); System.out.println(pojo6); &#125;&#125; （4）运行结果 12345678单例：仅存在一个Bean实例cn.water.spring_ioc.POJO@3c0ecd4bcn.water.spring_ioc.POJO@3c0ecd4bcn.water.spring_ioc.POJO@3c0ecd4b多例：每次从容器中调用Bean时，都返回一个新的Bean实例cn.water.spring_ioc.POJO@14bf9759cn.water.spring_ioc.POJO@5f341870cn.water.spring_ioc.POJO@553f17c 生命周期 理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。 为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。 Bean的生命周期可以表达为： Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 （1）配置Bean.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- [POJO类]：生命周期 init-method属性：指定POJO类中的方法 destroy-method属性：指定POJO类中的方法 --&gt; &lt;bean id="pojoBean_lifycycle" class="cn.water.spring_ioc.POJO" init-method="turnON" destroy-method="turnOFF"&gt;&lt;/bean&gt;&lt;/beans&gt; （2）POJO类（添加两个方法turnON()和turnOFF()） 12345678910111213141516171819202122package cn.water.spring_ioc;public class POJO &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("Your Message : " + message); &#125; public void turnON()&#123; System.out.println("初始化~~~"); &#125; public void turnOFF()&#123; System.out.println("销毁！！！"); &#125;&#125; （3）测试文件 12345678910111213/* 1.创建 抽象容器 */AbstractApplicationContext abstractContext = new ClassPathXmlApplicationContext("spring_ioc/Beans.xml");// [init-method] -- turnON方法执行了/* 2.获取 单例的POJO对象 */POJO pojo = abstractContext.getBean("pojoBean_lifycycle", POJO.class);/* 3.注销 抽象容器 */abstractContext.registerShutdownHook();// [destroy-method] -- turnOFF方法执行了 （4）运行结果 12初始化~~~销毁！！！ 实例化默认无参构造（1）配置Bean.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 默认无参构造 --&gt; &lt;!-- 针对于目标类，它会根据默认无参构造函数来创建类对象。 如果bean中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id="pojoBean" class="cn.water.spring_ioc.POJO02"&gt;&lt;/bean&gt;&lt;/beans&gt; （2）POJO类 12345678package cn.water.spring_ioc;public class POJO02 &#123; public POJO02() &#123; System.out.println("POJO对象创建了..."); &#125;&#125; （3）测试文件 123456789101112131415161718package cn.water.spring_ioc.NewInstance;import cn.water.spring_ioc.POJO02;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class constructor &#123; public static void main(String[] args) &#123; /* 默认构造函数 */ System.out.println("----默认构造函数----"); ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_ioc/NewInstance/Beans.xml"); &#125;&#125; （4）运行结果 12----默认构造函数----POJO对象创建了... 工厂类方法（1）配置Bean.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 工厂类方法 --&gt; &lt;!-- 针对于工厂类中提供的目标类，它会根据工厂类中创建目标类的方法来创建类对象。 首先，根据无参构造来创建工厂类对象； 然后，根据工厂类的方法来创建目标类。--&gt; &lt;bean id="InstanceFactory" class="cn.water.spring_ioc.NewInstance.factory.InstanceFactory"&gt;&lt;/bean&gt; &lt;bean id="pojoBean_InstanceFactory" factory-bean="InstanceFactory" factory-method="getPOJO"&gt;&lt;/bean&gt;&lt;/beans&gt; （2）POJO类 12345678package cn.water.spring_ioc;public class POJO02 &#123; public POJO02() &#123; System.out.println("POJO对象创建了..."); &#125;&#125; （3）工厂类 12345678910111213141516package cn.water.spring_ioc.NewInstance.factory;import cn.water.spring_ioc.POJO02;/** * 模拟工厂类 * * 该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数 */public class InstanceFactory &#123; /* 成员方法：返回一个POJO对象 */ public POJO02 getPOJO()&#123; return new POJO02(); &#125;&#125; （4）测试文件 123456789101112131415161718package cn.water.spring_ioc.NewInstance;import cn.water.spring_ioc.POJO02;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class constructor &#123; public static void main(String[] args) &#123; /* 工厂类方法 */ System.out.println("----工厂类方法----"); ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_ioc/NewInstance/Beans.xml"); &#125;&#125; （4）运行结果 12----工厂类方法----POJO对象创建了... 工厂类静态方法（1）配置Bean.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;!-- 工厂类静态方法 --&gt; &lt;!-- 针对于工厂类中提供的目标类，它会根据工厂类中创建目标类的静态方法来创建类对象。 直接根据工厂类对象的静态方法来创建目标类。--&gt; &lt;bean id="ServiceImp_SF" class="cn.water.spring_ioc.NewInstance.factory.StaticFactory" factory-method="getPOJO"&gt;&lt;/bean&gt;&lt;/beans&gt; （2）POJO类 12345678package cn.water.spring_ioc;public class POJO02 &#123; public POJO02() &#123; System.out.println("POJO对象创建了..."); &#125;&#125; （3）工厂类 12345678910111213141516package cn.water.spring_ioc.NewInstance.factory;import cn.water.spring_ioc.POJO02;/** * 模拟工厂类 * * 该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数 */public class StaticFactory &#123; /* 静态方法：返回一个POJO对象 */ public static POJO02 getPOJO()&#123; return new POJO02(); &#125;&#125; （4）测试文件 12345678910111213141516package cn.water.spring_ioc.NewInstance;import cn.water.spring_ioc.POJO02;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class constructor &#123; public static void main(String[] args) &#123; /* 工厂类静态方法 */ System.out.println("----工厂类静态方法----"); ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring_ioc/NewInstance/Beans.xml");&#125; （4）运行结果 12----工厂类静态方法----POJO对象创建了...]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring概述]]></title>
    <url>%2F2019%2F08%2F12%2FSSM%E6%A1%86%E6%9E%B6%2FSpring%2FSpring%2F</url>
    <content type="text"><![CDATA[概述 Spring是分层的企业级full-stack轻量级开源框架，以IoC和AOP为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，并整合了开源世界中众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 依赖注入DI（Dependency Injection） Spring 最被认同的技术是控制反转的依赖注入（DI）模式。 控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。 当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入有助于将这些类粘合在一起，并且在同一时间让它们保持独立。 到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。 依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法。 面向方面的程序设计AOP（Aspect-Oriented Programming） Spring 框架的一个关键组件是面向方面的程序设计（AOP）框架。 一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。 在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。 Spring 框架的 AOP 模块提供了面向方面的程序设计实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦出来。 体系结构 Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。 下面的部分对在 Spring 框架中所有可用的模块给出了详细的介绍。 核心容器 Core模块 提供了框架的基本组成部分，包括 IoC 和依赖注入功能。 Beans 模块 提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。 Context模块 建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。ApplicationContext接口是Context模块的焦点。 SpEL模块（Spring Expression Language） 提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 它们的完整依赖关系如下图所示： 数据访问/集成 JDBC 模块（Java Data Base Connectivity） 提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。 ORM 模块（Object Relational Mapping） 提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。 OXM 模块（Object XML Mapping） 提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 JMS 模块（Java Message Service） 包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细） Web Web 模块 提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块 为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块 为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块 提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。其他 其他 AOP 模块 提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。 Aspects 模块 提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块 在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。 Messaging 模块 为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。 Testing 模块 支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件]]></title>
    <url>%2F2019%2F08%2F08%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2FMyBatis_Configuration%2F</url>
    <content type="text"><![CDATA[URL 统一资源定位符（Uniform Resource Locator） 由协议、主机、端口和URI组成 http://localhost:8080/mybatis/demo file://localhost:8080/mybatis/demo.java 表示一个资源位置的唯一标识。 URI 统一资源标识符（Uniform Resource Locator） 在某个应用中，表示一个资源位置的唯一标识。 properties标签 在之前MyBatis主配置文件的环境搭建中，我们将连接数据库的4个基本信息编写在MyBatis主配置文件中，这种方式属于内部配置。 我们也可以选择外部配置的方式，只要我们通过properties标签来引用外部配置文件信息即可。 内部配置1234567891011121314151617&lt;!-- MyBatis主配置文件 --&gt;&lt;configuration&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 内部配置：连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 外部配置123456# jdbcConfig.properties配置文件jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee42jdbc.username=rootjdbc.password=1234 1234567891011121314&lt;!-- MyBatis主配置文件 --&gt;&lt;configuration&gt;&lt;!-- ................. --&gt; &lt;!-- 外部配置的两种方式:resource或url --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;properties url="file:///C:\Users\water\IDEA-workspace\mybatis_CRUD\src\main\resources\jdbcConfig.properties"&gt;&lt;/properties&gt;&lt;!-- ................. --&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;!-- ................. --&gt;&lt;/configuration&gt; typeAliases标签 在之前MyBatis主配置文件的环境搭建中，我们在持久层接口的映射配置文件中的resultType属性中，每次都需要输入冗长的实体类全类名。 我们可以通过typeAliases标签来取别名，从而避免这个问题。 别名不区分大小写。实体类全类名1234&lt;!-- 持久层接口的映射配置文件:UserDao.xml --&gt;&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 别名123456789&lt;!-- MyBatis主配置文件 --&gt;&lt;configuration&gt;&lt;!-- ................. --&gt;&lt;!-- 起别名 --&gt;&lt;typeAliases&gt; &lt;typeAlias type="cn.water.domain.User" alias="user"&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt;&lt;!-- ................. --&gt;&lt;/configuration&gt; 12345&lt;!-- 持久层接口的映射配置文件:UserDao.xml --&gt;&lt;select id="findAll" resultType="user"&gt; SELECT * FROM user;&lt;/select&gt; package标签 使用TypeAliases标签为每个实体类起别名的确简化了我们的操作，但我们也需要为每一个实体类手动的其别名，仍然有简化的余地。 为了是操作更加简便，我们可以使用Package标签来指定包，来自动加载包下的所有实体类，并以其类名作为别名，不区分大小写。 另外，Mappers标签中有Package属性，用于指定包，来自动加载包下的所有映射文件。相当于代替了所有的Mapper标签。 1234567891011121314&lt;!-- MyBatis主配置文件 --&gt;&lt;configuration&gt;&lt;!-- ................. --&gt;&lt;!-- 指定包--&gt;&lt;typeAliases&gt; &lt;package name="cn.water.domain"/&gt;&lt;/typeAliases&gt;&lt;!-- ................. --&gt;&lt;mappers&gt; &lt;!-- 指定包 --&gt; &lt;package name="cn.water.dao"/&gt;&lt;/mappers&gt;&lt;!-- ................. --&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的CRUD操作（代理持久层实现类）]]></title>
    <url>%2F2019%2F08%2F06%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2FMyBatis_CRUD%2F</url>
    <content type="text"><![CDATA[搭建环境说明 MyBatis环境搭建 的方式在前面已经详细的介绍过了，本文将通过映射配置文件使用代理持久层接口实现类的方式来进行MySQL数据库的CRUD操作。 目录结构 src/main java cn/water/dao UserDao.java（持久层接口） cn/water/domain User.java（持久层） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 核心内容 环境搭建成功后，MySQL数据库的CRUD操作基于以下几个文件的基础上进行修改： UserDao.java（持久层接口） 添加CRUD操作的抽象方法。 UserDao.xml（持久层接口的映射配置文件） 添加持久层接口的全类名：namespace 添加CRUD操作的mapper子标签：select、update、insert、 添加方法名：id 添加返回值类型的全类名：resultType 代码持久层接口：UserDao.java12345678package cn.water.dao;public interface UserDao &#123; // ...... // ...... // ...... // ...... &#125; 映射配置文件：UserDao.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt;&lt;/mapper&gt; 测试类：Test.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.QueryVo;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class MyBatisTest &#123; /** * 私有成员变量 */ private InputStream inputStream; private SqlSession sqlSession; private UserDao userDao; /** * 初始化操作 */ @Before public void init() throws IOException &#123; /* 1.根据主配置文件名，获取其路径的字节输入流 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 2.创建工厂实现类 */ SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder(); /* 3.根据主配置文件的字节输入流，获取工厂类 */ SqlSessionFactory factory = factoryBuilder.build(inputStream); /* 4.根据工厂类，获取产品类 */ sqlSession = factory.openSession(); /* 5.根据持久层接口的字节码文件，获取持久层接口的代理对象 */ userDao = sqlSession.getMapper(UserDao.class); &#125; /** * 反初始化操作 */ @After public void destroy() throws IOException &#123; /* 8.释放资源 */ sqlSession.close(); inputStream.close(); &#125; /** * 测试方法 */ @Test public void test() &#123; // ...... // ...... // ...... // ...... &#125;&#125; 实现CRUD操作查询所有用户123/* 持久层接口：UserDao.java */List&lt;User&gt; findAll() ; 123456&lt;!-- 映射配置文件：UserDao.xml --&gt; &lt;!-- 参数类型为JavaBean，占位符必须和成员变量的getXXX setXXX方法的小写XXX相同 --&gt;&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 12345678/* 测试类：Test.java*//* 6.通过代理对象，调用持久层接口的抽象方法，并获取返回值 */List&lt;User&gt; userList = userDao.findAll();/* 7.遍历 */for (User user : userList) &#123; System.out.println(user);&#125; 添加用户123/* 持久层接口：UserDao.java */void addUser(User user); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;insert id="addUser" parameterType="cn.water.domain.User"&gt; INSERT INTO user VALUES(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;);&lt;/insert&gt; 12345678/* 测试类：Test.java*//* 创建User对象，设置成员变量的值 */User user = new User(1,"mybatis addUser",new Date(),"男","UserDao");/* 6.通过代理对象，调用持久层接口的抽象方法 */userDao.addUser(user);/* 7.提交事务!!! */sqlSession.commit(); 更新用户信息123/* 持久层接口：UserDao.java */void updateUser(User user); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;update id="updateUser" parameterType="cn.water.domain.User"&gt; UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;id&#125;;&lt;/update&gt; 12345678/* 测试类：Test.java*//* 创建User对象，设置成员变量的值 */User user = new User(1,"mybatis updateUser",new Date(),"女","UserDao");/* 6.通过代理对象，调用持久层接口的抽象方法 */userDao.updateUser(user);/* 7.提交事务!!! */sqlSession.commit(); 删除用户123/* 持久层接口：UserDao.java */void deleteUser(Integer userid); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; DELETE FROM user WHERE id = #&#123;userId&#125;;&lt;/delete&gt; 123456/* 测试类：Test.java*//* 6.通过代理对象，调用持久层接口的抽象方法 */userDao.deleteUser(1);/* 7.提交事务!!! */sqlSession.commit(); 查找单个用户123/* 持久层接口：UserDao.java */List&lt;User&gt; findOne(Integer userid); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findOne" parameterType="java.lang.Integer" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE id=#&#123;id&#125;;&lt;/select&gt; 123456/* 测试类：Test.java*//* 6.通过代理对象，调用持久层接口的抽象方法 */List&lt;User&gt; userList = userDao.findOne(48);/* 7.输出结果 */System.out.println(userList.get(0)); 根据姓名模糊查询12345/* 持久层接口：UserDao.java */List&lt;User&gt; findByName01(String username);List&lt;User&gt; findByName02(String username); 123456789&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findByName01" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;username&#125;;&lt;/select&gt;&lt;select id="findByName02" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' ;&lt;/select&gt; 1234567891011121314/* 测试类：Test.java*//* 6.通过代理对象，调用持久层接口的抽象方法 */// LIKE #&#123;username&#125; 使用的是PreparedStatement对象List&lt;User&gt; userList1 = userDao.findByName01("%王%");// LIKE '%$&#123;value&#125;%' 使用的是Statement对象List&lt;User&gt; userList2 = userDao.findByName02("王");/* 7.输出结果 */for (User user : userList1) &#123; System.out.println("1--"+user);&#125;for (User user : userList2) &#123; System.out.println("2--"+user);&#125; 查询所有用户数量123/* 持久层接口：UserDao.java */Integer findTotalUser(); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findTotalUser" resultType="java.lang.Integer"&gt; SELECT COUNT(*) FROM user;&lt;/select&gt; 123456/* 测试类：Test.java*//* 6.通过代理对象，调用持久层接口的抽象方法 */Integer totalUser = userDao.findTotalUser();/* 7.输出结果 */System.out.println(totalUser); 添加用户，并且返回ID123/* 持久层接口：UserDao.java */void addAndReturn(User user); 12345678&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;insert id="addAndReturn" parameterType="cn.water.domain.User"&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="java.lang.Integer" order="AFTER"&gt; SELECT last_insert_id(); &lt;/selectKey&gt; INSERT INTO user VALUES(NULL,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;);&lt;/insert&gt; 12345678910/* 测试类：Test.java*//* 创建User对象，设置成员变量的值 */User user = new User(0,"mybatis addUser",new Date(),"男","UserDao");// 保存之前：0System.out.println(user);/* 6.通过代理对象，调用持久层接口的抽象方法 */userDao.addAndReturn(user);// 保存之后：为实际值System.out.println(user); OGNL表达式 Object Graphic Navigation Language：对象图导航语言 获取数据的一种表达式，在形式上省略了get Java表达式：user.getUsername(); OGNL表达式：user.username MyBatis表达式：username 其实在MyBatis的映射配置文件中，我们使用的也是OGNL表达式。只是由于我们再parameterType属性中已经提供了实体类，所以我们可以省略实体类名直接使用属性名来获取数据。 POJO对象 POJO对象等同于JavaBean对象，属于实体类的一种。 我们通过User对象来传递查询条件时，查询条件的范围有限，只能是User对象中有的数据。但在实际操作中，除了需要User对象的查询条件，还会需要其他对象的查询条件，此时使用User对象来传递查询条件显然是不够的。 通过POJO对象来传递查询条件的优势正在于此，将User对象以及所需的其他对象作为成员变量封装进POJO对象，在查询时，就可以使用多个对象的查询条件。 根据Query对象的条件，模糊查询 将User对象封装进QueryVo对象中，并通过QueryVo对象来获取User对象中Username的值，用于进行模糊查询。 123456789101112131415/* POJO对象：QueryVo.java */package cn.water.domain;public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 123/* 持久层接口：UserDao.java */ List&lt;User&gt; findByVo(QueryVo vo); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findByVo" parameterType="cn.water.domain.QueryVo" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;user.username&#125;;&lt;/select&gt; 1234567891011121314/* 测试类：Test.java*//* 创建User对象，设置成员变量的值 */User user =new User();user.setUsername("%王%");/* 创建QueryVo对象，设置成员变量的值 */QueryVo vo = new QueryVo();vo.setUser(user);/* 6.通过代理对象，调用持久层接口的抽象方法 */List&lt;User&gt; userList = userDao.findByVo(vo);/* 7.输出结果 */for (User u : userList) &#123; System.out.println(u);&#125; 实体类变量和数据库列名的匹配方式将实体类变量名设置为数据库列名123456789101112131415161718public class User implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;&#125; 123/* 持久层接口：UserDao.java */List&lt;User&gt; findAll() ; 12345&lt;!-- 映射配置文件：UserDao.xml --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 为数据库列名设置别名123456789101112131415161718public class User implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer userId; private String userName; private Date UserBirthday; private String UserSex; private String UserAddress; // 省略其他set方法 public Integer getUserId() &#123; return userId; &#125;// 省略其他get方法 public void setUserId(Integer userId) &#123; this.userId = userId; &#125;&#125; 12345&lt;!-- 映射配置文件：UserDao.xml --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT id AS userId,username AS UserName,address AS userAddress,sex AS userSex,birthday AS userBrithday FROM user;&lt;/select&gt; 配置对应关系123456789101112131415161718public class User implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer userId; private String userName; private Date UserBirthday; private String UserSex; private String UserAddress; // 省略其他set方法 public Integer getUserId() &#123; return userId; &#125;// 省略其他get方法 public void setUserId(Integer userId) &#123; this.userId = userId; &#125;&#125; 123456789101112131415&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;resultMap id="userMap" type="cn.water.domain.User"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property="userId" column="id" &gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property="userName" column="username" &gt;&lt;/result&gt; &lt;result property="UserBirthday" column="birthday" &gt;&lt;/result&gt; &lt;result property="UserSex" column="sex" &gt;&lt;/result&gt; &lt;result property="UserAddress" column="address" &gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id="findAll" resultMap="userMap"&gt; SELECT id * FROM user;&lt;/select&gt; 执行过程]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的CRUD操作（代理持久层实现类）]]></title>
    <url>%2F2019%2F08%2F06%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2FMyBatis_CRUD_Dao%2F</url>
    <content type="text"><![CDATA[搭建环境说明 MyBatis环境搭建 的方式在前面已经详细的介绍过了，本文仍然通过映射配置文件，但不再使用代理持久层接口实现类的方式，而是使用创建持久层接口实现类的方式来进行MySQL数据库的CRUD操作。 创建持久层接口实现类的方式在实际开发中并不常用，所以我会将本文的主题放在与前一种方法的比较上。 改变的内容主要是测试类和持久层接口实现类。 目录结构 src/main java cn/water/dao impl UserDaoImpl.java（持久层接口的实现类） UserDao.java（持久层接口） cn/water/domain User.java（持久层） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 代码持久层接口：UserDao.java12345678package cn.water.dao;public interface UserDao &#123; // ...... // ...... // ...... // ...... &#125; 持久层接口实现类：UserDaoImp.java123456789101112131415161718192021222324252627282930313233343536public class UserDaoImpl implements UserDao &#123; /** * 私有成员变量 */ private SqlSessionFactory factory; private SqlSession sqlSession; /** * 带参构造，初始化操作 * @param factory */ public UserDaoImpl(SqlSessionFactory factory)&#123; /* 5.初始化工厂类 */ this.factory = factory; /* 6.通过工厂类，获取产品类，并初始化产品类 */ sqlSession = factory.openSession(); &#125; /** * 反初始化操作 */ @After public void destroy() &#123; /* 9.释放资源 */ sqlSession.close(); &#125; public void method() &#123; // ...... // ...... // ...... // ...... &#125; &#125; 映射配置文件：UserDao.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt; &lt;!-- ..... --&gt;&lt;/mapper&gt; 测试类：Test.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.QueryVo;import cn.water.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class MyBatisTest &#123; /** * 私有成员变量 */ private InputStream inputStream; private SqlSessionFactory factory; private UserImpDao userDao; /** * 初始化操作 */ @Before public void init() throws IOException &#123; /* 1.根据主配置文件名，获取其路径的字节输入流 */ inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 2.创建工厂实现类 */ SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder(); /* 3.根据主配置文件的字节输入流，获取工厂类 */ factory = factoryBuilder.build(inputStream); /* 4.根据工厂类，通过持久层接口实现类，创建持久层接口 */ userDao = new UserImpDaoImpl(factory); &#125; /** * 反初始化操作 */ @After public void destroy() throws IOException &#123; /* 12.释放资源 */ inputStream.close(); &#125; /** * 测试方法 */ @Test public void test() &#123; // ...... // ...... // ...... // ...... &#125;&#125; 实现CRUD操作查询所有用户123/* 持久层接口：UserDao.java */List&lt;User&gt; findAll() ; 123456&lt;!-- 映射配置文件：UserDao.xml --&gt; &lt;!-- 参数类型为JavaBean，占位符必须和成员变量的getXXX setXXX方法的小写XXX相同 --&gt;&lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 1234567/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用selectList查询方法 *//* 参数：持久层接口的映射配置文件的namespace属性值+持久层接口的方法名 */List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll");/* 8.返回查询结果 */return list; 12345678910/* 测试类：Test.java*//* 10.通过持久层接口，调用方法 */List&lt;UserImp&gt; userList = userDao.findAll();/* 11.遍历结果 */for (UserImp user : userList) &#123; System.out.println(user);&#125;&#125; 添加用户123/* 持久层接口：UserDao.java */void addUser(User user); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;insert id="addUser" parameterType="cn.water.domain.User"&gt; INSERT INTO user VALUES(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;);&lt;/insert&gt; 123456/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用insert插入方法 */sqlSession.insert("cn.water.dao.UserImpDao.addUser",user);/* 8.提交事务 */sqlSession.commit(); 123456/* 测试类：Test.java*//* 10.创建User对象，设置成员变量的值 */UserImp user = new UserImp(1,"mybatis addUser",new Date(),"男","UserDao");/* 11.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */userDao.addUser(user); 更新用户信息123/* 持久层接口：UserDao.java */void updateUser(User user); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;update id="updateUser" parameterType="cn.water.domain.User"&gt; UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;id&#125;;&lt;/update&gt; 123456/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用update更新方法 */sqlSession.update("cn.water.dao.UserImpDao.updateUser",user);/* 8.提交事务 */sqlSession.commit(); 123456/* 测试类：Test.java*//* 10.创建User对象，设置成员变量的值 */UserImp user = new UserImp(1,"mybatis updateUser",new Date(),"女","UserDao");/* 11.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */userDao.updateUser(user); 删除用户123/* 持久层接口：UserDao.java */void deleteUser(Integer userid); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; DELETE FROM user WHERE id = #&#123;userId&#125;;&lt;/delete&gt; 123456/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用delete删除方法 */sqlSession.delete("cn.water.dao.UserImpDao.deleteUser",userid);/* 8.提交事务 */sqlSession.commit(); 1234/* 测试类：Test.java*//* 10.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */userDao.deleteUser(1); 查找单个用户123/* 持久层接口：UserDao.java */List&lt;User&gt; findOne(Integer userid); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findOne" parameterType="java.lang.Integer" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE id=#&#123;id&#125;;&lt;/select&gt; 123456/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用selectList查询方法 */UserImp user = sqlSession.selectOne("cn.water.dao.UserImpDao.findOne", userid);/* 8.返回查询结果 */return user; 123456/* 测试类：Test.java*//* 10.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */UserImp user = userDao.findOne(48);/* 11.输出结果 */System.out.println(user); 根据姓名模糊查询12345/* 持久层接口：UserDao.java */List&lt;User&gt; findByName01(String username);List&lt;User&gt; findByName02(String username); 123456789&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findByName01" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;username&#125;;&lt;/select&gt;&lt;select id="findByName02" parameterType="java.lang.String" resultType="cn.water.domain.User"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' ;&lt;/select&gt; 1234567891011/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用selectList查询方法 */List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findByName01", username);/* 8.返回查询结果 */return list;/* 7.使用产品类对象 调用selectList查询方法 */List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findByName02", username);/* 8.返回查询结果 */return list; 123456789101112/* 测试类：Test.java*//* 10.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */List&lt;UserImp&gt; userList1 = userDao.findByName01("%王%");List&lt;UserImp&gt; userList2 = userDao.findByName02("王");/* 11.输出结果 */for (UserImp user : userList1) &#123; System.out.println("1--"+user);&#125;for (UserImp user : userList2) &#123; System.out.println("2--"+user);&#125; 查询所有用户数量123/* 持久层接口：UserDao.java */Integer findTotalUser(); 12345&lt;!-- 映射配置文件：UserDao.xml --&gt;&lt;select id="findTotalUser" resultType="java.lang.Integer"&gt; SELECT COUNT(*) FROM user;&lt;/select&gt; 123456/* 持久层接口实现类：UserDaoImp.java *//* 7.使用产品类对象 调用selectList查询方法 */Integer count = sqlSession.selectOne("cn.water.dao.UserImpDao.findTotalUser");/* 8.返回查询结果 */return count; 123456/* 测试类：Test.java*//* 10.根据User对象，通过持久层接口，调用持久层接口的抽象方法 */Integer totalUser = userDao.findTotalUser();/* 11.输出结果 */System.out.println(totalUser); 执行过程]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义MyBatis]]></title>
    <url>%2F2019%2F08%2F04%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2FMyBatis_Custom%2F</url>
    <content type="text"><![CDATA[简介 我们知道创建Maven项目后，在项目中的pom.xml配置文件中引入MyBatis依赖之后，我们就可以使用MyBatis相关的类和接口，和相应的功能。 但为了对MyBatis的体系结构和功能有更加深刻的理解和全面的认识，本文Maven项目中的pom.xml配置文件，将不再引入MyBatis依赖，转而通过自定义编写MyBatis相关的类和接口来实现同样的功能。 思维导图 代码Maven项目配置文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;mybatis_custom&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- 此处没有MyBatis的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MyBatis主配置文件123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件。 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt;&lt;/configuration&gt; 持久层接口的映射配置文件1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; User实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.water.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; UserDao持久层接口123456789101112131415161718package cn.water.dao;import cn.water.domain.User;import java.util.List;/** * 用户的持久层接口 */public interface UserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findAll();&#125; Mapper实体类12345678910111213141516171819202122232425262728293031323334package cn.water.mybatis.cfg;/** * 封装SQL语句和结果集类型的全类名 */public class Mapper &#123; private String queryString; private String resultType; @Override public String toString() &#123; return "Mapper&#123;" + "queryString='" + queryString + '\'' + ", resultType='" + resultType + '\'' + '&#125;'; &#125; public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; Configuration实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.water.mybatis.cfg;import java.util.HashMap;import java.util.Map;/** * 封装数据库驱动和数据库连接对象的三个参数 */public class Configuration &#123; private String driver; private String url; private String username; private String password; private Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); @Override public String toString() &#123; return "Configuration&#123;" + "driver='" + driver + '\'' + ", url='" + url + '\'' + ", username='" + username + '\'' + ", password='" + password + '\'' + ", mappers=" + mappers + '&#125;'; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123;// this.mappers = mappers; 覆盖：Map集合中永远只会有一个键值对 this.mappers.putAll(mappers); // 追加 &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; MyBatisTest测试类12 Resources类12 SqlSessionFactoryBuilder工厂实现类123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.User;import cn.water.mybatis.io.Resources;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;import cn.water.mybatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserDao dao = sqlSession.getMapper(UserDao.class); /* 使用代理对象 执行方法 */ List&lt;User&gt; list = dao.findAll(); /* 遍历 */ for (User user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; XMLConfigBuilder工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package cn.water.mybatis.Utils;//import com.itheima.mybatis.annotations.Select;import cn.water.Anno.Select;import cn.water.mybatis.io.Resources;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.cfg.Mapper;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author 黑马程序员 * @Company http://www.ithiema.com * 用于解析配置文件 */public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术： * dom4j+xpath */ public static Configuration loadConfiguration(InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是XML"); //表示有resource属性，用的是XML //取出属性的值 String mapperPath = attribute.getValue();//获取属性的值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据daoClassPath获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 String namespace = root.attributeValue("namespace");//是组成map中key的部分 //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历select节点集合 for(Element selectElement : selectElements)&#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue("id"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace+"."+id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给map赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; SqlSessionFactory工厂接口12345678package cn.water.mybatis.session;/*** * 工厂接口 */public interface SqlSessionFactory &#123; SqlSession openSession();&#125; DefaultSqlSessionFactory工厂接口实现类12345678910111213141516171819202122232425262728293031323334package cn.water.mybatis.defaults;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;/** * SqlSessionFactory工厂接口的实现类 */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; /** * 私有成员变量 */ private Configuration configuration; /** * 带参构造 * @param configuration */ public DefaultSqlSessionFactory(Configuration configuration) &#123; this.configuration = configuration; &#125; /** * 创建操作数据库对象 * @return */ public SqlSession openSession() &#123; return new DefaultSqlSession(configuration); &#125; &#125; SqlSession产品接口123456789101112131415161718192021package cn.water.mybatis.session;/** * 产品接口 */public interface SqlSession &#123; /** * 根据参数，创建代理对象 * @param daoInterface * @param &lt;T&gt; * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface); /* &lt;T&gt; T 返回值为泛型时，需要先声明再使用。 */ /** * 释放资源 */ void close();&#125; DefaultSqlSession产品接口实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.water.mybatis.defaults;import cn.water.mybatis.Utils.DataSourceUtil;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.proxy.MapperProxy;import cn.water.mybatis.session.SqlSession;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.SQLException;/** * SqlSession产品接口的实现类 */public class DefaultSqlSession implements SqlSession &#123; /** * 私有成员变量 */ private Configuration configuration; private Connection connection; /** * 带参构造 * @param configuration */ public DefaultSqlSession(Configuration configuration) &#123; this.configuration = configuration; connection = DataSourceUtil.getConnection(configuration); &#125; /** * 创建代理对象 * @param daoInterface * @param &lt;T&gt; * @return */ public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface) &#123; return (T) Proxy.newProxyInstance( daoInterface.getClassLoader(), // 持久层接口的类加载器 new Class[]&#123;daoInterface&#125;, // 持久层接口 new MapperProxy(configuration.getMappers(), connection)); &#125; /** * 释放资源 */ public void close() &#123; if (connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; DataSourceUtils工具类12345678910111213141516171819202122232425262728package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Configuration;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/*** * 创建数据库连接池对象 */public class DataSourceUtil &#123; /*** * 创建数据库连接对象 * @param configuration * @return */ public static Connection getConnection(Configuration configuration) &#123; try &#123; Class.forName(configuration.getDriver()); return DriverManager.getConnection(configuration.getUrl(),configuration.getUsername(),configuration.getUsername()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; MapperProxy代理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.mybatis.proxy;import cn.water.mybatis.Utils.Executor;import cn.water.mybatis.cfg.Mapper;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Map;public class MapperProxy implements InvocationHandler &#123; /** * 私有成员变量 * key：全类名+方法名 * value：SQL语句+结果集数据类型的全类名 */ private Map&lt;String, Mapper&gt; mappers; private Connection connection; /** * 带参构造 * @param mappers */ public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection connection) &#123; this.mappers = mappers; this.connection = connection; &#125; /** * 代码增强 * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1.获取方法名 String methodName = method.getName(); // 2.获取方法所在类的名称 String className = method.getDeclaringClass().getName(); // 3.组合key String key = className + "." + methodName; // 4.获取mappers中的Mapper对象 Mapper mapper = mappers.get(key); // 5.判断是否有Mapper if (mapper==null)&#123; throw new IllegalArgumentException("传入的参数有误！"); &#125; // 6.调用工具类执行查询所有 return new Executor().selectList(mapper,connection); &#125;&#125; Executor工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Mapper;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;/** * @author 黑马程序员 * @Company http://www.ithiema.com * 负责执行SQL语句，并且封装结果集 */public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125; &#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注解 使用注解的方式我们编写的MyBatis相关的类和接口不用改变，除了修改MyBatis主配置文件和删除映射配置文件之外，只需按照注解的方式来编写User实体类和UserDao持久层接口即可，另外我们要自定义编写Select注解。 代码MyBatis主配置文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件。 --&gt; &lt;!-- 注解：使用class属性指定被注解的持久层接口的全类名 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;mapper class="cn.water.dao.UserAnnoDao"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; User实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.water.domain;import java.io.Serializable;import java.util.Date;public class UserAnno implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; UserDao持久层接口1234567891011121314151617181920package cn.water.dao;import cn.water.Anno.Select;import cn.water.domain.UserAnno;import java.util.List;/** * 用户的持久层接口 */public interface UserAnnoDao &#123; /** * 查询所有 * @return */ @Select("SELECT * FROM user;") List&lt;UserAnno&gt; findAll();&#125; Select注解123456789101112131415161718192021package cn.water.Anno;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 查询的注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; /*** * 配置SQL语句 * @return */ String value();&#125; MyBatisAnnoTest测试类123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.test;import cn.water.dao.UserAnnoDao;import cn.water.domain.UserAnno;import cn.water.mybatis.io.Resources;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;import cn.water.mybatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisAnnoTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserAnnoDao dao = sqlSession.getMapper(UserAnnoDao.class); /* 使用代理对象 执行方法 */ List&lt;UserAnno&gt; list = dao.findAll(); /* 遍历 */ for (UserAnno userAnno : list) &#123; System.out.println(userAnno); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JdbcTemplate]]></title>
    <url>%2F2019%2F08%2F02%2FJava%20SE%2FJdbcTemplate%2F</url>
    <content type="text"><![CDATA[Spring JDBC Spring框架对JDBC的简单封装，它提供了一个JDBCTemplate对象，简化JDBC的开发。 快速入门 导入jar包 创建JdbcTemplate对象，传递DataSource对象 JdbcTemplate template = new JdbcTemplate(dataSource); 调用JdbcTemplate的方法，完成CRUD的操作 update() queryForMap() queryForList() query() queryForObject() 方法update update()：执行DML增、删、改语句。 1234567/* 添加数据 */// SQL语句String sql = "UPDATE account SET balance = ? ";// 调用update方法int update = jdbcTemplate.update(sql, 1000);// 输出结果System.out.println("update添加:"+update); 1234567/* 修改数据 */// SQL语句 String sql = "INSERT INTO account VALUES (?,?,?),(?,?,?) ";// 调用update方法int update = jdbcTemplate.update(sql,null,"Rat",1000,null,"Ant",1000);// 输出结果ystem.out.println("update修改:"+update); 1234567/* 删除数据 */// SQL语句String sql = "DELETE FROM account WHERE name IN (?,?) ";// 调用update方法nt update = jdbcTemplate.update(sql,"Rat","Ant");// 输出结果System.out.println("update删除:"+update); queryForMap queryForMap()：查询结果，将结果集封装为Map集合。（结果集长度只能是1） 将列名作为key，将字段作为value，将一条记录封装为一个map集合。 一个Map对应着一条记录。1234567 /* 查询一条记录，封装至Map集合 */// SQL语句String sql = "SELECT * FROM account WHERE id = ?";// 调用queryForMap方法Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 1 );// 输出结果System.out.println(map); queryForList queryForList()：查询结果，将结果集封装为List集合。 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。 一个List对应着一张表。123456789/* 查询所有记录，封装至List集合 */// SQL语句String sql = "SELECT * FROM account";// 调用queryForMap方法List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql);// 输出结果for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap);&#125; query query()：查询结果，将结果集封装为JavaBean对象。 将列名作为成员变量，将字段作为成员变量的值，将一条记录封装为一个JavaBean对象。 一个JavaBean对象对应着一条记录。 query的参数：RowMapper接口 使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装。 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 传递RowMapper匿名内部类123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*基本数据类型*/ private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 123456789101112131415161718192021222324/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递RowMapper匿名内部类，手动的一条一条的获取ResultSet结果集中的数据，然后封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Record&gt;() &#123; @Override public Record mapRow(ResultSet reSet, int i) throws SQLException &#123; int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); Record record = new Record(id, ename, job_id, mgr, join_date, salary, bonus, dept_id); return record; &#125;&#125;// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; 传递BeanPropertyRowMapper实现类 注意，JavaBean对象中的成员变量类型一定要使用引用数据类型。 因为基本数据类型不能接受NULL值，而数据库中的字段可以设置为NULL值，所以在传递时，会发生类型转换的问题。 123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*引用数据类型*/ private Integer id; private String ename; private Integer job_id; private Integer mgr; private Date join_date; private Double salary; private Double bonus; private Integer dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 12345678910/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递BeanPropertyRowMapper实现类，自动获取ResultSet结果集中的数据，自动封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;&gt;(Record.class));// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; queryForObject queryForObject：查询结果，将结果集封装为对象。 用于聚合函数（查询表的记录数、列的最大数最小数平均数）123456/* 查询总记录数 */String sql = "SELECT COUNT(id) FROM emp";// 调用queryForObject方法Integer integer = jdbcTemplate.queryForObject(sql, Integer.class);// 输出结果System.out.println(integer);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>Spring JDBC</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接池]]></title>
    <url>%2F2019%2F08%2F02%2FJava%20SE%2FJDBCDateSource%2F</url>
    <content type="text"><![CDATA[数据库连接池 概念 数据库连接池：其实就是一个容器，存放数据库连接的容器。 当系统初始化后，容器被创建，并且容器会申请一些连接对象。 当用户来访问数据库时，从容器中获取连接对象；用户访问完之后，会将连接对象归还给容器。 优点 节约资源 用户访问高效 接口 数据库连接池接口由Sun公司编写，具体实现类由各个数据库厂商提供。 数据库连接池接口： javax.sql.DataSource 接口方法 获取连接：getConnection() 归还连接：Connection.close()。 Connection对象是从DataSource对象中获取，此时就不再是关闭连接了，而是归还连接。 接口的实现类 C3P0：数据库连接池实现技术 Druid：数据库连接池实现技术（阿里巴巴） C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 不要忘记导入数据库驱动jar包 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 123456789101112131415161718192021222324252627282930313233&lt;!-- c3p0-config.xml文件 --&gt;&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/jdbc&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!-- initialPoolSize：初始化申请的Connection对象数量 --&gt; &lt;!-- maxPoolSize：最大的的Connection对象数量 --&gt; &lt;!-- checkoutTimeout：超时时间 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 使用自定义的配置读取连接池对象 --&gt; &lt;named-config name="otherc3p0"&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/servlet&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345678910111213141516171819202122// 打印获取的数据库连接对象 public static void main(String[] args) throws SQLException &#123;//1.导入jar包//2.定义配置文件//3.使用默认配置，获取数据库连接池对象DataSource dataSource = new ComboPooledDataSource();//3.使用自定义配置，获取数据库连接池对象// DataSource dataSource = new ComboPooledDataSource("otherc3p0");// 最大获取连接对象为10个，但我们需要获取15个。// 那就一边获取数据库连接对象，一边归还数据库连接对象。for (int i = 0; i &lt; 15; i++) &#123; //4.获取 数据库连接对象 Connection connection = dataSource.getConnection(); System.out.print(i+" "); //5.打印 数据库连接对象 System.out.println(connection); if (i &gt;= 5 &amp;&amp; i&gt;= 9 ) &#123; connection.close(); &#125;&#125;&#125; Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象12345678# druid.properties文件driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/jdbcusername=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 123456789101112131415public static void main(String[] args) throws Exception &#123;//1.导入jar包//2.定义配置文件//3.加载配置文件Properties properties = new Properties();InputStream is = C_Druid.class.getClassLoader().getResourceAsStream("druid.properties");properties.load(is);//3.获取 数据库连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource( properties );//4.获取 数据库连接对象Connection connection = dataSource.getConnection();//5.打印System.out.println(connection);&#125; 对比 C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象 JDBC工具类 我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接池对象的静态方法 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class JDBCUtils &#123;// [静态变量:数据库连接池] private static DataSource dataSource;// [静态代码块：获取数据库连接池对象]// 使用数据库连接池对象后，我们就不需要挨个获取配置文件中的数据了，因为数据库连接池对象已经帮我们获取了，所以我们只需要获取数据库连接池对象就行了。 static &#123; try &#123; //1.创建properties对象 Properties properties = new Properties(); //2.加载配置文件 properties.load( JDBCUtils.class.getClassLoader(). getResourceAsStream("druid.properties")); //3.获取 数据库连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;//[成员方法：获取Connection对象] public static Connection getConneciton() throws SQLException &#123; return dataSource.getConnection(); &#125;//[成员方法：获取DataSource对象] public static DataSource getDataSource()&#123; return dataSource; &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat,Connection conn)&#123; close(null,stat,conn); &#125; //[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(ResultSet reSet,Statement stat, Connection conn)&#123; if (reSet!=null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat!=null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>C3P0</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F08%2F01%2FJava%20SE%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC简介 概念 Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。 JDBC本质 JDBC其实是sun公司定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去编写这套接口的实现类，包装成数据库驱动jar包。通过导入不同数据库厂商编写的数据库驱动jar包，来对JBDC接口进行实现。 快速入门 导入MySQL数据库驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制到项目的libs目录下 右键 –&gt; Add As Library 注册驱动 driver “com.mysql.jdbc.Driver” 获取数据库连接对象 Connection 第一个参数：URL（jdbc:mysql://连接IP地址:端口号/数据库名） 第二个参数：数据库账号 第三个参数：数据库密码 定义SQL语句 获取执行SQL语句的对象 Statement 执行SQL语句，接受返回结果 处理结果 释放资源 123456789101112# 创建数据库CREATE DATABASE jdbc;# 使用数据库USE jdbc;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT , NAME VARCHAR(20), balance INT);# 插入数据INSERT INTO account VALUES(1,&apos;Cat&apos;,1000),(2,&apos;Dog&apos;,1000); 12345678910111213141516//1.导入驱动jar包//2.注册驱动Class.forName("com.mysql.jdbc.Driver");//3.获取数据库连接对象ConnectionConnection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc", "root", "root");//4.定义SQL语句String s = "UPDATE account SET balance = 1500 WHERE id =1";//5.获取执行SQL的对象StatementStatement statement = connection.createStatement();//6.执行SQLint count = statement.executeUpdate(s);//7.处理结果System.out.println(count);//8.释放资源statement.close();connection.close(); 详解对象DriverManager DriverManager驱动管理对象：用于管理一组JDBC驱动程序的基本服务。 新增的DataSource接口提供了另一种连接到数据源的方法。 使用DataSource对象是连接到数据源的首选方法。 注册驱动 注册驱动：其实就是一个指定数据库驱动jar包的过程。 我们在快速入门的时候，使用的注册驱动方式是加载文件： 加载MySQL数据库驱动jar包中的com.mysql.jdbc.Driver类 Class.forName(“com.mysql.jdbc.Driver”); 那么为什么加载com.mysql.jdbc.Driver类就能够注册驱动呢？我们来探究一下。 其实真正注册驱动调用的是DriverManager类中的registerDriver静态方法 注册与给定的驱动程序 DriverManager ：static void registerDriver(Driver driver) 而由于com.mysql.jdbc.Driver类在其静态代码块调用了registerDriver静态方法，所以当我们去加载这个类时，它会帮我们自动的注册驱动，简便了我们的操作。 MySQL5之后的驱动jar包可以省略注册驱动的步骤，因为它自动加载了com.mysql.jdbc.Driver类。12345678/* com.mysql.jdbc.Driver类中的静态代码块 */static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; 获取数据库连接 static Connection getConnection(String url, String user, String password) url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/db3 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection Connection数据库连接对象：与特定数据库的连接。 获取执行SQL语句的对象 Statement createStatement() ：创建一个 Statement对象，用于将SQL语句发送到数据库。 PreparedStatement prepareStatement(String sql) ：创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 管理事务 void setAutoCommit(boolean autoCommit) ：（开启事务）将此连接的自动提交模式设置为给定状态。 true（自动提交） false（手动提交，开启事务） void commit() ：（提交事务）使自上次提交/回滚以来所做的所有更改都将永久性，并释放此 Connection对象当前持有的任何数据库锁。 void rollback() ：（回滚事务）撤消在当前事务中所做的所有更改，并释放此 Connection对象当前持有的任何数据库锁。 Statement Statement执行静态SQL语句的对象：用于执行静态SQL语句并返回其生成的结果的对象。 执行sql boolean execute(String sql) ：可以执行任意的SQL语句 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数 通过影响的行数可以判断语句是否执行成功。返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 练习：增删改添加记录注意：添加记录调用的是executeUpdate方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123;Connection conn = null;Statement stat = null;try &#123; //1.注册驱动 抓取异常 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "INSERT INTO account VALUES (NULL,'Rat',2000);"; //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 Statement stat = conn.createStatement(); //5.执行SQL语句 int i = stat.executeUpdate(s); //6.处理结果 if (i&gt;0) &#123; System.out.println("操作成功"); &#125;else &#123; System.out.println("操作失败"); &#125;&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; finally &#123;//7.释放资源/* 因为Statement和Connection已经在trycatch语句外声明了一个NULL值由于trycatch语句的特性，可能会造成在执行新的赋值语句之前就被中断了运行，所以Statement和Connection可能会是空值。于是这里需要采用if语句来避免空指针异常 */ if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 修改记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：修改记录执行SQL语句的是executeUpdate方法 123// .....String s = "UPDATE account SET balance =1000 WHERE name = 'rat'";// ..... 删除记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：删除记录执行SQL语句的是executeUpdate方法 123// .....String s = "DELETE FROM account WHERE name = 'rat'";// ..... ResultSet ResultSet结果集对象：表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。 封装查询结果 boolean next():：游标向下移动一行，并判断当前行是否是最后一行的末尾(是否有数据)。 如果是最后一行的末尾，则返回false；如果不是，则返回true。 getTYPE(参数)：获取数据 TYPE：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号，从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 练习：查询查询记录除了SQL语句、执行SQL语句和处理结果不一样，所有的代码都跟添加记录的练习一模一样。另外，你要在trycatch语句外声明一个ResultSet对象为NULL，并在finally语句中释放ResultSet资源。注意：查询记录执行SQL语句的是executeQuery方法 123456789101112131415161718192021// .....//2.定义SQL语句String s = "SELECT * FROM account";//3.获取数据库连接对象conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root");//4.获取执行SQL的对象 statementstat = conn.createStatement();//5.执行SQL，获取结果集reSet = stat.executeQuery(s);//6.处理结果// 1.让游标向下移动一行// 2.并判断是否是最后一行 while (reSet.next()) &#123;// 3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble("balance");// 4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125;// .... 查询记录（实体类）代码 查询数据库中emp表的数据，并将其封装为Employee对象，然后将其封装进List集合。 123456789101112131415161718192021222324252627282930# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号);-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),(1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10); 1234567891011121314151617181920212223242526272829303132333435363738394041// 实体类public class Employee &#123; // 成员变量（根据数据库的列来设置） private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; // 无参构造 public Employee() &#123; &#125; // 带参构造（按照数据库表中列的顺序） public Employee(int id, String ename, int job_id, int mgr, Date join_date, double salary, double bonus, int dept_id) &#123; this.id = id; this.ename = ename; this.job_id = job_id; this.mgr = mgr; this.join_date = join_date; this.salary = salary; this.bonus = bonus; this.dept_id = dept_id; &#125; // toString方法 @Override public String toString() &#123; return "Employee&#123;" + "id=" + id + ", ename='" + ename + '\'' + ", job_id=" + job_id + ", mgr=" + mgr + ", join_date=" + join_date + ", salary=" + salary + ", bonus=" + bonus + ", dept_id=" + dept_id + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 测试类// mian方法public static void main(String[] args) &#123; //调用方法，接收list集合 List&lt;Employee&gt; emps = returnTable(); //遍历list集合 for (Employee record : emps) &#123; System.out.println(record); &#125;&#125;// 成员方法（返回查询结果）public static List&lt;Employee&gt; returnTable()&#123;Connection conn = null;Statement stat = null;ResultSet reSet = null;List&lt;Employee&gt; tableList = new ArrayList&lt;&gt;();try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "SELECT * FROM emp"; //3.获取数据库连接对象 conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //6.1 让游标向下移动一行 //6.2 并判断是否是最后一行 while (reSet.next()) &#123; //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); //6.4 创建 Employee对象Employee emp = new Employee(id,ename,job_id,mgr,join_date,salary,bonus,dept_id); //6.5 将Employee对象添加进List集合 tableList.add(emp); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 /* 避免空指针异常，使用if语句判断 */ if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //8. 返回List集合 return tableList;&#125; 比较将数据库、实体类和测试类进行比较。 12345678910111213# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号); 1234567891011// 实体类 // 成员变量 private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; 12345678910// 测试类 //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); PreparedStatement PreparedStatement执行动态SQL语句的对象：表示预编译（动态）的SQL语句的对象。 SQL注入问题 指在拼接SQL时，有一些特殊的SQL关键字参与，从而造成了安全性问题。 用户输入前 12// Java语句String sql = "SELECT * FROM user WHERE username = '"+username+"' AND password = '"+password+"';"; 用户输入后， 账户：随便，密码：a’ or ‘a’=’a 1234# SQL语句SELECT * FROM JDBC_user WHERE username = &apos;随便&apos; AND password =&apos;a&apos; OR &apos;a&apos;=&apos;a&apos;;# 语句永远成立，轻松登录成功。 解决SQL注入问题 使用PreparedStatement对象来解决SQL注入问题。 预编译（动态）的SQL：参数使用?作为占位符 使用步骤： 导入驱动jar包 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 传递SQL语句，获取执行动态SQL语句的对象 PreparedStatement 给？占位符赋值： 方法： setXxx(参数1,参数2) 参数1：？占位符的位置编号，从1 开始 参数2：？占位符的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 登录案例 需求 用户通过键盘录入用户名和密码； 查询数据库后，判断用户是否登录成功。 使用静态SQL12345678# 创建表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(30), PASSWORD VARCHAR(30));# 插入数据INSERT INTO USER VALUES(1,&apos;cat&apos;,111),(2,&apos;dog&apos;,222); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// [main方法]public static void main(String[] args) &#123;//用户输入Scanner scanner = new Scanner(System.in);System.out.println("请输入账户：");String username = scanner.next();System.out.println("请输入密码：");String password = scanner.next();//调用login方法boolean flg = login(username, password);//输入if (flg)&#123; System.out.println("登录成功");&#125;else &#123; System.out.println("登录失败");&#125;&#125;//[login方法]public static boolean login(String username, String password) &#123; //防止输入空值 if (username == null) &#123; return false; &#125; if (password == null) &#123; return false; &#125; //声明变量 Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM JDBC_user WHERE username = '"+username+"' AND password = '"+password+"'"; //获取Statement对象 statement = connection.createStatement(); //执行SQL语句，并获取ResultSet对象 resultSet = statement.executeQuery(sql); //返回 return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //返回 return false; &#125; 使用动态SQL1234567891011121314151617// ..... try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM user WHERE username = ? AND password = ? "; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql); //通过PreparedStatement类的set方法，给？占位符赋值 preparedStatement.setString(1,username); preparedStatement.setString(2,password); //通过PreparedStatement类的executeQuery方法，并获取ResultSet对象 resultSet = preparedStatement.executeQuery();//不需要传参 //返回 return resultSet.next();&#125; catch (SQLException e) &#123;// ..... JDBC工具类 经过几个JDBC的案例之后，我们不难发现JDBC的编写中存在大量复杂的相同的代码，为了简化书写，我们引入了JDBC工具类：JDBCUtils。 但仅仅使用JDBC工具类，仍然不能使得获取数据库连接对象的代码变得简洁，而我们每次在获取数据库连接对象时，输入的三个参数是很少会变化的。于是，为了更加简化书写，我们引入了JDBC配置文件：jdbc.properties。 为了达到最终的目的，我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//J DBC工具类：JDBCUtilspublic class JDBCUtils &#123;// [静态变量] private static String url; private static String user; private static String password; private static String driver; // [静态代码块：读取配置文件的数据] static &#123; try &#123;// 1.创建properties对象 Properties properties = new Properties();// 1.1 获取 字节码文件 Class jdbcClass = JDBCUtils.class;// 1.2 获取 类加载器 ClassLoader classLoader = jdbcClass.getClassLoader();// 1.3 获取 统一资源定位符 URL resource = classLoader.getResource("jdbc.properties");// 1.4 获取 路径 String path = resource.getPath();// 2.加载配置文件 properties.load(new FileReader(path));// 3.获取数据 url = properties.getProperty("url"); user = properties.getProperty("user"); password = properties.getProperty("password"); driver = properties.getProperty("driver");// 4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //[成员方法：获取Connection对象] public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat, Connection conn) &#123; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;//[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(Statement stat, Connection conn, ResultSet reSet) &#123; if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345# properties提示配置文件url = jdbc:mysql:///jdbcuser = rootpassword = rootdriver = com.mysql.jdbc.Driver 查询练习123456789101112131415161718192021222324252627282930313233// 使用JDBC工具类public static void main(String[] args) &#123; Connection conn = null; Statement stat = null; ResultSet reSet = null; try &#123; //1.注册驱动 //2.获取数据库连接对象 conn = JDBCUtils.getConnection(); //3.定义SQL语句 String s = "SELECT * FROM account"; //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //1.让游标向下移动一行 //2.并判断是否是最后一行 while (reSet.next()) &#123; //3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble(3); //4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 JDBCUtils.close(stat,conn,reSet); &#125;&#125; JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 JDBC使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) （false为开启事务） 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 我在代码中写入了一句异常 ，当程序运行到异常时，异常后的提交事务不会进行，程序运行catch语句，进行事务回滚，账户会回滚到之前的状态。当然，如果去除异常，交易会正常进行，账户会发生变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null;try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //【开启事务】 connection.setAutoCommit(false); //定义SQL语句 [Cat -500]*** String sql1 = "UPDATE account SET balance = balance - ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql1); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,1); //执行SQL语句 int i = preparedStatement.executeUpdate();System.out.println(i); //定义SQL语句 [Dog +500]*** String sql2 = "UPDATE account SET balance = balance + ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql2); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,2); //执行SQL语句 i = preparedStatement.executeUpdate(); System.out.println(i); // ***异常*** int iii = 3/0; //【提交事务】 connection.commit();&#125; catch (Exception e) &#123; //【事务回滚】 try &#123; if (connection!= null) &#123; connection.rollback(); &#125; &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace();&#125; finally &#123;// 释放资源JDBCUtils.close(preparedStatement,connection);&#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Building MyBatis development environment]]></title>
    <url>%2F2019%2F07%2F31%2FSSM%E6%A1%86%E6%9E%B6%2FMyBatis%2FMyBatis_BDE%2F</url>
    <content type="text"><![CDATA[内容简介 本文是对MyBatis的基础操作方式进行的演示，包括MyBatis环境搭建，以及一些细节知识点。 我们会发现其实各种操作方式的步骤大同小异，因为究其根源它们实现的都是相同的功能。 为了让大家能更好的理解，我们来试着分析一下MyBatis究竟帮我们实现了什么样的功能。 连接MySQL数据库的功能 连接持久层接口的功能 通过映射配置文件的方式 通过注解的方式 实现持久层接口的功能 创建持久层接口实现类 使用代理的持久层接口实现类 搭建环境创建Maven工程 GroupID 项目组织唯一的标识符 实际对应Java的包的结构，main/Java目录下的目录结构。 GroupID分为多段，第一段为域，第二段为公司名称等。 域：org（非盈利组织）、com（商业公司）、cn（中国组织） ArtifactID 项目的唯一的标识符 实际对应项目的名称，项目根目录的名称。 举例：Apache公司的Tomcat项目GroupID：org.apacheArtigactID：tomcat 第一步：创建Maven工程 第二步：设置GroupID、ArtifactID 第三步：设置项目名和模板名 第四步：Maven自动下载组件 添加MyBatis坐标 Maven坐标 Maven拥有数量非常巨大的构件（jar/war），而任何一个构件都可以使用Maven坐标来获取。maven坐标的元素包括groupId，artifactId，version，package，classifier。 引入依赖 一旦我们在pom.xml文件中配置好dependancy标签中的groupId标签，artifact标签，verison标签和classifier标签，maven就会从仓库中寻找相应的构件供我们使用。 在pom.xml 文件中，引入4个依赖： mybatis 3.4.5 mysql 5.1.6 junit 4.10 log4j 1.2.12 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建数据库1234567891011121314# 创建数据库CREATE DATABASE eesy_mybatis;USE eesy_mybatis;# 创建表CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, `sex` CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, `address` VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;# 插入数据INSERT INTO `user`(`id`,`username`,`birthday`,`sex`,`address`) VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;),(42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;),(46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;),(48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 映射配置文件目录结构 src/main java cn/water/dao UserDao.java（持久层接口） cn/water/domain User.java（持久层） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 实体类 实体类要实现Serializable接口，因为在封装MySQL数据库数据时，运用了代理对象。 实体类中的成员变量属性和MySQL数据库中的列属性保持一致。 1234567891011121314151617181920212223242526272829public class User implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口 持久层接口：编写一个操作数据库的方法，但是具体的SQL语句会由持久层接口的映射文件来编写。 1234567public interface UserDao &#123; List&lt;User&gt; findAll();&#125;` 映射配置文件 映射配置文件：专注于编写SQL语法。每个持久层接口对应一个映射配置文件。 创建位置：必须和持久层接口在相同的包中。 持久层接口：src/main/java/cn/water/dao/ 映射配置文件：src/main/resources/cn/water/dao/ 名称：必须以持久层接口名称命名文件名，扩展名是.xml 持久层接口：UserDao.java 映射配置文件：UserDao.xml 12345678910111213141516&lt;!-- UserDao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; MyBatis主配置文件 MyBatis主配置文件：专注于连接数据库。 每个持久层接口对应一个映射配置文件，每个映射配置文件对应MyBatis主配置文件中的一个mapper标签 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试类 测试类：获取查询的结果 123456789101112131415161718192021222324public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream is = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory ssf = ssfb.build(is); /* 使用工厂 生产SqlSession对象 */ SqlSession ss = ssf.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserDao dao = ss.getMapper(UserDao.class); /* 使用代理对象 执行方法 */ List&lt;User&gt; list = dao.findAll(); /* 遍历 */ for (User user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ ss.close(); is.close(); &#125;&#125; 测试类中的设计模式构建者模式 定义： 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 举例 计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将不同计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 InputeStream in = Resources.getResourceAsStream(“SqlMapConfig.xml”);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder;SqlSessionFactory factory = builder.build(in); 工厂模式 定义 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。 举例 各种产品有专门的工厂生产。在苹果工厂，我们可以拿到iPhone、iPad和macbook；在华为工厂，我们可以拿到p30，mate20，Matebook。我们不关心产品是如何做的，甚至可以不关心产品的名字（拿到工厂你就拿到了产品）。 优点 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 区别 建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 SqlSession sqlSession = factory.openSession(); 代理模式 定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 举例 购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； List&lt;User&gt; list = dao.findAll(); 注解 介绍 通过注解来配置时，就不再需要映射配置文件了。目录结构 src/main java cn/water/dao UserAnnoDao.java（持久层接口） cn/water/domain UserAnno.java（持久层） resources SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisAnnoTest.java（测试文件） 实体类1234567891011121314151617181920212223242526272829public class UserAnno implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口（注解） 在持久层接口的方法上添加注解 12345678public interface UserAnnoDao &#123; @Select("SELECT * FROM user;") List&lt;User&gt; findAll();&#125;` MyBatis主配置文件（添加映射） 添加mapper标签 123456789&lt;mappers&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的项目路径。 --&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;!-- 注解：使用class属性指定被注解的持久层接口的全类名。 --&gt; &lt;mapper class="cn.water.dao.UserAnnoDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类 测试类：获取查询的结果。 123456789101112131415161718192021222324public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserAnnoDao dao = sqlSession.getMapper(UserAnnoDao.class); /* 使用代理对象 执行方法 */ List&lt;UserAnno&gt; list = dao.findAll(); /* 遍历 */ for (UserAnno userAnno : list) &#123; System.out.println(userAnno); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 比较 映射配置文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; 注解 显然注解方式，极大的简化了映射配置文件所需要的过程 12@Select("SELECT * FROM user;")List&lt;UserAnno&gt; findAll(); 创建持久层接口实现类区别核心区别在于它们是如何调用持久层接口中抽象方法 目录结构 src/main java cn/water/dao UserImpDao.java（持久层接口） cn/water/dao/Impl UserImpDao.java（持久层接口的实现类） cn/water/domain UserImp.java（持久层） resources cn/water/dao UserImpDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisImpTest.java（测试文件） 实体类1234567891011121314151617181920212223242526272829public class UserImp implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口123456public interface UserImpDao &#123; List&lt;User&gt; findAll();&#125;` 持久层接口实现类（新增）123456789101112131415161718192021public class UserImpDaoImpl implements UserImpDao &#123; private SqlSessionFactory factory; public UserImpDaoImpl(SqlSessionFactory factory)&#123; this.factory = factory; &#125; public List&lt;UserImp&gt; findAll() &#123; /* 使用工厂 创建SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 执行查询所有方法 */ /* 参数为：持久层接口的映射配置文件的namespace属性值+持久层接口的方法名 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll"); /* 释放资源 */ sqlSession.close(); return list; &#125;&#125;` 映射配置文件（更新参数）12345678910111213141516&lt;!-- UserImpDao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserImpDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.UserImp"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; MyBatis主配置文件（添加映射）123&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserImpDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类(编写)12345678910111213141516171819202122232425262728293031323334public class MybatisImpTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 创建持久层接口的对象 */ UserImpDao dao = new UserImpDaoImpl(factory); /* 由持久层接口的实现类来生产SqlSession对象 */ /* 使用工厂 生产SqlSession对象 */ //SqlSession sqlSession = factory.openSession(); /* 当我们自己定义了持久层实现类之后，我就不需要代理类了 */ /* 使用SqlSession对象 创建Dao接口的代理对象 */ // UserImpDao dao = sqlSession.getMapper(UserImpDao.class); /* 使用代理对象 执行方法 */ List&lt;UserImp&gt; list = dao.findAll(); /* 遍历 */ for (UserImp user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ /* 没有session，不必释放资源了 */ // sqlSession.close(); inputStream.close(); &#125;&#125; 报错错误一：IllegalArgumentException错误代码1Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.water.dao.UserImpDao 错误原因一：SqlSession调用selectList方法的参数错误123456&lt;!-- 持久层接口的映射配置文件 --&gt;&lt;mapper namespace="cn.water.dao.UserImpDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.UserImp"&gt; SELECT * FROM user; &lt;/select&gt; 12345678910111213/* 持久层接口的实现类*/public class UserImpDaoImpl implements UserImpDao &#123; public List&lt;UserImp&gt; findAll() &#123; /* 错误参数：持久层接口的映射配置文件的namespace属性值 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao"); /* 正确参数：持久层接口的映射配置文件的namespace属性值+id属性 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll"); &#125;&#125; 错误原因二：MyBatis主配置文件中没有设置mapper标签1234&lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置。 --&gt;&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserImpDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F25%2FJava%20SE%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[基础知识概念 反射是框架设计的灵魂。 反射机制就是将类的各个组成部分封装为其他对象。优势 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 Java代码的阶段 Java代码在计算机中经历的三个阶段 Source（源代码阶段） Java文件被Javac编译为class文件，class文件会将成员变量、成员方法和构造方法等编译成不同的模块。 class文件通过 Classload类加载器 来进入和下一阶段。 Class（类对象阶段） 通过 Classload类加载器，将class文件加载进内存，成员变量、成员方法和构造方法会被封装为Class类中的对象。 Runtime（运行阶段） 当我们需要访问Java文件的成员时，我们就可以逆向访问，通过Class类的Classload类加载器来获取该成员的对象。 获取Class对象 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。 处于Source（源代码阶段），并未加载进内存。 用于配置文件，将类名定义在配置文件中。读取文件，从而加载类。 类名.class：通过类名的属性class获取。 处于Class（类对象阶段），已经加载进内存。 多用于参数的传递。 对象.getClass()：Object类中定义的方法。 Runtime（运行阶段），处于运行时。 用于获取对象的字节码文件对象。 Class类对象 同一个字节码文件( .class)在一次程序运行过程中，只会被加载一次。 不论通过哪一种方式获取的Class类对象都是同一个。12345678// Class类.静态方法forName("全类名")Class class1 = Class.forName("com.test.Person");// 类名.成员classClass class2 = Person.class;// 对象名.成员方法getClass()Person person = new Person();Class class3 = person.getClass(); 获取成员变量 Field[] getFields() 返回包含一个 Field对象数组，反射 所有可访问的 public字段类对象。 Field getField(String name) 返回一个 Field对象，反射 指定的 public成员字段类对象。 Field[] getDeclaredFields() 返回一个 Field对象，反射 所有可访问的 已声明字段类对象。（不考虑修饰符） Field getDeclaredField(String name) 返回一个 Field对象数组，反射 指定已声明字段类对象。（不考虑修饰符） Person类中的成员变量 123456789// public修饰符 public String publicName; public int publicAge;// private修饰符 private String privateName;// protected修饰符 protected String protectedName;// 无修饰符 String name; 获取Person类中的成员变量 123456789101112131415161718192021222324252627 Class pc = Person.class;/* getField("") */Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicName/* getFields() */Field[] fies = pc.getFields(); // public java.lang.String test.Person.publicName // public int test.Person.publicAge/* getDeclaredField("") */Field fie = pc.getDeclaredField("privateName");privateName.setAccessible(true); // private java.lang.String test.Person.privateName/* getDeclaradFields() */Field[] fies = pc.getDeclaredFields();for (Field fie : fies) &#123; fie.setAccessible(true);&#125; // public java.lang.String test.Person.publicName // private java.lang.String test.Person.privateName // protected java.lang.String test.Person.protectedName // java.lang.String test.Person.name 获取构造方法 Constructor&lt;?&gt;[] getConstructors() 返回一个 Constructor对象，反射 指定的 public构造类对象。 Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象，反射 指定的 构造类对象。 Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象数组，反射 所有的 public构造类对象。 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回一个 Constructor对象数组，反射 所有定的 构造类对象。 Person类中的构造方法 123456789// 无参构造public Person() &#123;&#125;// public 带参构造（String）public Person(String publicName) &#123;&#125;// private 带参构造（String,String）private Person(String publicName,String privateName) &#123;&#125; 获取Person类中的构造方法 12345678910111213141516171819202122232425262728/* getConstructor */ Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; Constructor con = pc.getConstructor(String.class); Object object = constructor2.newInstance("Cat"); // &#123;publicName='Cat', privateName='null'&#125;/* getDeclaredConstructor */ Constructor con = pc.getDeclaredConstructor(String.class,String.class,); declaredConstructor.setAccessible(true); Object object = declaredConstructor1.newInstance("Pig","Pug"); // &#123;publicName='Pig', privateName='Pug'&#125;/* getConstructors */ Constructor[] cons = pc.getConstructors(); // public test.Person() // public test.Person(java.lang.String,)/* getDeclaredConstructors */ Constructor[] cons = pc.getDeclaredConstructors(); // public test.Person() // public test.Person(java.lang.String) // private test.Person(java.lang.String,java.lang.String) 获取成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 public成员方法类对象。 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 成员方法类对象。 Method[] getMethods() 返回一个 Method对象数组，反射 所有的 public成员方法类对象。 Method[] getDeclaredMethods() 返回一个 Method对象数组，反射 所有的 成员方法类对象。 Person类中的成员方法 12345678910// public修饰符 public void publicMethod111()&#123;System.out.println("publicMethod()...");&#125; public void publicMethod222(String s)&#123;System.out.println("publicMethod("+ s +")...");&#125;// private修饰符 private void privateMethod()&#123;System.out.println("privateMethod()...");&#125;// protected修饰符 protected void protectedMethod()&#123;System.out.println("publicMethod()...");&#125; 获取Person类中的成员方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445 Class pc = Person.class; Person p = new Person();/* getMethod */ Method method = personClass.getMethod("publicMethod111"); // public void test.Person.publicMethod111() method.invoke(p); // publicMethod()... Method method = personClass.getMethod("publicMethod222", String.class); // public void test.Person.publicMethod222(java.lang.String) method.invoke(p,"带参"); // publicMethod(带参).../* getDeclaredMethod */Method method = pc.getDeclaredMethod("privateMethod"); //private void test.Person.privateMethod()method.setAccessible(true);method.invoke(p); // privateMethod().../* getMethods */ Method[] methods = personClass.getMethods(); //public java.lang.String test.Person.toString() //public java.lang.String test.Person.getName() //public void test.Person.setName(java.lang.String) //public void test.Person.publicMethod111() //public void test.Person.publicMethod222(java.lang.String) //public void test.Person.setPublicAge(int) //public void test.Person.setProtectedName(java.lang.String) //public int test.Person.getPublicAge() // ................................/* getDeclaredMethods */Method[] methods = personClass.getDeclaredMethods(); // public java.lang.String test.Person.toString() // public java.lang.String test.Person.getName() // public void test.Person.setName(java.lang.String) // public void test.Person.publicMethod111() // protected void test.Person.protectedMethod() // private void test.Person.privateMethod() // public void test.Person.publicMethod222(java.lang.String) // public void test.Person.setPublicAge(int) // public void test.Person.setProtectedName(java.lang.String) // ............................... 获取全类名 String getName() 其他操作操作Field 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 暴力反射：忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射123456789101112131415161718Class pc = Person.class;Person p = new Person(); /*public修饰符*/Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicNamefie.set(p,"cat");System.out.print( fie.get(p) ); // cat /*private修饰符*/Field fie = pc.getDeclaredField("privateName"); // private java.lang.String test.Person.privateNamepc.setAccessible(true);pc.set(p,"dog");System.out.print( fie.get(p) ); // dog 操作Constructor 创建对象 T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化 Class对象的newInstance方法 123456789101112 /* Class */ Class pc = Person.class; Object object = pc.newInstance(); // &#123;publicName='null', privateName='null'&#125;/* Constructor */ Class pc = Person.class; Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; 操作Method 执行方法 Object invoke(Object obj, Object… args) 获取方法名 String getName12345Class pc = Person.class;Person p = new Person();Method method = personClass.getMethod("publicMethod111");method.invoke(p);// publicMethod()...]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%2FMySQL%2F</url>
    <content type="text"><![CDATA[基础知识数据库 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。 我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。 所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS 即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS 术语 数据库：数据库是一些关联表的集合。 数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列：一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。MySQL数据库 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。 MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将- 所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。入门配置 打开刚刚解压的文件夹 C:\web\mysql-8.0.11 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 启动 启动MySQL 1net start mysql 登录 MySQ -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 1mysql -h 主机名 -u 用户名 -p 密码 登录本机MySQL 1mysql -u 用户名 -p 密码 关闭MySQL 1net stop mysql 管理 USE $table SHOW DATABASES SHOW TABLES SHOW COLUMNS FROM $table USE $database 选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。 12&gt; Database changed&gt; SHOW DATABASES 列出 MySQL 数据库管理系统的数据库列表。 123456789&gt; +--------------------+&gt; | Database |&gt; +--------------------+&gt; | information_schema |&gt; | mysql |&gt; | performance_schema |&gt; | test |&gt; +--------------------+&gt; SHOW TABLES 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。 12345678&gt; +------------------+&gt; | Tables_in_runoob |&gt; +------------------+&gt; | employee_tbl |&gt; | runoob_tbl |&gt; | tcount_tbl |&gt; +------------------+&gt; SHOW COLUMNS FROM $database 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 12345678+-----------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+--------------+------+-----+---------+-------+| runoob_id | int(11) | NO | PRI | NULL | || runoob_title | varchar(255) | YES | | NULL | || runoob_author | varchar(255) | YES | | NULL | || submission_date | date | YES | | NULL | |+-----------------+--------------+------+-----+---------+-------+ SQL SQL （Structured Query Language ） 结构化查询语言 特点 以分号结尾； 不区分大小写。 分类 DDL（Data Definition Language ） ：定义数据库、表。 DML（Data Manipulation Language） ：对数据库中表的数据进行增删改。 DQL （Data Query Language）：查询数据库中表的数据。 DCL（Data Control Language） ：定义数据库的访问权限和安全级别，及创建用户。 注释 单行注释：“– ”(空格必须加） 单行注释：“#”（空格可加可不加） 多行注释：“/* */” DDL Data Definition Language 数据定义语言 操作数据库使用123456# 使用数据库USE $database;# 查询当前正在使用的数据库名称SELECT DATABASE(); 创建123456789101112# 创建数据库CREATE DATABASE $database;# 创建数据库，并判断是否存在CREATE DATABASE IF NOT EXISTS $database;# 创建数据库，并设置字符集CREATE DATABASE $database CHARACTER SET utf-8;# 创建数据库，判断是否存在，并设置字符集CREATE DATABASE IF NOT EXISTS $database CHARACTER SET utf-8; 查询123456# 查询所有数据库名称SHOW DATABASES;# 查询数据库的创建语句SHOW CREATE DATABASE $database; 修改123# 修改数据库的字符集ALTER DATABASE $database CHARACTER SET gbk; 删除123456# 删除数据库DROP DATABASE $database;# 删除数据库，判断是否存在DROP DATABASE IF EXISTS $database; 操作表、列创建123456789# 创建表CREATE TABLE $table( $columnA $type, $columnB $tyep);# 创建副本CREATE TABLE $tableB LIKE $tableA 查询123456789# 查询某个数据库中的所有表SHOW TABLES;# 查询表结构DESC $table;# 查询表的创建语句SHOW CREATE TABLE $table; 修改123456789101112131415161718# 修改表名ALTER TABLE $tableOld RENAME TO $tableNew# 修改表的字符集ALTER TABLE $table CHARACTER SET utf-8;# 修改列ALTER TABLE $table CHANGE $columnOld $columnNew $typeNew;# 修改类型ALTER TABLE $table MODIFY $column $tyepNew;# 添加列ALTER TABLE $table ADD $column $type;# 删除列ALTER TABLE $table DROP $column; 删除123456# 删除表DROP TABLE $table;# 删除表，判断是否存在DROP TABLE IF EXISTS $table; DML Data Manipulation Language 数据操作语言 操作记录、值创建123456# 给记录中的所有字段，添加值INSERT INTO $table VALUES($valueA,$valueB....)# 给记录中指定的字段，添加值INSERT INTO $table($columnA) VALUES($valueA) 删除123456789# 删除所有记录DELETE * FROM $table;# 删除指定记录DELETE FROM $table WHERE $column = $value;# 删除所有记录，并创建一个空副本TRUNCATE TABLE $table; 修改123456# 给记录中所有的字段，修改值UPDATE $table SET $columnA = $valueA;# 给记录中指定的字段，修改值UPDATE $table SET $columnA = $valueA WHERE $colmnB = $valueB; DQL Data Query Language 数据查询语言 基础查询123456789101112131415161718192021222324252627282930313233# 查询表中的所有列SELECT * FROM $table;# 查询表中指定的列SELECT $column FROM $table;# 查询表中指定的列，并去掉重复的字段SELECT DISTINCT $column FROM $table;# 查询表中指定的列，并计算SELECT $columnA, $columnB, $columnA + $columnB FROM $table;# 查询表中指定的列，并计算，且排除为null的情况SELECT $columnA, $columnB, IFNULL($columnA,0) + IFNULL($columnB,0) FROM $table;# 查询表中指定的列，计算，排除为null的情况，给计算结果起名# AS可省略SELECT $columnA AS $nameA, $columnB AS $nameB, IFNULL($columnA,0)+IFNULL($columnB,0) AS $nameCFROM $table; 条件查询1234567891011121314151617181920# 大于、大于等于、等于、不等于、不等于WHERE $column &gt; $value;WHERE $column &gt;= $value;WHERE $column = $value;WHERE $column != $value;WHERE $column &lt;&gt; $value;# 范围WHERE $column&gt;=10 &amp;&amp; $column&lt;=100;WHERE $column&gt;=10 AND $column&lt;=100;WHERE $column BETWEEN 10 AND 1000;# 个例WHERE $column=10 OR $column=20;WHERE $column IN (10,20,30,40);#查询NULLWHERE $column IS NULL;WHERE $column IS NOT NULL; 模糊查询123456# “_” 单个任意字符WHERE $column = &apos;C_t&apos;;# “%” 多个任意字符WHERE $column = &apos;super%&apos;; 排序查询123456# 按照指定列的顺序，升序排序ORDER BY $column ASC;# 按照指定列的顺序，降序排序ORDER BY $column DESC; 聚合函数 聚合函数排除了NULL值123456789101112131415161718# 计算指定列的 字段个数SELECT COUNT($column) FROM $table;# 计算指定列的 字段个数，且不排除NULL值SELECT COUNT( IFNULL($column,0) ) FROM $table;# 计算指定列的 最大值SELECT MAX($column) FROM $table;# 计算指定列的 最小值SELECT MIN($column) FROM $table;# 计算指定列的和SELECT SUM($column) FROM $table;# 计算指定列的平均值SELECT AVG($column) FROM $table; 分组查询12 分页查询DCL Data Control Language 数据控制语言 12 约束]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS中的函数是否加括号的问题]]></title>
    <url>%2F2019%2F07%2F22%2FJava%20WEB%2FJS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数表达式的定位 本文相关的概念：函数，函数表达式，返回值。 函数：函数名为Fun的函数。函数表达式：Fun() 和 fun。返回值：即函数Fun的返回值。 首先，需要明确的概念是：函数表达式的定位。不同的定位决定了不同的功能，以下是我列出来的函数表达式及其定位。我会在详细表述表达式时，附上便于理解的代码。 函数表达式 定位 function() 调用函数、返回返回值 function 函数的副本 函数表达式 function()当按钮被点击，函数表达式Fun() 作为参数首先被执行。于是，第一步，函数Fun被调用，函数Fun执行 方法alert(111)，弹出“111”；第二步，函数fun 返回 返回值222。接着，按钮的点击事件执行 alert方法，并接收到了返回值222，弹出“222”。 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun()); &#125;&lt;/script&gt; 函数表达式 function我们在前面说到 函数表达式Fun 的定位是 函数Fun 的一个副本。为了印证这个观点，其余代码不变，将函数表达式Fun() 换成 函数表达式Fun。我得到的结果是，弹出： “ function Fun() { alert(1); return 222; } “ 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F07%2F21%2FJava%20WEB%2Fredis%2F</url>
    <content type="text"><![CDATA[NoSQL概念 NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web- 0网站的兴起，传统的关系数据库在应付web- 0网站，特别是超大规模和高并发的SNS类型的web- 0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 比较非关系型数据库优势 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 ## 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 ## 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis## 概念 Redis是一款高性能的NOSQL系列的非关系型数据库 Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s 。 Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedsetredis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离下载安装 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端数据结构 Redis存储：key，value格式的数据 key的数据类型：字符串 value的数据结构： 字符串类型 string 哈希类型 hash （map格式） 列表类型 list （ Linkedlist格式，允许重复） 集合类型 set （HashSet格式，不允许重复） 有序集合类型 sortedset （不允许重复，且有序）命令操作字符串类型 string 存储： set key value 获取： get key 删除： del key 哈希类型 hash 存储： hset key field value 获取指定的field对应的值：hget key field: 获取所有的field和value：hgetall key 删除： hdel key field 列表类型 list 将元素加入列表左边： lpush key value 将元素加入列表右边：rpush key value 范围获取：lrange key start end 获取所有元素：lrange key 0 -1 删除列表最左边的元素，并将元素返回：lpop key 删除列表最右边的元素，并将元素返回：rpop key 集合类型 set set 集合 （ 不允许重复） 存储：sadd key value 获取set集合中所有元素：smembers key 删除set集合中的某个元素：srem key value 有序集合类型 sortedset sortedset集合 不允许重复元素，且元素有顺序。 每个元素都会关联一个double类型的分数。 redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令 查询所有的键：keys * 获取键对应的value的类型：type key 删除指定的key value：del key 持久化机制 Redis持久化 Redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据丢失时，我们可以将redis内存中的数据持久化，将其保存到硬盘的文件中。RDB 默认持久化机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据。 修改 redis.windwos.conf 文件 save 900 1：after 900 sec (15 min) if at least 1 key changed save 300 10：after 300 sec (5 min) if at least 10 keys changed save 60 10000：after 60 sec if at least 10000 keys changed 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf AOF 日志记录机制 记录每一条命令的操作。每一次命令操作后，持久化数据。 编辑 redis.windwos.conf 文件 开启AOF appendonly no（关闭AOF） ppendonly yes （开启AOF） 取值 appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化（默认） appendfsync no： 不进行持久化 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf Jedis（Java客户端） Jedis:是一款java操作redis数据库的工具.快速入门 下载jedis的jar包 使用123456// 获取连接 Jedis jedis = new Jedis("localhost",6379);// 操作 jedis.set("username","zhangsan");// 关闭连接 jedis.close(); 命令操作字符串类型 string set get1234567891011121314151617@Test/* 操作字符串String */public void test02() &#123; // 获取连接 Jedis jedis = new Jedis(); //空参构造，默认("localhost",6379) // 存储 jedis.set("cat","001"); // 获取 String cat = jedis.get("cat"); System.out.println(cat); // 存储有时限的数据 jedis.setex("dog",10,"002"); // 时间单位：秒 // 关闭连接 jedis.close();&#125; 哈希类型 hash （ map格式 ） hset hget hgetAll12345678910111213141516171819202122232425@Test /* 操作Hash */public void test03() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.hset("map","cat","111"); jedis.hset("map","dog","222"); jedis.hset("map","rat","333"); // 获取 String cat = jedis.hget("map", "cat"); System.out.println(cat); // 获取hash中的map中的所有数据 Map&lt;String, String&gt; map = jedis.hgetAll("map"); // 输出 Set&lt;String&gt; keySet = map.keySet(); for (String s : keySet) &#123; String value = map.get(s); System.out.println(s+":"+value); &#125; // 关闭连接 jedis.close();&#125; 列表类型 list （ LinkedList格式，允许重复） lpush / rpush lpop / rpop lrange start end 12345678910111213141516171819202122@Test /* 操作List(允许重复) */public void test04() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.lpush("list","A","B","C","D"); jedis.rpush("list","A","B","C","D"); // 打印 List&lt;String&gt; list = jedis.lrange("list", 0, -1); System.out.println(list); // 弹出 String element1 = jedis.lpop("list"); String element2 = jedis.lpop("list"); // 打印 System.out.println(element1); System.out.println(element2); List&lt;String&gt; list2 = jedis.lrange("list", 0, -1); System.out.println(list2); // 关闭连接 jedis.close();&#125; 集合类型 set （HashSet格式， 不允许重复） sadd smembers12345678910111213@Test /* 操作Set(不允许重复) */public void test05() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.sadd("set","A","B","C","D"); // 获取 Set&lt;String&gt; set = jedis.smembers("set"); // 打印 System.out.println(set); // 关闭连接 jedis.close();&#125; 有序集合类型 sortedset zadd zrange123456789101112131415@Test /* 操作SortedSet(不允许重复，有序) */public void test06() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.zadd("sortedSet",1,"cat"); jedis.zadd("sortedSet",2,"dog"); jedis.zadd("sortedSet",3,"rat"); // 获取 Set&lt;String&gt; sortedSet = jedis.zrange("sortedSet", 0, -1); // 打印 System.out.println(sortedSet); // 关闭连接 jedis.close();&#125; JedisPool（jedis连接池） 快速入门 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接123456789101112131415// 创建连接池配置对象 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); // 设置配置 jedisPoolConfig.setMaxTotal(50); jedisPoolConfig.setMaxIdle(10); // 创建连接池对象，并传入连接池配置对象 JedisPool jedisPool = new JedisPool(jedisPoolConfig, "localhost", 6379); // 获取连接 Jedis resource = jedisPool.getResource(); // 使用 resource.set("name", "cat"); String s = resource.get("name"); System.out.println(s); // 关闭，归还到连接池中 resource.close(); JedisPoolUtil工具类 设置 JedisPoolUtil工具类 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 设置之后的操作，简化了很多 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; ​]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F07%2F20%2FJava%20WEB%2FJson%2F</url>
    <content type="text"><![CDATA[概念 JSON：JavaScript 对象表示法（JavaScript Object Notation） JSON现在多用于存储和交换文本信息的语法，进行数据的传输。 JSON 比 XML 更小、更快，更易解析。 注意：JSON 虽然使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。1234567&#123; "employees": [ &#123; "firstName":"Bill" , "lastName":"Gates" &#125;, &#123; "firstName":"George" , "lastName":"Bush" &#125;, &#123; "firstName":"Thomas" , "lastName":"Carter" &#125; ]&#125; 区别类似 XML JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字总结 对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 语法 JSON 语法是 JavaScript 语法的子集。语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组名称/值对JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：1"firstName" : "John" 值 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） { “firstName”:”John” , “lastName”:”Doe” } null文件 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” 使用获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 123456789101112131415161718192021222324252627282930313233 /* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; var name11 = person.name; var name12 = person["name"];/* 嵌套格式 */ // JSON &#123; JSON,JASON &#125; var persons = &#123; "personCat": &#123;"name":"cat","age":11&#125;, "personDog":&#123;"name":"dog","age":12&#125;, "personRat":&#123;"name":"rat","age":13&#125;&#125; var personCat = persons.personCat; var name2 = persons.personCat.name; // Array [JSON,JASON] var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] var name3 = array[0].name; // JSON &#123; Array[JSON,JASON], Array[JSON,JASON] &#125; var persons = &#123; "person1":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,], "person2":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,] &#125; var name4 = persons.person1[0].name; 遍历12345678910111213141516171819202122/* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; for (var key in person) &#123; // * key默认为字符串 alert(key); alert(person.key); // * person."name"; 无法获取 alert(person[key]); // * person["name"]; 无法获取 &#125; /* 嵌套格式 */ var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] for (var i =0;i&lt;array.length;i++) &#123; var p = array[i]; for (var key in p) &#123; alert(key); alert(p[key]); &#125; &#125; 转换 转换 由于JSON对象的特性，在实际操作中，我们通过JSON对象代替Java对象在数据中的传输。所以，我们需要学习JSON对象和Java对象的相互转换。 JSON解析器 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class)Java对象转换JSON 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 writeValue(参数1，obj) File：将obj对象转换为JSON字符串，并保存到指定的文件中。 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中。 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中。 writeValueAsString(obj) 将对象转为json字符串 注解 @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern = “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致 格式问题 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。 在浏览器端设置$.ajax属性 $.get(type):将最后一个参数type指定为”json” 在服务器端设置MIME类型 response.setContentType(“application/json;charset=utf-8”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F07%2F20%2FJava%20WEB%2FAjax%2F</url>
    <content type="text"><![CDATA[基础知识AJAX AJAX 是与服务器交换数据的艺术，它在不重载全部页面的情况下，实现了对部分网页的更新。 AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 异步和同步 同步 客户端和服务器端相互通信的基础上，客户端必须等待服务器端的响应。 在等待的期间客户端不能做其他操作。 异步 客户端和服务器端相互通信的基础上，客户端不需要等待服务器端的响应。 在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式JS实现方式（了解） 如果没有 jQuery，AJAX 编程还是有些难度的。123456789101112131415161718192021222324252627282930313233/* 发送异步请求 */// 1.创建对象 var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125;// 2.建立连接// * 请求方式：GET/POST// * 请求的URL// * 同步或异步请求：true（异步）、false（同步） xmlhttp.open("GET","/ajaxServlet?fname=Henry&amp;lname=Ford",true);// 3.发送请求 xmlhttp.send(); // POST方式 // xmlhttp.open("POST","/ajaxServlet",true); // xmlhttp.send("fname=Henry&amp;lname=Ford");// 4.接受并处理来自服务器的相应结果// 判断服务器是否成功响应 xmlhttp.onreadystatechange=function()&#123; // readyState：就绪状态 // status：响应状态码 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; // responseText：响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQeury实现方式 通过 jQuery AJAX 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON 同时能够把这些外部数据直接载入网页的被选元素中。$.ajax() 12345678910111213141516171819$.ajax(&#123; // url：请求路径 url:"/ajaxServlet", // type：请求方式 type:"POST", // data：请求参数 // data:"fname=Henry&amp;lname=Ford", data:&#123;"fname":"Henry","lname":"Ford"&#125;, // Json方式// success：响应成功后的回调函数 success:function (responseData) &#123; alert(responseData);&#125;,// error：响应错误后的回调函数error:function () &#123; alert("出错了!"); &#125;, // dateType：设置接受到的响应数据的格式 dataType:"text"&#125;); $.get()123456789101112 $.get( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125; $.post()123456789101112$.post( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F07%2F19%2FJava%20WEB%2FjQuery%2F</url>
    <content type="text"><![CDATA[基础知识简介 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。 jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 jQuery封装了JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery本质上就是一些js文件，封装了js的原生代码而已。 jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 安装 下载JQuery 目前jQuery有三个大版本 1.x 兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了。 2.x 不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x。 3.x 不兼容ie678，只支持最新的浏览器。 除非特殊要求，一般不会使用3.x版本的，因为很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。 每个大版本包括两个小版本 jquery.js Development version（开发版本） - 用于测试和开发。 给程序员看的，有良好的缩进和注释，体积大一些，程序加载较慢。 jquery.min.js Production version（生产版本）- 用于实际的网站中，已被精简和压缩。 在程序中使用，没有缩进，体积小一些，程序加载更快。 导入JQuery的js文件 引入Jquery资源 请注意，&lt;script&gt; 标签应该位于页面的 &lt;head&gt; 部分。123&lt;head&gt; &lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt; 基础语法 $(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作文档就绪函数 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 123456789/* 完全体 */$(document).ready(function()&#123;&#125;);/* 简化版 */$(function()&#123;&#125;); 转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用 两者相互转换 Jquery – &gt; JS Jquery对象[索引] Jquery对象.get(索引) JS – &gt; Jquery $(JS对象) 选择器 jQuery选择器允许您对元素组或单个元素进行操作。 jQuery 元素选择器和属性选择器允许您通过标签名、属性名或内容对 HTML 元素进行选择。 jQuery选择器允许您对 HTML 元素组或单个元素进行操作。 在 HTML DOM 术语中：jQuery选择器允许您对 DOM 元素组或单个 DOM 节点进行操作。 基本选择器 选择器 实例 描述 * $(“*”) 所有元素 this $(this) 当前 HTML 元素 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) 所有 class=”intro” 的元素 .class.class $(“.intro.demo”) 所有 class=”intro” 且 class=”demo” 的元素 element $(“p”) 所有 &lt;p&gt; 元素 element.class $(“p.intro”) 所有 class=”intro” 的 &lt;p&gt; 元素 element#id $(“p#demo”) 所有 id=”demo” 的 &lt;p&gt; 元素。 s1,s2,s3 $(“th,td,.intro”) 所有带有匹配选择的元素 层级选择器 选择器 实例 描述 super sub $(“table tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;元素（不仅是子元素） super &gt; sub $(“table &gt; tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;子元素 ## 属性选择器 - jQuery 使用 XPath 表达式来选择带有给定属性的元素。 选择器 实例 描述 :—: —– —– [atribute] $(“[href]”) 所有带有 href 属性的元素 [[attribute = value]] $(“[href=’#’]”) 所有 href 属性的值等于 “#” 的元素 [[attribute != value]] $(“[href!=’#’]”) 所有 href 属性的值不等于 “#” 的元素 [[attribute *$= *value]] $(“[href$=’.jpg’]”) 所有 href 属性的值包含以 “.jpg” 结尾的元素 过滤选择器 选择器 实例 描述 [:first] $(“p:first”) 第一个 &lt;p&gt; 元素 [:last] $(“p:last”) 最后一个 &lt;p&gt; 元素 [:even] $(“tr:even”) 所有偶数 &lt;tr&gt; 元素 [:odd] $(“tr:odd”) 所有奇数 &lt;tr&gt; 元素 [:eq(index)] $(“ul li:eq(3)”) 列表中的第四个元素（index 从 0 开始） [:gt(no)] $(“ul li:gt(3)”) 列出 index 大于 3 的元素 [:lt(no)] $(“ul li:lt(3)”) 列出 index 小于 3 的元素 [:empty] $(“:empty”) 无子（元素）节点的所有元素 :not(selector) $(“input:not(:empty)”) 所有不为空的 input 元素 [:header] $(“:header”) 所有标题元素 &lt;h1&gt; - &lt;h6&gt; [:contains(text)] $(“:contains(‘W3School’)”) 包含指定字符串的所有元素 :hidden $(“p:hidden”) 所有隐藏的 &lt;p&gt; 元素 [:visible] $(“table:visible”) 所有可见的表格 表单过滤选择器 选择器 实例 描述 [:input] $(“:input”) 所有 &lt;input&gt; 元素 [:text] $(“:text”) 所有 type=”text” 的 &lt;input&gt; 元素 [:password] $(“:password”) 所有 type=”password” 的 &lt;input&gt; 元素 [:radio] $(“:radio”) 所有 type=”radio” 的 &lt;input&gt; 元素 [:checkbox] $(“:checkbox”) 所有 type=”checkbox” 的 &lt;input&gt; 元素 [:submit] $(“:submit”) 所有 type=”submit” 的 &lt;input&gt; 元素 [:reset] $(“:reset”) 所有 type=”reset” 的 &lt;input&gt; 元素 [:button] $(“:button”) 所有 type=”button” 的 &lt;input&gt; 元素 [:image] $(“:image”) 所有 type=”image” 的 &lt;input&gt; 元素 [:file] $(“:file”) 所有 type=”file” 的 &lt;input&gt; 元素 [:enabled] $(“:enabled”) 所有激活的 input 元素 [:disabled] $(“:disabled”) 所有禁用的 input 元素 [:selected] $(“:selected”) 所有被选取的 input 元素 [:checked] $(“:checked”) 所有被选中的 input 元素 事件函数 jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 术语由事件“触发”（或“激发”）经常会被使用。 如果你的网站包含许多页面，为了让 jQuery 函数易于维护，需要将 jQuery 函数放到独立的 .js 文件中。123456&lt;head&gt;&lt;!-- 引入Jquery资源 --&gt;&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;!-- 引入独立的js文件 --&gt;&lt;script type="text/javascript" src="my_jquery_functions.js"&gt;&lt;/script&gt;&lt;/head&gt; 鼠标事件 事件 描述 click 当单击元素时 dbclick 当双击元素时 mouseenter 当鼠标指针穿过（进入）被选元素时 mouseleave 当鼠标指针离开被选元素时 hover 当鼠标指针悬停在被选元素上时 ## 键盘事件 事件 描述 —– :—: keydown 键按下的过程 keypress 键被按下 keyup 键被松开 ## 表单事件 事件 描述 —– :—: submit 当提交表单时 change 当元素的值改变时发生 change 事件（仅适用于表单字段） focus 当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时） blur 当元素失去焦点时 ## 窗口事件 事件 描述 —– :—: resize 当调整浏览器窗口大小时 scroll 当用户滚动指定的元素时 DOM操作 jQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 提示：DOM = Document Object Model（文档对象模型）内容操作方法 html() 获取/设置元素的标签体内容（包括 HTML 标记） text() 获取/设置元素的标签体纯文本内容 val() 获取/设置元素的value属性值123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("Dolly Duck");&#125;); 属性操作方法 通用属性操作 attr() 获取/设置元素的属性 如果操作的是元素自定义的属性，则建议使用attr removeAttr() 删除属性 prop() 获取/设置元素的属性 如果操作的是元素的固有属性，则建议使用prop removeProp() 删除属性123$("button").click(function()&#123; $("#w3s").attr("href","http://www.w3school.com.cn/jquery");&#125;); 对class属性操作 addClass() 添加class属性值 removeClass() 删除class属性值 toggleClass() 切换class属性 toggleClass(“one”): 如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加。 css() 设置/添加属性值 123456789101112131415$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;);$("button").click(function()&#123; $("h1,h2,p").removeClass("blue");&#125;);$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;);$("p").css("background-color","yellow");$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); 文档操作方法 append() 父元素将子元素追加到末尾 A.append(B) 将B添加到A元素内部，并且在末尾。 prepend() 父元素将子元素追加到开头 A.prepend(B) 将B添加到A元素内部，并且在开头。 appendTo() 子元素将父元素追加到末尾 A.appendTo(B) 将A添加到B内部，并且在末尾。 prependTo() 子元素将父元素追加到开头 A.prependTo(B) 将A添加到B内部，并且在开头。 after() 添加元素2到元素1后边 A.after(B) 将B添加到A后边（兄弟关系） before() 添加元素2到元素1前边 A.before(B) 将B添加到A前边（兄弟关系） insertAfter() 添加元素1到元素2后边 A.insertAfter(B) 将A添加到B后边（兄弟关系） insertBefore() 添加元素1到元素2前边 A.insertBefore(B) 将A添加到B前边（兄弟关系） remove() 移除元素 A.remove() 将A删除掉 empty() 清空元素的所有后代元素。 A.empty() 将对象的后代元素全部清空，但是保留当前A以及其属性节点12345678$("p").append("Some appended text.");$("p").prepend("Some prepended text.");$("img").after("Some text after");$("img").before("Some text before");$("#div1").remove();// jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。$("p").remove(".italic");$("#div1").empty(); 动画显示/隐藏 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： show( speed，callback ) hide( speed，callback ) 通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。 toggle(speed,callback) speed：参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 callback：参数是隐藏或显示完成后所执行的函数名称。1234567891011$("#hide").click(function()&#123; $("p").hide();&#125;);$("#show").click(function()&#123; $("p").show();&#125;);$("button").click(function()&#123; $("p").toggle();&#125;); 淡入/淡出 通过 jQuery，您可以实现元素的淡入淡出效果。 fadeIn() 用于淡入已隐藏的元素。 fadeOut() 用于淡出可见元素。 fadeToggle() 在淡入淡出之间切换。1234567891011121314151617$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); 滑动 通过 jQuery，您可以在元素上创建滑动效果。 slideDown() 用于向下滑动元素。 slideUp() 用于向上滑动元素。 slideToggle() 在向下滑动向上滑动之间切换。1234567891011$("#flip").click(function()&#123; $("#panel").slideDown();&#125;);$("#flip").click(function()&#123; $("#panel").slideUp();&#125;);$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 遍历JS的遍历方式 for (初始化值;循环结束条件;步长)Jquery的遍历方式 Jquery对象.each(callback) jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 callback：回调函数返回值 true：如果当前function返回为false，则结束循环(break)。 false：如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of for(元素对象 of 容器对象) Jqueryuery 3.0 之后1234567891011121314151617181920212223242526272829303132333435363738 /* for循环 */var citys = $("#city li");for (var i = 0; i &lt; citys.length; i++) &#123; //获取内容 alert(i+":"+citys[i].innerHTML); if("上海" == citys[i].innerHTML)&#123; //break; 结束循环 //continue; //结束本次循环，继续下次循环 &#125;&#125;/* Jquery对象.each(callback) */var citys = $("#city li");citys.each(function (index,element) &#123; // 1.获取li对象 第一种方式 this alert(this.innerHTML);//JS对象调用 alert($(this).html());//Jquery对象调用 // 2.获取li对象 第二种方式 在回调函数中定义参数 index（索引） element（元素对象） alert(index+":"+element.innerHTML); alert(index+":"+$(element).html()); //判断如果是上海，则结束循环 if("上海" == $(element).html())&#123; //返回false，结束循环(break)。 //返回true，结束本次循环，继续下次循环(continue) return true; &#125;&#125;);/* $.each(object, [callback]) */$.each(citys,function (index,element) &#123; alert($(this).html());&#125;);/* for ... of (jquery 3.0 版本之后提供的方式) */for(li of citys)&#123; alert($(li).html());&#125; 事件绑定 Jquery标准的绑定方式 jq对象.事件方法(回调函数) 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 toggle事件切换 jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。1&lt;script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 插件 $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie&Session&JSP]]></title>
    <url>%2F2019%2F07%2F15%2FJava%20WEB%2FCookie%26Session%26JSP%2F</url>
    <content type="text"><![CDATA[会话技术 概念 一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。 功能 在一次会话的范围内的多次请求间，来共享数据。 方式 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 客户端会话技术，将数据保存到客户端。 Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies）； 一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies） 快速入门 使用步骤： 服务器通过response，对浏览器发送cookie *new Cookie(String name, String value) * *response.addCookie(Cookie cookie) * 服务器通过request，接收浏览器发送的cookie *Cookie[] request.getCookies() * 实现原理 服务器通过response，对浏览器发送cookie 服务器将数据，保存在响应头的set-cookie中。 当服务器通过request，接收浏览器发送的cookie 浏览器将数据，保存在请求头的cookie中。 cookie的细节一次可不可以发送多个cookie? 一次可以发送多个cookie。 创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁。 设置Cookie生命周期，使其持久化存储 setMaxAge(int seconds) 正数：持久化存储，并指定cookie存活时间。 在时间内，关闭浏览器cookie仍然可访问。 负数：默认值 关闭浏览器后，无法访问。 零：删除cookie信息 一般是先设置持久化存储，然后删除。cookie能不能存储中文？ 在tomcat8 之前，cookie中不能直接存储中文数据。 需要将中文数据转码为一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。 特殊字符还是不支持，建议使用URL编码存储，URL解码解析cookie共享问题？ 在同一个tomcat服务器中的多个web项目的cookie能不能共享？ 默认情况下cookie不能共享 设置获取cookie范围（默认设置当前虚拟目录） setPath(String path) 如果要共享，则可以将path设置为”/“（根路径） 在不同的tomcat服务器间cookie能不能共享？ 设置获取cookie范围 setDomain(String path) 如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”) 那么tieba.baidu.com和news.baidu.com中cookie可以共享 特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 浏览器对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别（个性化设置） JSP概念 Java Server Pages（java服务器端页面） 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理 JSP本质上就是一个Servlet实现类 如果我们要编写一个正常的主页，那么我们在servlet实现类中既要写后端代码，也要写前端代码。但是在servlet实现类中写前端代码（response.write.write()）太麻烦了，所以出现了JSP。 JSP本质是一个servlet实现类，它会将所有的前端代码自动的包裹进输出代码（out.write()）。 脚本 JSP的脚本：JSP定义Java代码的方式 &lt;% %&gt; 定义的java代码，在service方法中。 &lt;%! %&gt; 定义的java代码，定义java类的成员。 &lt;%= %&gt; 定义的java代码，输出到页面上。 内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象 request response out 字符输出流对象。可以将数据输出到页面上。 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 Session概念 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 快速入门 获取HttpSession对象 HttpSession session = request.getSession() 使用HttpSession对象 Object getAttribute(String name) void setAttribute(String name, Object value) *void removeAttribute(String name) * 原理 Session的实现是依赖于Cookie的。 细节 当浏览器关闭后，服务器不关闭，两次获取的session是否相同？ 默认情况下，两次session不同。 浏览器关闭，意味着会话结束。 如果需要两次session相同 创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie cookie = new Cookie(“JSESSIONID”,session.getId()); cookie.setMaxAge(60*60); response.addCookie(c); 浏览器不关闭，服务器关闭后，两次获取的session是否相同？ 两次session不同，但是要确保数据不丢失。 tomcat自动完成，IDEA不能 自动完成。 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上。 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30 &lt;session-config&gt; ## 特点－ session用于存储一次会话的多次请求的数据，存在服务器端。－ session可以存储任意类型，任意大小的数据。 session与Cookie的区别 Session(会话） － session存储数据在服务器端 － session没有数据大小限制 － session数据安全 Cookie（甜点） －Cookie有数据大小限制 －Cookie存储数据在客户端 －Cookie相对于不安全]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2F2019%2F07%2F14%2FJava%20WEB%2Fresponse%2F</url>
    <content type="text"><![CDATA[功能设置响应行 设置状态码 *setStatus(int sc) * 设置响应头 设置响应头 *setHeader(String name, String value) * 设置响应体 获取输出流 字符输出流（字符数据） PrintWriter getWriter() 字节输出流（任意数据） ServletOutputStream getOutputStream() 其他功能重定向（redirect） 重定向是一种在互联网中的资源跳转方式。 方法一 通过response对象设置状态码 response.setStatus(302); 使用response对象设置响应头的location参数 *response.setHeader(“location”,”/response2”); * 方法二 通过response对象的重定向方法 response.sendRedirect(“/response2”); 重定向的特点 重定向 重定向 地址栏会发生变化 重定向 可以访问其他服务器的资源 重定向 是两次请求 转发的特点 转发 转发 地址栏不会发生变化 转发 不可以访问其他服务器的资源 转发 是一次请求 输出数据 设置 获取字符输出流 PrintWriter writer = response.getWriter(); 输出数据 writer.write(“&lt;h1&gt;在恭喜发财！&lt;/h1&gt;”); 中文乱码问题 在获取流之前，设置流编码为系统默认编码（可以不写） response.setCharacterEncoding(“utf-8”); 设置浏览器解码的编码 response.setHeader(“content-type”,”text/html;charset=utf-8”); 设置浏览器解码的编码（简化） response.setContentType(“text/html;charset=utf-8”); ServletContext对象概念 ServletContext对象代表整个web应用，可以和程序的容器(服务器)来通信。获取 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext();功能获取MIME类型 获取MIME类型 String getMimeType(String file) MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。ServletContext域：所有用户所有请求的数据 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 文件真实路径 获取文件的真实路径（tomcat服务器） String getRealPath(String path); web目录下资源访问 context.getRealPath(“/b.txt”); WEB-INF目录下的资源访问 context.getRealPath(“/WEB-INF/c.txt”); src目录下的资源访问 context.getRealPath(“/WEB-INF/classes/a.txt”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2F2019%2F07%2F13%2FJava%20WEB%2Frequest%2F</url>
    <content type="text"><![CDATA[原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 体系结构 ServletRequest 接口 HttpServletRequest 接口 （继承） org.apache.catalina.connector.RequestFacade 类（Tomcat实现） 功能获取请求消息数据获取请求行数据 请求行数据：GET /web/A?name=Cat HTTP/1.1 请求方式： GET String getMethod() 请求端的URI(统一资源标识符) 地址：/web/A String getRequestURI() 请求端的URL(统一资源定位符)地址： http: //localhost//web/A StringBuilder getRequestURL() 虚拟目录：/web String getContextPath() 服务器路径：/A String getServletPath() 请求参数：name=Cat String getQueryString() HTTP协议的版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr()123456789101112131415161718//请求方式： GET String method = request.getMethod();//请求端的URI地址：/web/A String requestURI = request.getRequestURI();//请求端的URI地址：/web/A StringBuffer requestURL = request.getRequestURL();//虚拟目录：/web String contextPath = request.getContextPath();//服务器路径：/A String servletPath = request.getServletPath();//请求参数：name=Cat String queryString = request.getQueryString();//HTTP协议的版本：HTTP/1.1 String protocol = request.getProtocol();//获取客户机的IP地址： String remoteAddr = request.getRemoteAddr();//获取客户机的端口号 int remotePort = request.getRemotePort(); 获取请求头数据 请求头数据 通过请求头的名称 获取请求头的值 String getHeader(String name) 获取 所有的请求头名称（判断浏览器） Enumeration&lt;String&gt; getHeaderNames():12345678//获取 所有的请求头名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements())&#123; //通过请求头的名称 获取请求头的值 String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name+" ===== "+value); &#125; 获取请求体数据 请求体（POST请求方式） 获取字符输入流（字符数据） BufferedReader getReader() 获取字节输入流（所有类型数据） ServletInputStream getInputStream()1234567&lt;form action="/request1" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;input type="checkbox" name="hobby" value="dance"&gt; &lt;input type="checkbox" name="hobby" value="sing"&gt; &lt;input type="checkbox" name="hobby" value="rap"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 1234567891011@WebServlet("/request1")public class Request1 extends HttpServlet &#123;//获取字符输入流（字符数据） BufferedReader reader = request.getReader(); String line; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; 其他功能获取动态目录 为了防止虚拟目录变更，建议使用动态虚拟目录 -getContextPath() 路径 相对路径 相对路径 无法确定唯一资源 ./index.html 当前资源和目标资源的相对位置关系 ./ 当前目录 ../ 后退一级目录 绝对路径 绝对路径 可以确定唯一资源 /web/index.html 获取请求参数(通用) 获取请求参数通用方式 不论get还是post请求方式都可以使用下列方法来获取请求参数 根据参数名称 获取参数值 ：(username) cat String getParameter(String name) 根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] getParameterValues(String name) 获取 所有请求的参数名称：username hobby Enumeration&lt;String&gt; getParameterNames() 获取 所有参数的map集合：username=cat hobby=sing,rap Map&lt;String,String[]&gt; getParameterMap()1234567891011121314151617181920212223242526272829303132333435//根据参数名称 获取参数值 ：(username)cat String username = request.getParameter("username"); System.out.println(username); //根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] hobbies = request.getParameterValues("hobby"); for (String hobby : hobbies) &#123; System.out.println(hobby); &#125;//获取 所有请求的参数名称： username hobbyEnumeration&lt;String&gt; parameterNames = request.getParameterNames();while (parameterNames.hasMoreElements())&#123;String s = parameterNames.nextElement();System.out.println(s);&#125;//获取 所有参数的map集合 /* Map集合：获取所有参数 */ Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); /* Set集合：包含参数和参数的值们 */ Set&lt;String&gt; keyset = parameterMap.keySet(); /* 迭代器*/ Iterator&lt;String&gt; iterator = keyset.iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.print(key+": "); String[] values = parameterMap.get(key); for (String value : values) &#123; System.out.print(value+" "); &#125; System.out.println();&#125; 请求转发（forword） 请求转发是一种在服务器内部的资源跳转方式。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 *forward(ServletRequest request, ServletResponse response) * 特点 浏览器地址栏路径不发生变化。 只能转发到当前服务器内部资源中。 多个服务器资源使用一次请求。 Java文件一 1234567891011@WebServlet("/request111")public class Request1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("助理：我是处理部门的助理，你有什么问题？"); System.out.println("助理：你的问题我解决不了，我去叫经理，稍等。"); //找到“经理的位置” RequestDispatcher requestDispatcher = request.getRequestDispatcher("/request222"); //把“问题”告诉经理 requestDispatcher.forward(request,response); &#125;&#125; Java文件二 1234567@WebServlet("/request222")public class Request2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("经理：我是处理部门的经理，你有什么问题？"); System.out.println("经理：你的问题我已经解决了，你回去吧。"); &#125;&#125; 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 中文乱码问题 get方式：tomcat 8 已经将get方式乱码问题解决了。 post方式：中文或非法数据会乱码。 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(“utf-8”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter&Listener]]></title>
    <url>%2F2019%2F07%2F12%2FJava%20WEB%2FFilter%26Listener%2F</url>
    <content type="text"><![CDATA[Filter（过滤器）概念 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。作用 一般用于完成通用的操作。 如：登录验证、统一编码处理、敏感字符过滤… 快速入门 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 过滤器细节web.xml配置123456789&lt;filter&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;!-- 拦截路径 --&gt;&lt;url-pattern&gt;/-&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码过滤器生命周期方法 init 在服务器启动后，会创建Filter对象，然后调用init方法。 只执行一次。 用于加载资源。 doFilter 每一次请求被拦截资源时，会执行。 执行多次。 destroy 在服务器关闭后，Filter对象被销毁。 如果服务器是正常关闭，则会执行destroy方法。 只执行一次。 用于释放资源。过滤器配置详解拦截路径配置 具体资源路径 /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录 /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截 *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源 /* 访问所有资源时，过滤器都会被执行拦截方式配置 资源被访问的方式 注解配置 设置dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源。 FORWARD：转发访问资源 。 ERROR：错误跳转资源。 ASYNC：异步访问资源。 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置：&lt;filter-mapping&gt;谁定义在上边，谁先执行 Listener（监听器）概念 web的三大组件之一事件监听机制 事件：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码运用 监听ServletContext对象的创建和销毁 ServletContextListener 方法： ServletContext对象被销毁之前会调用该方法 void contextDestroyed(ServletContextEvent sce) ServletContext对象创建后会调用该方法 void contextInitialized(ServletContextEvent sce) 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置1234web.xml&lt;listener&gt;&lt;listener-class&gt;listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解 @WebListener]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F07%2F12%2FJava%20WEB%2Fservlet%2F</url>
    <content type="text"><![CDATA[概念 server applet：运行在服务器端的小程序 为了更好的理解servlet，我们先从B/S模式来示例 用户输入账号密码，请求登录 我们需要判断 用户A输入的账号和密码是否正确。 此处需要运用 Java逻辑来判断。 也就是，我们需要通过Java代码来确定。 具体就是，通过Java类来实现。 创建 Java类，判断账号密码 但是，并非所有的Java类都可以在服务器端运行，想要在服务器端运行就必须依赖于服务器端。 换句话说，想要在服务器端运行就要遵循服务器端的”规则“。 而具体来说，在Java中的规则，即是接口。 Servlet就是一个接口 Servlet接口中定义了能被浏览器访问到的，且能被tomcat服务器识别到的Java类的规则。 自定义一个类，实现Servlet接口，复写Servlet接口方法。 快速入门 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 配置web.xml文件，设置虚拟路径 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo 文字输出在服务器端 刷新一次页面，输出一次文字 java文件 123456789101112131415161718192021public class A_ServletDemo implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123;&#125; @Override public ServletConfig getServletConfig() &#123;return null;&#125; /* 提供服务的方法 */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("Hello Servlet!!!"); &#125; @Override public String getServletInfo() &#123;return null;&#125; @Override public void destroy() &#123;&#125; &#125; 在web/WEB-INF目录下，配置web.xml 123456789101112131415&lt;!--配置Servlet --&gt; &lt;!-- name --&gt; &lt;!-- 全类名 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet.A_ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--配置Servlet映射--&gt; &lt;!-- name --&gt; &lt;!-- 虚拟路径 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 执行原理客户端对服务器发出请求 用户通过浏览器对服务器发出请求（ *http: //localhost:8080/web/demo * ） Tomcat服务器接受请求，并开始解析URL路径 web.xml文件 首先，Tomcat服务器通过虚拟路径找到相对应的&lt;url-pattern&gt;标签。 其次，Tomcat服务器通过&lt;url-pattern&gt;标签，获取&lt;servlet-name&gt;标签，以及&lt;servlet-class&gt;标签。 最后，Tomcat服务器通过&lt;servlet-class&gt;标签，获取到Java文件的全类名。 Tomcat服务器将java文件加载进内存（classObj = Class.forName(全类名); ） Tomcat服务器创建Servlet对象（ classObj.instance(); ） Tomcat服务器创建request对象和response对象。 request对象中封装 请求消息数据 response对象中封装 响应消息数据 Tomcat服务器调用service方法，并传入request对象和response对象。 我们通过request对象获取请求消息数据 并通过response对象设置响应消息数据 Tomcat服务器在给浏览器做出响应之前，会从response对象中拿出设置好的响应消息数据。 不同的请求方式GET方式 如果我们要通过GET方式来对Tomcat服务器发送请求，那么我们可以直接访问Tomcat服务器中的GET实现类。 比如，我创建了一个HTTPServlet实现类，但是里面只重写了doGET方法。此时可打开Tomcat服务器，直接通过浏览器访问GET实现类，继而完成在Tomcat服务器中的操作。POST方式 如果我们要通过POST方式来对Tomcat客户端发送请求，那么我们就不可以直接访问Tomcat客户端中的POST实现类。 比如，创建一个HTTPServlet实现类，但是里面只重写了doPOST方法，此时打开Tomcat客户端，但是无法直接通过浏览器访问POST实现类。 不过，可以通过使用POST方法传递的表单来实现。定义一个这样的POST表单，打开Tomcat客户端，访问POST表单，继而完成在Tomcat服务器中的操作。 抽象方法 service 提供服务的方法 只要servlet服务器被访问，service方法就会执行。 *init 初始化的方法 * 无论servlet服务器被访问多少次，init方法只会执行一次。 *destroy 销毁的方法 * 当servlet服务器被正常关闭时，destroy方法会执行一次。 *getServletConfig 获取配置对象的方法 * *getServletInfo 获取servlet信息的方法 * java文件 123456789101112131415161718192021222324252627282930313233/* 初始化方法 */ // 只会执行一次 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println("===init()执行了"); &#125; /* 获取配置对象方法 */ //ServletConfig：配置对象 @Override public ServletConfig getServletConfig() &#123; return null; &#125; /* 提供服务的方法 */ // servlet被访问一次，就执行一次 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("===service()执行了"); &#125; /* 获取servlet信息方法*/ @Override public String getServletInfo() &#123; return null; &#125; /* 销毁方法 */ // servlet正常关闭时，执行一次。 @Override public void destroy() &#123; System.out.println("===destroy&#123;&#125;执行了"); &#125; 生命周期被创建 servlet被创建时会执行init方法，且只执行一次。 修改配置 默认情况下，在servlet服务器第一次被访问时，Servlet被创建。 web.xml文件中，可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 第一次被访问时 创建&lt;load-on-startup&gt;标签，值为负数 在服务器启动时 创建&lt;load-on-startup&gt;标签，值为0或正整数 安全问题 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 所以多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。 提供服务 每次访问Servlet服务器时，Service方法都会被调用一次。 被销毁 Servlet服务器被销毁时执行一次。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 注解 上述情况下，我们发现一个问题，即每次新建文件都需要在web.xml文件中添加虚拟路径。 为了解决这个问题，官方在Servlet3.0版本支持了注解配置，从而代替web.xml文件了。 在web.xml文件，除了需要指定虚拟目录以外，还需要指定文件目录。 而对于注解来说，@WebServlet已经定义在文件中了，所以只需要指定虚拟目录即可。 步骤 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = “/demo3”) *@WebServlet(“/demo3”) * 此处填写的源代码应是”value=’’demo3” “， 如果注解后只写一个属性的话，value可以不写。 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo3 文字输出在服务器端 刷新一次页面，输出一次文字 体系结构 Servlet 接口 GenericServlet 抽象类 （继承） HttpServlet 抽象类（继承） GenericServlet 抽象类 GenericServlet抽象类 将Servlet接口中其他的抽象方法默认空实现，只将service()方法作为抽象方法。 上述情况下，我们仍可以发现一个问题，即创建的实现了servlet接口的Java类中，有许多我们不需要重写的抽象方法。但是大部分情况下我只用需要实现service方法，那我们为什么不能不实现其他方法呢？ 为了解决这个问题，我们可以通过GenericServlet抽象类来完成。 Java类不再是 实现servlet接口 Java类如今是 继承GenericServelet抽象类 HttpServlet 抽象类 HttpServlet抽象类在其父类GenericServlet 抽象类的功能上更进一步。为了可以获取正确的数据，HttpServlet抽象类对请求的方法（get、post）自动进行了判断。 Java类继承 HttpServlet抽象类 复写doGet/doPost方法 相关配置 urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： 目录结构：/xxx 多层目录结构：/xxx/xxx 文件名：*.do]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F07%2F11%2FJava%20WEB%2FHTTP%2F</url>
    <content type="text"><![CDATA[概念 HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 传输协议 传输协议定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型 ：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本 HTTP 1.0：每一次请求响应都会建立新的连接，浪费时间，消耗资源。 HTTP 1.1：复用连接。 请求消息数据格式 数据格式 请求消息数据格式 响应消息数据格式 请求消息数据格式请求方式 HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求行 Request method ：请求方式 Request URI ：请求端的URI地址 Http version ：HTTP协议的版本 GET方式 POST方式2 请求头 Accept：指浏览器或其他客户可以接爱的MIME文件格式。 Accept-Encoding：指出浏览器可以接受的编码方式。 Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。 connection：用来告诉服务器是否可以维持固定的HTTP连接。 Cookie：浏览器用这个属性向服务器发送Cookie。 Host：对应网址URL中的Web名称和端口号。 User-Agent：客户浏览器名称。 兼容性问题 Referer：表明产生请求的网页URL。 防盗链 统计工作 Content-Type：用来表名request的内容类型。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1。 GET方式 POST方式 请求空行 空行，用于分割请求头和请求体。请求体 封装POST请求消息的请求参数的 GET方式 POST方式 响应消息数据格式响应行 协议/版本 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1xx 指示信息：表示请求已接收，但没有完成，需要继续处理。 2xx 成功：表示请求已被成功接收、理解、接受。 3xx 重定向：要完成请求必须进行更进一步的操作。 302：重定向 304：访问缓存 4xx 客户端错误：请求有语法错误或请求无法实现。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx 服务器端错误：服务器未能实现合法的请求。 响应头 Content-Type：响应体数据格式以及编码格式 text/html;charset=UTF-8 Content-disposition：打开响应体数据的格式 in-line：在当前页面内打开（默认值） attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行响应体 传输的数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2019%2F07%2F11%2FJava%20WEB%2Ftomcat%2F</url>
    <content type="text"><![CDATA[web相关概念回顾软件架构 C/S 客户端/服务器端 B/S 浏览器/服务器端 资源分类 静态资源 所有用户访问后，得到的结果都是一样的。静态资源可以直接被浏览器解析。 如： html，css，JavaScript 动态资源 每个用户访问相同资源后，得到的结果可能不一样。动态资源被访问后，需要先转换为静态资源，再返回给浏览器。 如：servlet/jsp，php，asp 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议 TCP：安全协议，三次握手； 速度稍慢。 UDP：不安全协议；速度快。 web服务器软件 服务器 安装了服务器软件的计算机。 服务器软件 接收用户的请求，处理请求，做出响应。 web服务器软件 在web服务器软件中，部署web项目，让用户通过浏览器来访问项目。 同时，接收用户的请求，处理请求，做出响应。 动态资源依赖于web服务器软件，只能运行在web服务器中。 常见的java相关的web服务器软件 webLogic oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 webSphere IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 Tomcat Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat安装软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格。 卸载 删除目录就行了。 启动： bin/startup.bat 访问 http://localhost:8080 （本地） http://IP地址:8080 （外部） Tomcat目录结构 bin 可执行文件 conf 配置文件 lib 依赖jar包 logs 日志文件 temp 临时文件 webapps web项目 work 运行时的数据 启动软件问题一： 黑窗口一闪而过 解决办法：配置环境变量 假设Tomcat安装路径为：D:\Tomcat\apache-tomcat-8.0.47 打开 [控制面板]–[系统和安全]–[系统]–[计算机名、域和工作组设置]–[更改设置] 在打开的窗口 [系统属性]中，[高级]–[环境变量]–[用户变量]–[新建] 新建变量名：CATALINA_BASE，变量值：D:\Tomcat\apache-tomcat-8.0.47 新建变量名：CATALINA_HOME，变量值：D:\Tomcat\apache-tomcat-8.0.47 打开变量Path，添加变量值：%CATALINA_HOME%\lib 打开变量Path，添加变量值： %CATALINA_HOME%\bin 检验环境变量是否配置成功 第一步，打开命令提示符，输入startup，按回车键，启动tomcat 第二步，打开浏览器，输入http://localhost:8080 ，启动tomcat 问题一：启动报错 解决办法一：结束程序进程 打开命令提示符，输入netstat -ano，获得PID值（进程ID） 打开任务管理器，查看进程，选项显示PID，按照PID值结束程序进程 解决办法二：修改端口号 conf 目录下，找到 server.xml 修改其中的端口号，避免端口冲突。（慎用！） 关于端口号 &lt;Connector port=”8080” protocol=”HTTP/1.1”connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 一般会我们会将tomcat的默认端口号修改为80，端口号80是http协议的默认端口号。这样我们在访问时，就不用输入端口号了。 关闭 正常关闭： 在bin目录下，运行shutdown.bat 在启动的窗口中，按 ctrl+c 强制关闭： 直接关闭启动的窗口 部署web项目 放置项目目录下 直接将项目放置到webapps目录下 项目的访问路径 （虚拟目录）：localhost:8080/web/index.html 简化部署 将项目打成一个war包，再将war包放置到webapps目录下。 放置war包，自动解压缩出文件；删除war包，文件自动删除。 配置文件 在conf 目录下，找到 server.xml 在标签体中配置 &lt;Context docBase=”D:\web” path=”/w” /&gt; docBase:项目存放的路径 path：虚拟目录 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html 创建文件 在conf\Catalina\localhost目录下，创建任意名称的xml文件。 在xml文件中配置 w.xml &lt;Context docBase=”D:\hello” /&gt; 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html web项目目录结构 java动态项目的目录结构 项目的根目录 WEB-INF目录 web.xml web项目的核心配置文件 classes目录 放置字节码文件的目录 lib目录 放置依赖的jar包]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2019%2F07%2F10%2FJava%20WEB%2FXML%2F</url>
    <content type="text"><![CDATA[概念 XML（ Extensible Markup Language），即 可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 可扩展语言的精华在于其”Extensible”，即 在XML中的标签都是自定义的。 功能存储数据 配置文件 在网络中传输 xml与html的区别 HTML 标签预定义； 语法松散； 功能为展示数据。 XML 标签自定义； 语法严格； 功能为存储数据。 语法基本语法 后缀名 .xml 文档声明 必须在第一行 根标签 有且仅有一个 属性值 必须使用引号(单双都可)引起来 标签 必须正确关闭 标签名称 区分大小写 快速入门1234567891011121314&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分文档声明格式&lt;?xml 属性列表 ?&gt; 属性列表 version：版本号（必须的属性） 一般值：1.0 encoding：编码方式。 告知解析引擎当前文档使用的字符集 默认值：ISO-8859-1 （不支持中文） standalone：是否独立 yes：不依赖其他文件 no：依赖其他文件 指令（结合css） &lt;?xml-stylesheet type=”text/css” href=”a.css” ?&gt; 标签（自定义） 定义规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性属性值唯一 文本 CDATA区（原样展示数据） 格式： &lt;![CDATA[ 数据 ]]&gt; 约束 约束规定了ml文档的书写规则。 DTD约束技术DTD是一种简单的约束技术。我们可以通过dtd文件控制标签和标签的属性，但是对于标签内容的控制我们无能为力。而schema约束技术恰巧弥补了这一缺陷，关于schema约束技术在下一节会详细展开。 外部dtd引入 将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt; 外部dtd：dtd文件 1234567891011121314&lt;!-- ELEMENT元素（定义标签）--&gt; &lt;!-- students标签 （包含student标签 0个或者多个） --&gt;&lt;!ELEMENT students (student*) &gt; &lt;!-- student标签 （包含name标，age标签，sex标签 只能有一个） --&gt;&lt;!ELEMENT student (name,age,sex)&gt; &lt;!-- name标签 （字符串）--&gt;&lt;!ELEMENT name (#PCDATA)&gt; &lt;!-- age标签 （字符串）--&gt;&lt;!ELEMENT age (#PCDATA)&gt; &lt;!-- sex标签 （字符串）--&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!-- ATTLIST元素（定义属性）--&gt; &lt;!-- student标签 number属性 属性类型为ID #并且必需出现 --&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 外部dtd：xml文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 内部引入DTD文档 --&gt;&lt;!DOCTYPE students SYSTEM "student.dtd"&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 内部dtd 引入 将约束规则定义在xml文件中 内部dtd：xml文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 引入DTD文档 --&gt;&lt;!DOCTYPE students [ &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; Schema约束技术Schema是一种复杂的约束技术。它本身是一个xml文档，但文件后缀名以.xsd结尾。 引入实例 schema文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns="http://www.itcast.cn/xml" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itcast.cn/xml" elementFormDefault="qualified"&gt; &lt;!-- element元素 &#123;自定义标签(1):students 自定义类型(1):studentsType&#125; --&gt; &lt;xsd:element name="students" type="studentsType"/&gt; &lt;!-- complexType元素 &#123;自定义类型(1):studentsType&#125; --&gt; &lt;!-- sequence元素（按顺序） --&gt; &lt;!-- element元素 &#123;自定义标签(1-1):student 自定义类型(1-1):studentType 最少出现:0次 最多出现:无限制&#125; --&gt; &lt;xsd:complexType name="studentsType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="student" type="studentType" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;!-- complexType元素 &#123;自定义类型(1-1):studentType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-1):name 基本类型:xsd:string&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-2):age 自定义类型(1-1-2):ageType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-3):sex 自定义类型(1-1-3):sexType&#125; --&gt; &lt;!-- attribute元素 &#123;定义属性:number 自定义类型(1-1-4):numberType #必需&#125; --&gt; &lt;xsd:complexType name="studentType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="name" type="xsd:string"/&gt; &lt;xsd:element name="age" type="ageType" /&gt; &lt;xsd:element name="sex" type="sexType" /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name="number" type="numberType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-2)：sexType &#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 可选值：male --&gt; &lt;!-- 可选值：female --&gt; &lt;xsd:simpleType name="sexType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:enumeration value="male"/&gt; &lt;xsd:enumeration value="female"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-3)：ageType&#125; --&gt; &lt;!-- 基本类型：integer --&gt; &lt;!-- 最小值：0 --&gt; &lt;!-- 最大值：256 --&gt; &lt;xsd:simpleType name="ageType"&gt; &lt;xsd:restriction base="xsd:integer"&gt; &lt;xsd:minInclusive value="0"/&gt; &lt;xsd:maxInclusive value="256"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-4):numberType&#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 格式化：Cat_后跟四个数字 --&gt; &lt;xsd:simpleType name="numberType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:pattern value="Cat_\d&#123;4&#125;"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; xml文件 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. xsi:schemaLocation=”http://www.itcast.cn/xml student.xsd” 为每一个xsd约束声明一个前缀,作为标识 xmlns:xxx=”http://www.itcast.cn/xml&quot; 不写为默认前缀 xmlns=”http://www.itcast.cn/xml&quot; 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;students xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.itcast.cn/xml student.xsd" xmlns="http://www.itcast.cn/xml" &gt; &lt;student number="Cat_0001"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 解析操作xml文档，将文档中的数据读取到内存中。 操作xml文档 解析(读取)：将文档中的数据读取到内存中。 写入：将内存中的数据保存到xml文档中。 解析xml文档DOM DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树。 优点：操作方便，能对文档进行CRUD的所有操作。 缺点：因为形成了DOM树，所以DOM比较占内存，不适用于内存较小的设备。 SAX SAX：基于事件驱动，逐行读取，读取一行释放一行。 优点：不占内存，适用于内存较小的设备。 缺点：只能读取，不能增删改。 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想。但是性能低，基本没有人使用。 DOM4J：一款非常优秀的解析器。 PULL：Android操作系统内置的解析器，支持sax思想。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoupjsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 步骤 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 快速入门1234567891011121314151617181920// 1.导入jar包// 2.根据xml文件，获取Document对象 // * 获取 DTD约束的student.xml文件路径 // * 解析 xml文档，获取DOM树（Document对象）,抛出异常 /* 通过本类的字节码文件，找到类加载器；再通过类加载器，找到文件路径；最后得到文件路径的字符串形式 */ String path = A_Jsoup.class.getClassLoader().getResource("DTD/student.xml").getPath(); Document ducument = Jsoup.parse(new File(path),"utf-8");// 3.获取Element元素对象 name Elements names = ducument.getElementsByTag("name");// 输出所有name元素 System.out.println(names);// 输出第一个name元素 Element name1 = names.get(0); String nameStr1 = name1.text(); System.out.println(nameStr1); 对象Jsoup工具类 获取Document对象 parse(File in, String charsetName)：解析xml、html文件 parse(String html)：解析xml、html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html、xml的文档对象 Java文件：解析html文件 123456789101112131415161718192021 /* 解析xml、html文件 */ String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/test.html").getPath(); Document document = Jsoup.parse(new File(path),"utf-8"); System.out.println(document);/* 解析xml、html字符串 */ Document document2 = Jsoup.parse("&lt;!DOCTYPE html&gt;\n" + "&lt;html lang=\"en\"&gt;\n" + "&lt;head&gt;\n" + " &lt;meta charset=\"UTF-8\"&gt;\n" + " &lt;title&gt;Title&lt;/title&gt;\n" + "&lt;/head&gt;\n" + "&lt;body&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"); System.out.println(document2);/* 通过网络路径获取指定的html、xml的文档对象 */ URL url = new URL("https://www.baidu.com/"); Document document3 = Jsoup.parse( url, 3000); System.out.println(document3); Document文档对象 获取Element对象（任意） getElementById(String id)：根据id属性值，获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称，获取元素对象集合 getElementsByAttribute(String key)：根据属性名称，获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值，获取元素对象集合 html文件 1234567&lt;body&gt; &lt;div id="div1"&gt; &lt;div class="div2" align="left"&gt;&lt;/div&gt; &lt;div class="div2" align="center"&gt;&lt;/div&gt; &lt;div class="div2" align="right"&gt;&lt;/div&gt; &lt;/div&gt; Java文件：解析html文件 123456789101112131415161718String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/C_test.html").getPath();Document document = Jsoup.parse(new File(path),"utf-8");/*根据id属性值，获取唯一的element对象*/ Element id = document.getElementById("div1"); System.out.println(id);/*根据标签名称，获取元素对象集合*/ Elements tag = document.getElementsByTag("div"); System.out.println(tag);/*根据属性名称，获取元素对象集合*/ Elements attribute = document.getElementsByAttribute("align"); System.out.println(attribute);/*根据对应的属性名和属性值，获取元素对象集合*/ Elements attributeValue = document.getElementsByAttributeValue("align", "center"); System.out.println(attributeValue); Elements集合Elements是元素Element对象的集合，相当于一个 ArrayList&lt;Element&gt;。 Element：元素对象 获取Element对象（当前元素的子标签） getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) html文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="attributeValue"&gt; &lt;span&gt;文本内容&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; java文件 1234567891011121314151617181920//获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/D_test.html").getPath();//获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");//获取 Elements对象 Elements tags = document.getElementsByTag("div");//获取 Element对象 Element div = tags.get(0);/* 根据属性名称获取属性值 */ String att = div.attr("id"); System.out.println(att);/* 根据属性名称获取属性值 */ String text = div.text(); System.out.println(text);/* 获取标签体的所有内容(包括字标签的字符串内容) */ String html = div.html(); System.out.println(html); Node：节点对象 Node是Document和Element的父类。 查询快捷查询方式： selector：选择器 XPath：XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。selector 方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 html文件 123456 &lt;div&gt; &lt;div id="div"&gt; &lt;div class="div"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; java文件 1234567891011121314151617181920212223242526272829303132333435// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");/* 选择所有div标签 */ Elements selector1 = document.select("div"); for (Element element : selector1) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的标签*/ Elements selector3 = document.select("#div"); for (Element element : selector3) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有class属性值为div的标签*/ Elements selector2 = document.select(".div"); for (Element element : selector2) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ Elements elements = document.select("div[id='div'] &gt; div"); for (Element element : elements) &#123; System.out.println(element); System.out.println(); &#125; XPath 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 注意：在填写xpath时，引号内不允许有空格。 java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");// 获取 JXDocument对象 JXDocument jxDocument = new JXDocument(document);/* 选择所有div标签 */ List&lt;JXNode&gt; jxNodes = jxDocument.selN("//div"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的div标签 */ List&lt;JXNode&gt; jxNodes2 = jxDocument.selN("//div[@id='div']"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择id属性值的所有值*/ List&lt;JXNode&gt; jxNodes3 = jxDocument.selN("//@id"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的div标签 */ List&lt;JXNode&gt; jxNodes4 = jxDocument.selN("//div/div"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的所有带class属性的div标签 */ List&lt;JXNode&gt; jxNodes5 = jxDocument.selN("//div/div[@class]"); for (JXNode jxNode : jxNodes5) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ List&lt;JXNode&gt; jxNodes6 = jxDocument.selN("//div[@id=div]/div"); for (JXNode jxNode : jxNodes6) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>DTD</tag>
        <tag>Schame</tag>
        <tag>Jsoup</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2F2019%2F07%2F09%2FJava%20WEB%2FBootStrap%2F</url>
    <content type="text"><![CDATA[概念Bootstrap是一个前端开发的框架，来自 Twitter，是目前很受欢迎的前端框架。它基于 HTML、CSS、JavaScript ，具有简洁、直观、强悍的优点，使得 Web 开发更加快捷。 优势 响应式设计，能够自适应于台式机、平板电脑、手机，确保了适当的绘制和触屏缩放，同时可以设置禁止缩放功能，使网站看上去感觉更像原生应用。 包含了功能强大的内置组件（css样式和js插件），我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 快速入门 下载Bootstrap框架Bootstrap官网下载 将Bootstrap框架引入项目直接将解压后的文件复制进项目即可 HTML文件模板任何bootstrap页面都是基于这样的一个模板 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt;&lt;!-- 下面的3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;&lt;!-- Bootstrap --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 响应式布局 响应式布局就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。 响应式布局的实现，依赖于栅格系统。 栅格系统栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 栅格系统，简单来说，就是将页面一行平均分成12个格子，根据不同的终端对元素设定不同的格子。 在PC端每张图片设定占4个格子，那么PC端页面每一行显示3张图片 在平板电脑每张图片设定占6个格子，那么平板电脑端页面每一行只显示2张图片。 在手机端每张图片设定占12个格子，那么手机端页面每一行则只显示1张图片。 步骤 定义容器 container（固定宽度） container-fluid（100% 宽度） 定义行 row 定义元素 col-设备代号-格子数目 设备代号 xs 超小屏幕 手机 (&lt;768px) sm 小屏幕 平板 (≥768px) md 中等屏幕 桌面显示器 (≥992px) lg 大屏幕 大桌面显示器 (≥1200px) 注意 如果设定的格子数目超过12，超出部分自动换行。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 栅格类属性可以向上兼容。 只设定手机端图片占4个格子，那么手机端、平板端和PC端页面每行都显示3张图片。 案例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 定义了div的边框 --&gt; &lt;style&gt; .inner&#123; border: 1px solid #1c7430 ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义容器 --&gt; &lt;div class="container-fluid"&gt; &lt;!-- 定义行 --&gt; &lt;div class="row"&gt; &lt;!-- 定义元素 --&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;CSS样式 按钮 预定样式 12345678910111213&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt; 尺寸 12345678910111213141516&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-lg"&gt;（大按钮）Large button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary"&gt;（默认尺寸）Default button&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-sm"&gt;（小按钮）Small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt; 图片 图片在任意尺寸都占100% 1&lt;img src="..." class="img-responsive" alt="Responsive image"&gt; 图片形状 ​ 123&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt; 表格 表格实例 123&lt;table class="table"&gt; ...&lt;/table&gt; 条纹状表格 123&lt;table class="table table-striped"&gt; ...&lt;/table&gt; 带边框的表格 123&lt;table class="table table-bordered"&gt; ...&lt;/table&gt; 鼠标悬停 123&lt;table class="table table-hover"&gt; ...&lt;/table&gt; 响应式表格12345&lt;div class="table-responsive"&gt;&lt;table class="table"&gt; ...&lt;/table&gt;&lt;/div&gt; 表单 表单实例 123456789101112131415161718192021&lt;form&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt;&lt;/div&gt;&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt;&lt;/div&gt;&lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 水平排列的表单 12345678910111213141516171819202122232425262728 &lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 组件导航条 导航条实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 反色的导航条 123&lt;nav class=&quot;navbar navbar-inverse&quot;&gt; ...&lt;/nav&gt; 分页条 分页条实例 12345678910111213141516171819&lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 插件 Carousel（轮播图） 轮播图实例1234567891011121314151617181920212223242526272829303132333435&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TyparoMarkdown]]></title>
    <url>%2F2019%2F07%2F09%2FTyparoMarkdown%2F</url>
    <content type="text"><![CDATA[*语法手册* 功能 markdown语法 快捷键 转义字符 \ 分割线 -– 标题 # ## ### ctrl + 1~6 斜体 * ctrl + I 粗体 ** ctrl + B 下划线 ctrl + U 删除线 ~~ alt + shift +5 引用 &lt; ctrl + shift + Q 超链接 \ ctrl + K 代码片段 · ctrl + shift + ` 代码块 ··· ctrl + shift + K 图片 [ ]( “”) ctrl + shift + I 有序列表 1. 2. 3. ctrl + shift + [ 无序列表 - + * ctrl + shift + ] 表格 ctrl + T 清除样式 ctrl + \ 源代码模式 ctrl + / 目录 [toc] 脚注 [^ ]: 第1章 标题123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 第2章 字体12345*斜体* **粗体** ***粗斜体*** &lt;u&gt;下划线&lt;/u&gt; ~~删除线~~ 斜体粗体粗斜体下划线 删除线 第3章 引用123&gt;引用 &gt;&gt;引用&gt;&gt;&gt;引用 引用 引用 引用 第4章 超链接1[百度](http://baidu.com &quot;title&quot;) 百度 ​ * 默认在本页面打开 第5章 引用链接12345[百度][id][id]: http://baidu.com &quot;title&quot;[百度][][百度]: http://baidu.com &quot;title&quot; [百度][id][id]: http://baidu.com “title” 百度 第6章 分割线1234-------******** 第7章 代码12代码片段 代码块 代码片段 12&gt; 代码块&gt; 第8章 图片1![panda](http://pvpv3a462.bkt.clouddn.com/StudyNotes/BootStrap/pic01.jpg &apos;&apos;panda&apos;&apos;) 第9章 列表123456789101. 有序 2. 有序3. 有序- 无序- 无序+ 无序+ 无序* 无序* 无序 有序 有序 有序 无序 无序 无序 无序 无序 无序 第10章 任务列表123[] 洗衣服[] 吃饭[] 睡觉 洗衣服 吃饭 睡觉 第11章 表格1234567 姓名 | 技能 | 排行 -- | :--: | --: 刘备 | 哭 | 大哥 关羽 | 打 | 二哥 张飞 | 骂 | 三弟* 左对齐 -- 居中 :--: 右对齐 --: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 第12章 脚注123[^1]:a note at the bottom of the page in a book.This is a footnote[^1] [^1]:a note at the bottom of the page in a book.This is a footnote.[^1] 第13章 表情123:cat::dog::rat: :cat::dog::rat: 第148章 上标下标12H~2~OX^2^ H2OX^2^ 附录Typora官方文档* Markdown链接默认本窗口打开]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
