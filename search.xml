<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义MyBatis]]></title>
    <url>%2F2019%2F08%2F04%2FMyBatis_Custom%2F</url>
    <content type="text"><![CDATA[简介 我们知道创建Maven项目后，在项目中的pom.xml配置文件中引入MyBatis依赖之后，我们就可以使用MyBatis相关的类和接口，和相应的功能。 但为了对MyBatis的体系结构和功能有更加深刻的理解和全面的认识，本文Maven项目中的pom.xml配置文件，将不再引入MyBatis依赖，转而通过自定义编写MyBatis相关的类和接口来实现同样的功能。 思维导图 代码Maven项目配置文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.water&lt;/groupId&gt; &lt;artifactId&gt;mybatis_custom&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- 此处没有MyBatis的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MyBatis主配置文件123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件。 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt;&lt;/configuration&gt; 持久层接口的映射配置文件1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; User实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.water.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; UserDao持久层接口123456789101112131415161718package cn.water.dao;import cn.water.domain.User;import java.util.List;/** * 用户的持久层接口 */public interface UserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findAll();&#125; Mapper实体类12345678910111213141516171819202122232425262728293031323334package cn.water.mybatis.cfg;/** * 封装SQL语句和结果集类型的全类名 */public class Mapper &#123; private String queryString; private String resultType; @Override public String toString() &#123; return "Mapper&#123;" + "queryString='" + queryString + '\'' + ", resultType='" + resultType + '\'' + '&#125;'; &#125; public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; Configuration实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.water.mybatis.cfg;import java.util.HashMap;import java.util.Map;/** * 封装数据库驱动和数据库连接对象的三个参数 */public class Configuration &#123; private String driver; private String url; private String username; private String password; private Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); @Override public String toString() &#123; return "Configuration&#123;" + "driver='" + driver + '\'' + ", url='" + url + '\'' + ", username='" + username + '\'' + ", password='" + password + '\'' + ", mappers=" + mappers + '&#125;'; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123;// this.mappers = mappers; 覆盖：Map集合中永远只会有一个键值对 this.mappers.putAll(mappers); // 追加 &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; MyBatisTest测试类12 Resources类12 SqlSessionFactoryBuilder工厂实现类123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.test;import cn.water.dao.UserDao;import cn.water.domain.User;import cn.water.mybatis.io.Resources;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;import cn.water.mybatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserDao dao = sqlSession.getMapper(UserDao.class); /* 使用代理对象 执行方法 */ List&lt;User&gt; list = dao.findAll(); /* 遍历 */ for (User user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; XMLConfigBuilder工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package cn.water.mybatis.Utils;//import com.itheima.mybatis.annotations.Select;import cn.water.Anno.Select;import cn.water.mybatis.io.Resources;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.cfg.Mapper;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author 黑马程序员 * @Company http://www.ithiema.com * 用于解析配置文件 */public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术： * dom4j+xpath */ public static Configuration loadConfiguration(InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是XML"); //表示有resource属性，用的是XML //取出属性的值 String mapperPath = attribute.getValue();//获取属性的值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据daoClassPath获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 String namespace = root.attributeValue("namespace");//是组成map中key的部分 //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历select节点集合 for(Element selectElement : selectElements)&#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue("id"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace+"."+id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给map赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; SqlSessionFactory工厂接口12345678package cn.water.mybatis.session;/*** * 工厂接口 */public interface SqlSessionFactory &#123; SqlSession openSession();&#125; DefaultSqlSessionFactory工厂接口实现类12345678910111213141516171819202122232425262728293031323334package cn.water.mybatis.defaults;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;/** * SqlSessionFactory工厂接口的实现类 */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; /** * 私有成员变量 */ private Configuration configuration; /** * 带参构造 * @param configuration */ public DefaultSqlSessionFactory(Configuration configuration) &#123; this.configuration = configuration; &#125; /** * 创建操作数据库对象 * @return */ public SqlSession openSession() &#123; return new DefaultSqlSession(configuration); &#125; &#125; SqlSession产品接口123456789101112131415161718192021package cn.water.mybatis.session;/** * 产品接口 */public interface SqlSession &#123; /** * 根据参数，创建代理对象 * @param daoInterface * @param &lt;T&gt; * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface); /* &lt;T&gt; T 返回值为泛型时，需要先声明再使用。 */ /** * 释放资源 */ void close();&#125; DefaultSqlSession产品接口实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.water.mybatis.defaults;import cn.water.mybatis.Utils.DataSourceUtil;import cn.water.mybatis.cfg.Configuration;import cn.water.mybatis.proxy.MapperProxy;import cn.water.mybatis.session.SqlSession;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.SQLException;/** * SqlSession产品接口的实现类 */public class DefaultSqlSession implements SqlSession &#123; /** * 私有成员变量 */ private Configuration configuration; private Connection connection; /** * 带参构造 * @param configuration */ public DefaultSqlSession(Configuration configuration) &#123; this.configuration = configuration; connection = DataSourceUtil.getConnection(configuration); &#125; /** * 创建代理对象 * @param daoInterface * @param &lt;T&gt; * @return */ public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterface) &#123; return (T) Proxy.newProxyInstance( daoInterface.getClassLoader(), // 持久层接口的类加载器 new Class[]&#123;daoInterface&#125;, // 持久层接口 new MapperProxy(configuration.getMappers(), connection)); &#125; /** * 释放资源 */ public void close() &#123; if (connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; DataSourceUtils工具类12345678910111213141516171819202122232425262728package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Configuration;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/*** * 创建数据库连接池对象 */public class DataSourceUtil &#123; /*** * 创建数据库连接对象 * @param configuration * @return */ public static Connection getConnection(Configuration configuration) &#123; try &#123; Class.forName(configuration.getDriver()); return DriverManager.getConnection(configuration.getUrl(),configuration.getUsername(),configuration.getUsername()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; MapperProxy代理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.water.mybatis.proxy;import cn.water.mybatis.Utils.Executor;import cn.water.mybatis.cfg.Mapper;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Map;public class MapperProxy implements InvocationHandler &#123; /** * 私有成员变量 * key：全类名+方法名 * value：SQL语句+结果集数据类型的全类名 */ private Map&lt;String, Mapper&gt; mappers; private Connection connection; /** * 带参构造 * @param mappers */ public MapperProxy(Map&lt;String, Mapper&gt; mappers, Connection connection) &#123; this.mappers = mappers; this.connection = connection; &#125; /** * 代码增强 * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1.获取方法名 String methodName = method.getName(); // 2.获取方法所在类的名称 String className = method.getDeclaringClass().getName(); // 3.组合key String key = className + "." + methodName; // 4.获取mappers中的Mapper对象 Mapper mapper = mappers.get(key); // 5.判断是否有Mapper if (mapper==null)&#123; throw new IllegalArgumentException("传入的参数有误！"); &#125; // 6.调用工具类执行查询所有 return new Executor().selectList(mapper,connection); &#125;&#125; Executor工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.water.mybatis.Utils;import cn.water.mybatis.cfg.Mapper;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;/** * @author 黑马程序员 * @Company http://www.ithiema.com * 负责执行SQL语句，并且封装结果集 */public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125; &#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注解 使用注解的方式我们编写的MyBatis相关的类和接口不用改变，除了修改MyBatis主配置文件和删除映射配置文件之外，只需按照注解的方式来编写User实体类和UserDao持久层接口即可，另外我们要自定义编写Select注解。 代码MyBatis主配置文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件。 --&gt; &lt;!-- 注解：使用class属性指定被注解的持久层接口的全类名 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;mapper class="cn.water.dao.UserAnnoDao"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; User实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.water.domain;import java.io.Serializable;import java.util.Date;public class UserAnno implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; UserDao持久层接口1234567891011121314151617181920package cn.water.dao;import cn.water.Anno.Select;import cn.water.domain.UserAnno;import java.util.List;/** * 用户的持久层接口 */public interface UserAnnoDao &#123; /** * 查询所有 * @return */ @Select("SELECT * FROM user;") List&lt;UserAnno&gt; findAll();&#125; Select注解123456789101112131415161718192021package cn.water.Anno;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 查询的注解 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; /*** * 配置SQL语句 * @return */ String value();&#125; MyBatisAnnoTest测试类123456789101112131415161718192021222324252627282930313233343536373839404142package cn.water.test;import cn.water.dao.UserAnnoDao;import cn.water.domain.UserAnno;import cn.water.mybatis.io.Resources;import cn.water.mybatis.session.SqlSession;import cn.water.mybatis.session.SqlSessionFactory;import cn.water.mybatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisAnnoTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserAnnoDao dao = sqlSession.getMapper(UserAnnoDao.class); /* 使用代理对象 执行方法 */ List&lt;UserAnno&gt; list = dao.findAll(); /* 遍历 */ for (UserAnno userAnno : list) &#123; System.out.println(userAnno); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JdbcTemplate]]></title>
    <url>%2F2019%2F08%2F02%2FJdbcTemplate%2F</url>
    <content type="text"><![CDATA[Spring JDBC Spring框架对JDBC的简单封装，它提供了一个JDBCTemplate对象，简化JDBC的开发。 快速入门 导入jar包 创建JdbcTemplate对象，传递DataSource对象 JdbcTemplate template = new JdbcTemplate(dataSource); 调用JdbcTemplate的方法，完成CRUD的操作 update() queryForMap() queryForList() query() queryForObject() 方法update update()：执行DML增、删、改语句。 1234567/* 添加数据 */// SQL语句String sql = "UPDATE account SET balance = ? ";// 调用update方法int update = jdbcTemplate.update(sql, 1000);// 输出结果System.out.println("update添加:"+update); 1234567/* 修改数据 */// SQL语句 String sql = "INSERT INTO account VALUES (?,?,?),(?,?,?) ";// 调用update方法int update = jdbcTemplate.update(sql,null,"Rat",1000,null,"Ant",1000);// 输出结果ystem.out.println("update修改:"+update); 1234567/* 删除数据 */// SQL语句String sql = "DELETE FROM account WHERE name IN (?,?) ";// 调用update方法nt update = jdbcTemplate.update(sql,"Rat","Ant");// 输出结果System.out.println("update删除:"+update); queryForMap queryForMap()：查询结果，将结果集封装为Map集合。（结果集长度只能是1） 将列名作为key，将字段作为value，将一条记录封装为一个map集合。 一个Map对应着一条记录。1234567 /* 查询一条记录，封装至Map集合 */// SQL语句String sql = "SELECT * FROM account WHERE id = ?";// 调用queryForMap方法Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 1 );// 输出结果System.out.println(map); queryForList queryForList()：查询结果，将结果集封装为List集合。 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。 一个List对应着一张表。123456789/* 查询所有记录，封装至List集合 */// SQL语句String sql = "SELECT * FROM account";// 调用queryForMap方法List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql);// 输出结果for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap);&#125; query query()：查询结果，将结果集封装为JavaBean对象。 将列名作为成员变量，将字段作为成员变量的值，将一条记录封装为一个JavaBean对象。 一个JavaBean对象对应着一条记录。 query的参数：RowMapper接口 使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装。 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 传递RowMapper匿名内部类123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*基本数据类型*/ private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 123456789101112131415161718192021222324/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递RowMapper匿名内部类，手动的一条一条的获取ResultSet结果集中的数据，然后封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql, new RowMapper&lt;Record&gt;() &#123; @Override public Record mapRow(ResultSet reSet, int i) throws SQLException &#123; int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); Record record = new Record(id, ename, job_id, mgr, join_date, salary, bonus, dept_id); return record; &#125;&#125;// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; 传递BeanPropertyRowMapper实现类 注意，JavaBean对象中的成员变量类型一定要使用引用数据类型。 因为基本数据类型不能接受NULL值，而数据库中的字段可以设置为NULL值，所以在传递时，会发生类型转换的问题。 123456789101112131415// JavaBean对象：Recordpublic class Record &#123; /*引用数据类型*/ private Integer id; private String ename; private Integer job_id; private Integer mgr; private Date join_date; private Double salary; private Double bonus; private Integer dept_id; /*省略get、set方法*/ /*省略toString方法*/&#125; 12345678910/* 查询所有记录，封装至List&lt;Record&gt;集合*/// SQL语句String sql = "SELECT * FROM emp";// 调用query方法// 传递BeanPropertyRowMapper实现类，自动获取ResultSet结果集中的数据，自动封装进JavaBean对象List&lt;Record&gt; list = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;&gt;(Record.class));// 输出结果for (Record record : list) &#123; System.out.println(record);&#125; queryForObject queryForObject：查询结果，将结果集封装为对象。 用于聚合函数（查询表的记录数、列的最大数最小数平均数）123456/* 查询总记录数 */String sql = "SELECT COUNT(id) FROM emp";// 调用queryForObject方法Integer integer = jdbcTemplate.queryForObject(sql, Integer.class);// 输出结果System.out.println(integer);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>Spring JDBC</tag>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接池]]></title>
    <url>%2F2019%2F08%2F02%2FJDBCDateSource%2F</url>
    <content type="text"><![CDATA[数据库连接池 概念 数据库连接池：其实就是一个容器，存放数据库连接的容器。 当系统初始化后，容器被创建，并且容器会申请一些连接对象。 当用户来访问数据库时，从容器中获取连接对象；用户访问完之后，会将连接对象归还给容器。 优点 节约资源 用户访问高效 接口 数据库连接池接口由Sun公司编写，具体实现类由各个数据库厂商提供。 数据库连接池接口： javax.sql.DataSource 接口方法 获取连接：getConnection() 归还连接：Connection.close()。 Connection对象是从DataSource对象中获取，此时就不再是关闭连接了，而是归还连接。 接口的实现类 C3P0：数据库连接池实现技术 Druid：数据库连接池实现技术（阿里巴巴） C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 不要忘记导入数据库驱动jar包 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 123456789101112131415161718192021222324252627282930313233&lt;!-- c3p0-config.xml文件 --&gt;&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/jdbc&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;!-- initialPoolSize：初始化申请的Connection对象数量 --&gt; &lt;!-- maxPoolSize：最大的的Connection对象数量 --&gt; &lt;!-- checkoutTimeout：超时时间 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;!-- 使用自定义的配置读取连接池对象 --&gt; &lt;named-config name="otherc3p0"&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/servlet&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345678910111213141516171819202122// 打印获取的数据库连接对象 public static void main(String[] args) throws SQLException &#123;//1.导入jar包//2.定义配置文件//3.使用默认配置，获取数据库连接池对象DataSource dataSource = new ComboPooledDataSource();//3.使用自定义配置，获取数据库连接池对象// DataSource dataSource = new ComboPooledDataSource("otherc3p0");// 最大获取连接对象为10个，但我们需要获取15个。// 那就一边获取数据库连接对象，一边归还数据库连接对象。for (int i = 0; i &lt; 15; i++) &#123; //4.获取 数据库连接对象 Connection connection = dataSource.getConnection(); System.out.print(i+" "); //5.打印 数据库连接对象 System.out.println(connection); if (i &gt;= 5 &amp;&amp; i&gt;= 9 ) &#123; connection.close(); &#125;&#125;&#125; Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象12345678# druid.properties文件driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/jdbcusername=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 123456789101112131415public static void main(String[] args) throws Exception &#123;//1.导入jar包//2.定义配置文件//3.加载配置文件Properties properties = new Properties();InputStream is = C_Druid.class.getClassLoader().getResourceAsStream("druid.properties");properties.load(is);//3.获取 数据库连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource( properties );//4.获取 数据库连接对象Connection connection = dataSource.getConnection();//5.打印System.out.println(connection);&#125; 对比 C3P0 导入jar包 c3p0-0.9.5.2.jar（数据库连接池技术jar包） mchange-commons-java-0.2.12.jar （依赖jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 名称： c3p0.properties 或者 c3p0-config.xml 路径：src目录下 创建数据库连接池对象 ComboPooledDataSource 获取连接对象 Druid 导入jar包 druid-1.0.9.jar数据库连接池技术jar包） mysql-connector-java-5.1.37-bin.jar（MySQL数据库驱动jar包） 定义配置文件 任意名称，但必须是properties文件 任意目录下 加载配置文件 获取数据库连接池对象 通过工厂来来获取 DruidDataSourceFactory 获取连接对象 JDBC工具类 我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接池对象的静态方法 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class JDBCUtils &#123;// [静态变量:数据库连接池] private static DataSource dataSource;// [静态代码块：获取数据库连接池对象]// 使用数据库连接池对象后，我们就不需要挨个获取配置文件中的数据了，因为数据库连接池对象已经帮我们获取了，所以我们只需要获取数据库连接池对象就行了。 static &#123; try &#123; //1.创建properties对象 Properties properties = new Properties(); //2.加载配置文件 properties.load( JDBCUtils.class.getClassLoader(). getResourceAsStream("druid.properties")); //3.获取 数据库连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;//[成员方法：获取Connection对象] public static Connection getConneciton() throws SQLException &#123; return dataSource.getConnection(); &#125;//[成员方法：获取DataSource对象] public static DataSource getDataSource()&#123; return dataSource; &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat,Connection conn)&#123; close(null,stat,conn); &#125; //[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(ResultSet reSet,Statement stat, Connection conn)&#123; if (reSet!=null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat!=null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>C3P0</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F08%2F01%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC简介 概念 Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。 JDBC本质 JDBC其实是sun公司定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去编写这套接口的实现类，包装成数据库驱动jar包。通过导入不同数据库厂商编写的数据库驱动jar包，来对JBDC接口进行实现。 快速入门 导入MySQL数据库驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制到项目的libs目录下 右键 –&gt; Add As Library 注册驱动 driver “com.mysql.jdbc.Driver” 获取数据库连接对象 Connection 第一个参数：URL（jdbc:mysql://连接IP地址:端口号/数据库名） 第二个参数：数据库账号 第三个参数：数据库密码 定义SQL语句 获取执行SQL语句的对象 Statement 执行SQL语句，接受返回结果 处理结果 释放资源 123456789101112# 创建数据库CREATE DATABASE jdbc;# 使用数据库USE jdbc;# 创建表CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT , NAME VARCHAR(20), balance INT);# 插入数据INSERT INTO account VALUES(1,&apos;Cat&apos;,1000),(2,&apos;Dog&apos;,1000); 12345678910111213141516//1.导入驱动jar包//2.注册驱动Class.forName("com.mysql.jdbc.Driver");//3.获取数据库连接对象ConnectionConnection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc", "root", "root");//4.定义SQL语句String s = "UPDATE account SET balance = 1500 WHERE id =1";//5.获取执行SQL的对象StatementStatement statement = connection.createStatement();//6.执行SQLint count = statement.executeUpdate(s);//7.处理结果System.out.println(count);//8.释放资源statement.close();connection.close(); 详解对象DriverManager DriverManager驱动管理对象：用于管理一组JDBC驱动程序的基本服务。 新增的DataSource接口提供了另一种连接到数据源的方法。 使用DataSource对象是连接到数据源的首选方法。 注册驱动 注册驱动：其实就是一个指定数据库驱动jar包的过程。 我们在快速入门的时候，使用的注册驱动方式是加载文件： 加载MySQL数据库驱动jar包中的com.mysql.jdbc.Driver类 Class.forName(“com.mysql.jdbc.Driver”); 那么为什么加载com.mysql.jdbc.Driver类就能够注册驱动呢？我们来探究一下。 其实真正注册驱动调用的是DriverManager类中的registerDriver静态方法 注册与给定的驱动程序 DriverManager ：static void registerDriver(Driver driver) 而由于com.mysql.jdbc.Driver类在其静态代码块调用了registerDriver静态方法，所以当我们去加载这个类时，它会帮我们自动的注册驱动，简便了我们的操作。 MySQL5之后的驱动jar包可以省略注册驱动的步骤，因为它自动加载了com.mysql.jdbc.Driver类。12345678/* com.mysql.jdbc.Driver类中的静态代码块 */static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; 获取数据库连接 static Connection getConnection(String url, String user, String password) url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/db3 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 Connection Connection数据库连接对象：与特定数据库的连接。 获取执行SQL语句的对象 Statement createStatement() ：创建一个 Statement对象，用于将SQL语句发送到数据库。 PreparedStatement prepareStatement(String sql) ：创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 管理事务 void setAutoCommit(boolean autoCommit) ：（开启事务）将此连接的自动提交模式设置为给定状态。 true（自动提交） false（手动提交，开启事务） void commit() ：（提交事务）使自上次提交/回滚以来所做的所有更改都将永久性，并释放此 Connection对象当前持有的任何数据库锁。 void rollback() ：（回滚事务）撤消在当前事务中所做的所有更改，并释放此 Connection对象当前持有的任何数据库锁。 Statement Statement执行静态SQL语句的对象：用于执行静态SQL语句并返回其生成的结果的对象。 执行sql boolean execute(String sql) ：可以执行任意的SQL语句 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数 通过影响的行数可以判断语句是否执行成功。返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 练习：增删改添加记录注意：添加记录调用的是executeUpdate方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123;Connection conn = null;Statement stat = null;try &#123; //1.注册驱动 抓取异常 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "INSERT INTO account VALUES (NULL,'Rat',2000);"; //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 Statement stat = conn.createStatement(); //5.执行SQL语句 int i = stat.executeUpdate(s); //6.处理结果 if (i&gt;0) &#123; System.out.println("操作成功"); &#125;else &#123; System.out.println("操作失败"); &#125;&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; finally &#123;//7.释放资源/* 因为Statement和Connection已经在trycatch语句外声明了一个NULL值由于trycatch语句的特性，可能会造成在执行新的赋值语句之前就被中断了运行，所以Statement和Connection可能会是空值。于是这里需要采用if语句来避免空指针异常 */ if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 修改记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：修改记录执行SQL语句的是executeUpdate方法 123// .....String s = "UPDATE account SET balance =1000 WHERE name = 'rat'";// ..... 删除记录除了SQL语句，所有的代码都跟添加记录的练习一模一样。注意：删除记录执行SQL语句的是executeUpdate方法 123// .....String s = "DELETE FROM account WHERE name = 'rat'";// ..... ResultSet ResultSet结果集对象：表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。 封装查询结果 boolean next():：游标向下移动一行，并判断当前行是否是最后一行的末尾(是否有数据)。 如果是最后一行的末尾，则返回false；如果不是，则返回true。 getTYPE(参数)：获取数据 TYPE：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号，从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 练习：查询查询记录除了SQL语句、执行SQL语句和处理结果不一样，所有的代码都跟添加记录的练习一模一样。另外，你要在trycatch语句外声明一个ResultSet对象为NULL，并在finally语句中释放ResultSet资源。注意：查询记录执行SQL语句的是executeQuery方法 123456789101112131415161718192021// .....//2.定义SQL语句String s = "SELECT * FROM account";//3.获取数据库连接对象conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root");//4.获取执行SQL的对象 statementstat = conn.createStatement();//5.执行SQL，获取结果集reSet = stat.executeQuery(s);//6.处理结果// 1.让游标向下移动一行// 2.并判断是否是最后一行 while (reSet.next()) &#123;// 3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble("balance");// 4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125;// .... 查询记录（实体类）代码 查询数据库中emp表的数据，并将其封装为Employee对象，然后将其封装进List集合。 123456789101112131415161718192021222324252627282930# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号);-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),(1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10); 1234567891011121314151617181920212223242526272829303132333435363738394041// 实体类public class Employee &#123; // 成员变量（根据数据库的列来设置） private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; // 无参构造 public Employee() &#123; &#125; // 带参构造（按照数据库表中列的顺序） public Employee(int id, String ename, int job_id, int mgr, Date join_date, double salary, double bonus, int dept_id) &#123; this.id = id; this.ename = ename; this.job_id = job_id; this.mgr = mgr; this.join_date = join_date; this.salary = salary; this.bonus = bonus; this.dept_id = dept_id; &#125; // toString方法 @Override public String toString() &#123; return "Employee&#123;" + "id=" + id + ", ename='" + ename + '\'' + ", job_id=" + job_id + ", mgr=" + mgr + ", join_date=" + join_date + ", salary=" + salary + ", bonus=" + bonus + ", dept_id=" + dept_id + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 测试类// mian方法public static void main(String[] args) &#123; //调用方法，接收list集合 List&lt;Employee&gt; emps = returnTable(); //遍历list集合 for (Employee record : emps) &#123; System.out.println(record); &#125;&#125;// 成员方法（返回查询结果）public static List&lt;Employee&gt; returnTable()&#123;Connection conn = null;Statement stat = null;ResultSet reSet = null;List&lt;Employee&gt; tableList = new ArrayList&lt;&gt;();try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.定义SQL语句 String s = "SELECT * FROM emp"; //3.获取数据库连接对象 conn = DriverManager.getConnection("jdbc:mysql:///jdbc", "root", "root"); //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //6.1 让游标向下移动一行 //6.2 并判断是否是最后一行 while (reSet.next()) &#123; //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); //6.4 创建 Employee对象Employee emp = new Employee(id,ename,job_id,mgr,join_date,salary,bonus,dept_id); //6.5 将Employee对象添加进List集合 tableList.add(emp); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 /* 避免空指针异常，使用if语句判断 */ if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //8. 返回List集合 return tableList;&#125; 比较将数据库、实体类和测试类进行比较。 12345678910111213# MySQL数据库-- 创建表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT -- 所在部门编号); 1234567891011// 实体类 // 成员变量 private int id; private String ename; private int job_id; private int mgr; private Date join_date; private double salary; private double bonus; private int dept_id; 12345678910// 测试类 //6.3 获取数据 int id = reSet.getInt(1); String ename = reSet.getString(2); int job_id = reSet.getInt(3); int mgr = reSet.getInt(4); Date join_date = reSet.getDate(5); double salary = reSet.getDouble(6); double bonus = reSet.getDouble(7); int dept_id = reSet.getInt(8); PreparedStatement PreparedStatement执行动态SQL语句的对象：表示预编译（动态）的SQL语句的对象。 SQL注入问题 指在拼接SQL时，有一些特殊的SQL关键字参与，从而造成了安全性问题。 用户输入前 12// Java语句String sql = "SELECT * FROM user WHERE username = '"+username+"' AND password = '"+password+"';"; 用户输入后， 账户：随便，密码：a’ or ‘a’=’a 1234# SQL语句SELECT * FROM JDBC_user WHERE username = &apos;随便&apos; AND password =&apos;a&apos; OR &apos;a&apos;=&apos;a&apos;;# 语句永远成立，轻松登录成功。 解决SQL注入问题 使用PreparedStatement对象来解决SQL注入问题。 预编译（动态）的SQL：参数使用?作为占位符 使用步骤： 导入驱动jar包 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 传递SQL语句，获取执行动态SQL语句的对象 PreparedStatement 给？占位符赋值： 方法： setXxx(参数1,参数2) 参数1：？占位符的位置编号，从1 开始 参数2：？占位符的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 登录案例 需求 用户通过键盘录入用户名和密码； 查询数据库后，判断用户是否登录成功。 使用静态SQL12345678# 创建表CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(30), PASSWORD VARCHAR(30));# 插入数据INSERT INTO USER VALUES(1,&apos;cat&apos;,111),(2,&apos;dog&apos;,222); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// [main方法]public static void main(String[] args) &#123;//用户输入Scanner scanner = new Scanner(System.in);System.out.println("请输入账户：");String username = scanner.next();System.out.println("请输入密码：");String password = scanner.next();//调用login方法boolean flg = login(username, password);//输入if (flg)&#123; System.out.println("登录成功");&#125;else &#123; System.out.println("登录失败");&#125;&#125;//[login方法]public static boolean login(String username, String password) &#123; //防止输入空值 if (username == null) &#123; return false; &#125; if (password == null) &#123; return false; &#125; //声明变量 Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM JDBC_user WHERE username = '"+username+"' AND password = '"+password+"'"; //获取Statement对象 statement = connection.createStatement(); //执行SQL语句，并获取ResultSet对象 resultSet = statement.executeQuery(sql); //返回 return resultSet.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //返回 return false; &#125; 使用动态SQL1234567891011121314151617// ..... try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //编写SQL语句 String sql = "SELECT * FROM user WHERE username = ? AND password = ? "; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql); //通过PreparedStatement类的set方法，给？占位符赋值 preparedStatement.setString(1,username); preparedStatement.setString(2,password); //通过PreparedStatement类的executeQuery方法，并获取ResultSet对象 resultSet = preparedStatement.executeQuery();//不需要传参 //返回 return resultSet.next();&#125; catch (SQLException e) &#123;// ..... JDBC工具类 经过几个JDBC的案例之后，我们不难发现JDBC的编写中存在大量复杂的相同的代码，为了简化书写，我们引入了JDBC工具类：JDBCUtils。 但仅仅使用JDBC工具类，仍然不能使得获取数据库连接对象的代码变得简洁，而我们每次在获取数据库连接对象时，输入的三个参数是很少会变化的。于是，为了更加简化书写，我们引入了JDBC配置文件：jdbc.properties。 为了达到最终的目的，我们需要在JDBC工具类中来编写以下内容： 静态变量 静态代码块 获取数据库连接对象的静态方法 增删改操作释放资源的静态方法 查询操作释放资源的静态方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//J DBC工具类：JDBCUtilspublic class JDBCUtils &#123;// [静态变量] private static String url; private static String user; private static String password; private static String driver; // [静态代码块：读取配置文件的数据] static &#123; try &#123;// 1.创建properties对象 Properties properties = new Properties();// 1.1 获取 字节码文件 Class jdbcClass = JDBCUtils.class;// 1.2 获取 类加载器 ClassLoader classLoader = jdbcClass.getClassLoader();// 1.3 获取 统一资源定位符 URL resource = classLoader.getResource("jdbc.properties");// 1.4 获取 路径 String path = resource.getPath();// 2.加载配置文件 properties.load(new FileReader(path));// 3.获取数据 url = properties.getProperty("url"); user = properties.getProperty("user"); password = properties.getProperty("password"); driver = properties.getProperty("driver");// 4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //[成员方法：获取Connection对象] public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125;//[成员方法：增删改操作释放Connection对象、Statement对象] public static void close(Statement stat, Connection conn) &#123; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;//[成员方法：查询操作释放Connection对象、Statement对象、ResultSet对象] public static void close(Statement stat, Connection conn, ResultSet reSet) &#123; if (reSet != null) &#123; try &#123; reSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stat != null) &#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 12345# properties提示配置文件url = jdbc:mysql:///jdbcuser = rootpassword = rootdriver = com.mysql.jdbc.Driver 查询练习123456789101112131415161718192021222324252627282930313233// 使用JDBC工具类public static void main(String[] args) &#123; Connection conn = null; Statement stat = null; ResultSet reSet = null; try &#123; //1.注册驱动 //2.获取数据库连接对象 conn = JDBCUtils.getConnection(); //3.定义SQL语句 String s = "SELECT * FROM account"; //4.获取执行SQL的对象 statement stat = conn.createStatement(); //5.执行SQL reSet = stat.executeQuery(s); //6.处理结果 //1.让游标向下移动一行 //2.并判断是否是最后一行 while (reSet.next()) &#123; //3.获取数据 int anInt = reSet.getInt(1); String string = reSet.getString(2); double aDouble = reSet.getDouble(3); //4.输出数据 System.out.println(anInt + "---" + string + "---" + aDouble); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 JDBCUtils.close(stat,conn,reSet); &#125;&#125; JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 JDBC使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) （false为开启事务） 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 我在代码中写入了一句异常 ，当程序运行到异常时，异常后的提交事务不会进行，程序运行catch语句，进行事务回滚，账户会回滚到之前的状态。当然，如果去除异常，交易会正常进行，账户会发生变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null;try &#123; //获取Connection对象 connection = JDBCUtils.getConnection(); //【开启事务】 connection.setAutoCommit(false); //定义SQL语句 [Cat -500]*** String sql1 = "UPDATE account SET balance = balance - ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql1); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,1); //执行SQL语句 int i = preparedStatement.executeUpdate();System.out.println(i); //定义SQL语句 [Dog +500]*** String sql2 = "UPDATE account SET balance = balance + ? WHERE id = ?"; //传递SQL语句，获取preparedStatement对象 preparedStatement = connection.prepareStatement(sql2); //通过PreparedStatement类的set方法，给？赋值 preparedStatement.setInt(1,500); preparedStatement.setInt(2,2); //执行SQL语句 i = preparedStatement.executeUpdate(); System.out.println(i); // ***异常*** int iii = 3/0; //【提交事务】 connection.commit();&#125; catch (Exception e) &#123; //【事务回滚】 try &#123; if (connection!= null) &#123; connection.rollback(); &#125; &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace();&#125; finally &#123;// 释放资源JDBCUtils.close(preparedStatement,connection);&#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis快速入门]]></title>
    <url>%2F2019%2F07%2F31%2FMyBatis%2F</url>
    <content type="text"><![CDATA[内容简介本文是对MyBatis的三种操作方式进行的演示，包括MyBatis环境搭建，以及一些细节知识点。三种方式大同小异，目的是一样的。我为了分别三种操作方式，将以其不同处的特点命名每种操作方法。 创建映射配置文件的方式 在持久层接口中使用注解的方式 创建持久层接口实现类的方式 搭建环境创建Maven工程 GroupID 项目组织唯一的标识符 实际对应Java的包的结构，main/Java目录下的目录结构。 GroupID分为多段，第一段为域，第二段为公司名称等。 域：org（非盈利组织）、com（商业公司）、cn（中国组织） ArtifactID 项目的唯一的标识符 实际对应项目的名称，项目根目录的名称。 举例：Apache公司的Tomcat项目GroupID：org.apacheArtigactID：tomcat 第一步：创建Maven工程 第二步：设置GroupID、ArtifactID 第三步：设置项目名和模板名 第四步：Maven自动下载组件 添加MyBatis坐标 Maven坐标 Maven拥有数量非常巨大的构件（jar/war），而任何一个构件都可以使用Maven坐标来获取。maven坐标的元素包括groupId，artifactId，version，package，classifier。 引入依赖 一旦我们在pom.xml文件中配置好dependancy标签中的groupId标签，artifact标签，verison标签和classifier标签，maven就会从仓库中寻找相应的构件供我们使用。 在pom.xml 文件中，引入4个依赖： mybatis 3.4.5 mysql 5.1.6 junit 4.10 log4j 1.2.12 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建数据库1234567891011121314# 创建数据库CREATE DATABASE eesy_mybatis;USE eesy_mybatis;# 创建表CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` DATETIME DEFAULT NULL COMMENT &apos;生日&apos;, `sex` CHAR(1) DEFAULT NULL COMMENT &apos;性别&apos;, `address` VARCHAR(256) DEFAULT NULL COMMENT &apos;地址&apos;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;# 插入数据INSERT INTO `user`(`id`,`username`,`birthday`,`sex`,`address`) VALUES (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;),(42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;),(46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;),(48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 映射配置文件 目录结构： src/main java cn/water/dao UserDao.java（持久层接口） cn/water/domain User.java（持久层） resources cn/water/dao UserDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisTest.java（测试文件） 实体类 实体类中的成员变量属性和数据库中的列属性保持一致。 1234567891011121314151617181920212223242526272829public class User implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口 持久层接口：编写一个操作数据库的方法，但是具体的SQL语句会由持久层接口的映射文件来编写。 1234567public interface UserDao &#123; List&lt;User&gt; findAll();&#125;` 映射配置文件 映射配置文件：专注于编写SQL语法。每个持久层接口对应一个映射配置文件。 创建位置：必须和持久层接口在相同的包中。 持久层接口：src/main/java/cn/water/dao/ 映射配置文件：src/main/resources/cn/water/dao/ 名称：必须以持久层接口名称命名文件名，扩展名是.xml 持久层接口：UserDao.java 映射配置文件：UserDao.xml 12345678910111213141516&lt;!-- UserDao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; MyBatis主配置文件 MyBatis主配置文件：专注于连接数据库。 每个持久层接口对应一个映射配置文件，每个映射配置文件对应MyBatis主配置文件中的一个mapper标签 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置MySQL的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试类 测试类：获取查询的结果 123456789101112131415161718192021222324public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream is = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory ssf = ssfb.build(is); /* 使用工厂 生产SqlSession对象 */ SqlSession ss = ssf.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserDao dao = ss.getMapper(UserDao.class); /* 使用代理对象 执行方法 */ List&lt;User&gt; list = dao.findAll(); /* 遍历 */ for (User user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ ss.close(); is.close(); &#125;&#125; 测试类中的设计模式构建者模式 定义： 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。 举例 计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将不同计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 InputeStream in = Resources.getResourceAsStream(“SqlMapConfig.xml”);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder;SqlSessionFactory factory = builder.build(in); 工厂模式 定义 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。 举例 各种产品有专门的工厂生产。在苹果工厂，我们可以拿到iPhone、iPad和macbook；在华为工厂，我们可以拿到p30，mate20，Matebook。我们不关心产品是如何做的，甚至可以不关心产品的名字（拿到工厂你就拿到了产品）。 优点 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 区别 建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 SqlSession sqlSession = factory.openSession(); 代理模式 定义 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 举例 购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； List&lt;User&gt; list = dao.findAll(); 持久层接口注解 介绍 通过注解来配置时，就不再需要映射配置文件了。 目录结构： src/main java cn/water/dao UserAnnoDao.java（持久层接口） cn/water/domain UserAnno.java（持久层） resources SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisAnnoTest.java（测试文件） 实体类1234567891011121314151617181920212223242526272829public class UserAnno implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口（注解） 在持久层接口的方法上添加注解 12345678public interface UserAnnoDao &#123; @Select("SELECT * FROM user;") List&lt;User&gt; findAll();&#125;` MyBatis主配置文件（添加映射） 添加mapper标签 123456789&lt;mappers&gt; &lt;!-- 映射配置文件：使用resource属性指定映射配置文件的项目路径。 --&gt; &lt;mapper resource="cn/water/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;!-- 注解：使用class属性指定被注解的持久层接口的全类名。 --&gt; &lt;mapper class="cn.water.dao.UserAnnoDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类 测试类：获取查询的结果。 123456789101112131415161718192021222324public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建SqlSessionFactoryBuilder工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建SqlSessionFactory工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 生产SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 创建Dao接口的代理对象 */ UserAnnoDao dao = sqlSession.getMapper(UserAnnoDao.class); /* 使用代理对象 执行方法 */ List&lt;UserAnno&gt; list = dao.findAll(); /* 遍历 */ for (UserAnno userAnno : list) &#123; System.out.println(userAnno); &#125; /* 释放资源 */ sqlSession.close(); inputStream.close(); &#125;&#125; 比较 映射配置文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.User"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; 注解 显然注解方式，极大的简化了映射配置文件所需要的过程 12@Select("SELECT * FROM user;")List&lt;UserAnno&gt; findAll(); 持久层接口实现类 目录结构： src/main java cn/water/dao UserImpDao.java（持久层接口） cn/water/dao/Impl UserImpDao.java（持久层接口的实现类） cn/water/domain UserImp.java（持久层） resources cn/water/dao UserImpDao.xml（持久层接口的映射配置文件） SqlMapConfig.xml（MyBatis主配置文件） src/tese java cn/water/test MybatisImpTest.java（测试文件） 实体类1234567891011121314151617181920212223242526272829public class UserImp implements Serializable &#123;// 成员变量（对应MySQL数据库中的数据） private Integer id; private String username; private Date birthday; private String sex; private String address; // 省略其他set方法 public Integer getId() &#123; return id; &#125;// 省略其他get方法 public void setId(Integer id) &#123; this.id = id; &#125;// toString方法 @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 持久层接口123456public interface UserImpDao &#123; List&lt;User&gt; findAll();&#125;` 持久层接口实现类（新增）123456789101112131415161718192021public class UserImpDaoImpl implements UserImpDao &#123; private SqlSessionFactory factory; public UserImpDaoImpl(SqlSessionFactory factory)&#123; this.factory = factory; &#125; public List&lt;UserImp&gt; findAll() &#123; /* 使用工厂 创建SqlSession对象 */ SqlSession sqlSession = factory.openSession(); /* 使用SqlSession对象 执行查询所有方法 */ /* 参数为：持久层接口的映射配置文件的namespace属性值+持久层接口的方法名 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll"); /* 释放资源 */ sqlSession.close(); return list; &#125;&#125;` 映射配置文件（更新参数）12345678910111213141516&lt;!-- UserImpDao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置映射文件 --&gt; &lt;!-- namespace：持久层接口的全类名 --&gt;&lt;mapper namespace="cn.water.dao.UserImpDao"&gt; &lt;!-- 配置持久层接口的方法 --&gt; &lt;!-- id：方法名称 --&gt; &lt;!-- resultType：返回类型（全类名） --&gt; &lt;select id="findAll" resultType="cn.water.domain.UserImp"&gt; SELECT * FROM user; &lt;/select&gt;&lt;/mapper&gt; MyBatis主配置文件（添加映射）123&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserImpDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类(编写)12345678910111213141516171819202122232425262728293031323334public class MybatisImpTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; /* 读取配置文件 */ InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); /* 创建工厂实现类 */ SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); /* 使用IO流和工厂实现类 创建工厂接口 */ SqlSessionFactory factory = builder.build(inputStream); /* 使用工厂 创建持久层接口的对象 */ UserImpDao dao = new UserImpDaoImpl(factory); /* 由持久层接口的实现类来生产SqlSession对象 */ /* 使用工厂 生产SqlSession对象 */ //SqlSession sqlSession = factory.openSession(); /* 当我们自己定义了持久层实现类之后，我就不需要代理类了 */ /* 使用SqlSession对象 创建Dao接口的代理对象 */ // UserImpDao dao = sqlSession.getMapper(UserImpDao.class); /* 使用代理对象 执行方法 */ List&lt;UserImp&gt; list = dao.findAll(); /* 遍历 */ for (UserImp user : list) &#123; System.out.println(user); &#125; /* 释放资源 */ /* 没有session，不必释放资源了 */ // sqlSession.close(); inputStream.close(); &#125;&#125; 报错错误一：IllegalArgumentException错误代码1Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.water.dao.UserImpDao 错误原因一：SqlSession调用selectList方法的参数错误123456&lt;!-- 持久层接口的映射配置文件 --&gt;&lt;mapper namespace="cn.water.dao.UserImpDao"&gt; &lt;select id="findAll" resultType="cn.water.domain.UserImp"&gt; SELECT * FROM user; &lt;/select&gt; 12345678910111213/* 持久层接口的实现类*/public class UserImpDaoImpl implements UserImpDao &#123; public List&lt;UserImp&gt; findAll() &#123; /* 错误参数：持久层接口的映射配置文件的namespace属性值 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao"); /* 正确参数：持久层接口的映射配置文件的namespace属性值+id属性 */ List&lt;UserImp&gt; list = sqlSession.selectList("cn.water.dao.UserImpDao.findAll"); &#125;&#125; 错误原因二：MyBatis主配置文件中没有设置mapper标签1234&lt;!-- 映射配置文件：使用resource属性指定映射配置文件的位置。 --&gt;&lt;mappers&gt; &lt;mapper resource="cn/water/dao/UserImpDao.xml"&gt;&lt;/mapper&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[基础知识概念 反射是框架设计的灵魂。 反射机制就是将类的各个组成部分封装为其他对象。优势 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 Java代码的阶段 Java代码在计算机中经历的三个阶段 Source（源代码阶段） Java文件被Javac编译为class文件，class文件会将成员变量、成员方法和构造方法等编译成不同的模块。 class文件通过 Classload类加载器 来进入和下一阶段。 Class（类对象阶段） 通过 Classload类加载器，将class文件加载进内存，成员变量、成员方法和构造方法会被封装为Class类中的对象。 Runtime（运行阶段） 当我们需要访问Java文件的成员时，我们就可以逆向访问，通过Class类的Classload类加载器来获取该成员的对象。 获取Class对象 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。 处于Source（源代码阶段），并未加载进内存。 用于配置文件，将类名定义在配置文件中。读取文件，从而加载类。 类名.class：通过类名的属性class获取。 处于Class（类对象阶段），已经加载进内存。 多用于参数的传递。 对象.getClass()：Object类中定义的方法。 Runtime（运行阶段），处于运行时。 用于获取对象的字节码文件对象。 Class类对象 同一个字节码文件( .class)在一次程序运行过程中，只会被加载一次。 不论通过哪一种方式获取的Class类对象都是同一个。12345678// Class类.静态方法forName("全类名")Class class1 = Class.forName("com.test.Person");// 类名.成员classClass class2 = Person.class;// 对象名.成员方法getClass()Person person = new Person();Class class3 = person.getClass(); 获取成员变量 Field[] getFields() 返回包含一个 Field对象数组，反射 所有可访问的 public字段类对象。 Field getField(String name) 返回一个 Field对象，反射 指定的 public成员字段类对象。 Field[] getDeclaredFields() 返回一个 Field对象，反射 所有可访问的 已声明字段类对象。（不考虑修饰符） Field getDeclaredField(String name) 返回一个 Field对象数组，反射 指定已声明字段类对象。（不考虑修饰符） Person类中的成员变量 123456789// public修饰符 public String publicName; public int publicAge;// private修饰符 private String privateName;// protected修饰符 protected String protectedName;// 无修饰符 String name; 获取Person类中的成员变量 123456789101112131415161718192021222324252627 Class pc = Person.class;/* getField("") */Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicName/* getFields() */Field[] fies = pc.getFields(); // public java.lang.String test.Person.publicName // public int test.Person.publicAge/* getDeclaredField("") */Field fie = pc.getDeclaredField("privateName");privateName.setAccessible(true); // private java.lang.String test.Person.privateName/* getDeclaradFields() */Field[] fies = pc.getDeclaredFields();for (Field fie : fies) &#123; fie.setAccessible(true);&#125; // public java.lang.String test.Person.publicName // private java.lang.String test.Person.privateName // protected java.lang.String test.Person.protectedName // java.lang.String test.Person.name 获取构造方法 Constructor&lt;?&gt;[] getConstructors() 返回一个 Constructor对象，反射 指定的 public构造类对象。 Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象，反射 指定的 构造类对象。 Constructor&lt;T&gt; getConstructor(类&lt;?&gt;… parameterTypes) 返回一个 Constructor对象数组，反射 所有的 public构造类对象。 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回一个 Constructor对象数组，反射 所有定的 构造类对象。 Person类中的构造方法 123456789// 无参构造public Person() &#123;&#125;// public 带参构造（String）public Person(String publicName) &#123;&#125;// private 带参构造（String,String）private Person(String publicName,String privateName) &#123;&#125; 获取Person类中的构造方法 12345678910111213141516171819202122232425262728/* getConstructor */ Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; Constructor con = pc.getConstructor(String.class); Object object = constructor2.newInstance("Cat"); // &#123;publicName='Cat', privateName='null'&#125;/* getDeclaredConstructor */ Constructor con = pc.getDeclaredConstructor(String.class,String.class,); declaredConstructor.setAccessible(true); Object object = declaredConstructor1.newInstance("Pig","Pug"); // &#123;publicName='Pig', privateName='Pug'&#125;/* getConstructors */ Constructor[] cons = pc.getConstructors(); // public test.Person() // public test.Person(java.lang.String,)/* getDeclaredConstructors */ Constructor[] cons = pc.getDeclaredConstructors(); // public test.Person() // public test.Person(java.lang.String) // private test.Person(java.lang.String,java.lang.String) 获取成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 public成员方法类对象。 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 返回一个 Method对象，反射 指定的 成员方法类对象。 Method[] getMethods() 返回一个 Method对象数组，反射 所有的 public成员方法类对象。 Method[] getDeclaredMethods() 返回一个 Method对象数组，反射 所有的 成员方法类对象。 Person类中的成员方法 12345678910// public修饰符 public void publicMethod111()&#123;System.out.println("publicMethod()...");&#125; public void publicMethod222(String s)&#123;System.out.println("publicMethod("+ s +")...");&#125;// private修饰符 private void privateMethod()&#123;System.out.println("privateMethod()...");&#125;// protected修饰符 protected void protectedMethod()&#123;System.out.println("publicMethod()...");&#125; 获取Person类中的成员方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445 Class pc = Person.class; Person p = new Person();/* getMethod */ Method method = personClass.getMethod("publicMethod111"); // public void test.Person.publicMethod111() method.invoke(p); // publicMethod()... Method method = personClass.getMethod("publicMethod222", String.class); // public void test.Person.publicMethod222(java.lang.String) method.invoke(p,"带参"); // publicMethod(带参).../* getDeclaredMethod */Method method = pc.getDeclaredMethod("privateMethod"); //private void test.Person.privateMethod()method.setAccessible(true);method.invoke(p); // privateMethod().../* getMethods */ Method[] methods = personClass.getMethods(); //public java.lang.String test.Person.toString() //public java.lang.String test.Person.getName() //public void test.Person.setName(java.lang.String) //public void test.Person.publicMethod111() //public void test.Person.publicMethod222(java.lang.String) //public void test.Person.setPublicAge(int) //public void test.Person.setProtectedName(java.lang.String) //public int test.Person.getPublicAge() // ................................/* getDeclaredMethods */Method[] methods = personClass.getDeclaredMethods(); // public java.lang.String test.Person.toString() // public java.lang.String test.Person.getName() // public void test.Person.setName(java.lang.String) // public void test.Person.publicMethod111() // protected void test.Person.protectedMethod() // private void test.Person.privateMethod() // public void test.Person.publicMethod222(java.lang.String) // public void test.Person.setPublicAge(int) // public void test.Person.setProtectedName(java.lang.String) // ............................... 获取全类名 String getName() 其他操作操作Field 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 暴力反射：忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射123456789101112131415161718Class pc = Person.class;Person p = new Person(); /*public修饰符*/Field fie = pc.getField("publicName"); // public java.lang.String test.Person.publicNamefie.set(p,"cat");System.out.print( fie.get(p) ); // cat /*private修饰符*/Field fie = pc.getDeclaredField("privateName"); // private java.lang.String test.Person.privateNamepc.setAccessible(true);pc.set(p,"dog");System.out.print( fie.get(p) ); // dog 操作Constructor 创建对象 T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化 Class对象的newInstance方法 123456789101112 /* Class */ Class pc = Person.class; Object object = pc.newInstance(); // &#123;publicName='null', privateName='null'&#125;/* Constructor */ Class pc = Person.class; Constructor con = pc.getConstructor(); Object object = constructor.newInstance(); // &#123;publicName='null', privateName='null'&#125; 操作Method 执行方法 Object invoke(Object obj, Object… args) 获取方法名 String getName12345Class pc = Person.class;Person p = new Person();Method method = personClass.getMethod("publicMethod111");method.invoke(p);// publicMethod()...]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%2F</url>
    <content type="text"><![CDATA[基础知识数据库 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。 我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。 所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS 即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS 术语 数据库：数据库是一些关联表的集合。 数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列：一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。MySQL数据库 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。 MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将- 所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。入门配置 打开刚刚解压的文件夹 C:\web\mysql-8.0.11 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 启动 启动MySQL 1net start mysql 登录 MySQ -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 1mysql -h 主机名 -u 用户名 -p 密码 登录本机MySQL 1mysql -u 用户名 -p 密码 关闭MySQL 1net stop mysql 管理 USE $table SHOW DATABASES SHOW TABLES SHOW COLUMNS FROM $table USE $database 选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。 12&gt; Database changed&gt; SHOW DATABASES 列出 MySQL 数据库管理系统的数据库列表。 123456789&gt; +--------------------+&gt; | Database |&gt; +--------------------+&gt; | information_schema |&gt; | mysql |&gt; | performance_schema |&gt; | test |&gt; +--------------------+&gt; SHOW TABLES 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。 12345678&gt; +------------------+&gt; | Tables_in_runoob |&gt; +------------------+&gt; | employee_tbl |&gt; | runoob_tbl |&gt; | tcount_tbl |&gt; +------------------+&gt; SHOW COLUMNS FROM $database 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 12345678+-----------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+--------------+------+-----+---------+-------+| runoob_id | int(11) | NO | PRI | NULL | || runoob_title | varchar(255) | YES | | NULL | || runoob_author | varchar(255) | YES | | NULL | || submission_date | date | YES | | NULL | |+-----------------+--------------+------+-----+---------+-------+ SQL SQL （Structured Query Language ） 结构化查询语言 特点 以分号结尾； 不区分大小写。 分类 DDL（Data Definition Language ） ：定义数据库、表。 DML（Data Manipulation Language） ：对数据库中表的数据进行增删改。 DQL （Data Query Language）：查询数据库中表的数据。 DCL（Data Control Language） ：定义数据库的访问权限和安全级别，及创建用户。 注释 单行注释：“– ”(空格必须加） 单行注释：“#”（空格可加可不加） 多行注释：“/* */” DDL Data Definition Language 数据定义语言 操作数据库使用123456# 使用数据库USE $database;# 查询当前正在使用的数据库名称SELECT DATABASE(); 创建123456789101112# 创建数据库CREATE DATABASE $database;# 创建数据库，并判断是否存在CREATE DATABASE IF NOT EXISTS $database;# 创建数据库，并设置字符集CREATE DATABASE $database CHARACTER SET utf-8;# 创建数据库，判断是否存在，并设置字符集CREATE DATABASE IF NOT EXISTS $database CHARACTER SET utf-8; 查询123456# 查询所有数据库名称SHOW DATABASES;# 查询数据库的创建语句SHOW CREATE DATABASE $database; 修改123# 修改数据库的字符集ALTER DATABASE $database CHARACTER SET gbk; 删除123456# 删除数据库DROP DATABASE $database;# 删除数据库，判断是否存在DROP DATABASE IF EXISTS $database; 操作表、列创建123456789# 创建表CREATE TABLE $table( $columnA $type, $columnB $tyep);# 创建副本CREATE TABLE $tableB LIKE $tableA 查询123456789# 查询某个数据库中的所有表SHOW TABLES;# 查询表结构DESC $table;# 查询表的创建语句SHOW CREATE TABLE $table; 修改123456789101112131415161718# 修改表名ALTER TABLE $tableOld RENAME TO $tableNew# 修改表的字符集ALTER TABLE $table CHARACTER SET utf-8;# 修改列ALTER TABLE $table CHANGE $columnOld $columnNew $typeNew;# 修改类型ALTER TABLE $table MODIFY $column $tyepNew;# 添加列ALTER TABLE $table ADD $column $type;# 删除列ALTER TABLE $table DROP $column; 删除123456# 删除表DROP TABLE $table;# 删除表，判断是否存在DROP TABLE IF EXISTS $table; DML Data Manipulation Language 数据操作语言 操作记录、值创建123456# 给记录中的所有字段，添加值INSERT INTO $table VALUES($valueA,$valueB....)# 给记录中指定的字段，添加值INSERT INTO $table($columnA) VALUES($valueA) 删除123456789# 删除所有记录DELETE * FROM $table;# 删除指定记录DELETE FROM $table WHERE $column = $value;# 删除所有记录，并创建一个空副本TRUNCATE TABLE $table; 修改123456# 给记录中所有的字段，修改值UPDATE $table SET $columnA = $valueA;# 给记录中指定的字段，修改值UPDATE $table SET $columnA = $valueA WHERE $colmnB = $valueB; DQL Data Query Language 数据查询语言 基础查询123456789101112131415161718192021222324252627282930313233# 查询表中的所有列SELECT * FROM $table;# 查询表中指定的列SELECT $column FROM $table;# 查询表中指定的列，并去掉重复的字段SELECT DISTINCT $column FROM $table;# 查询表中指定的列，并计算SELECT $columnA, $columnB, $columnA + $columnB FROM $table;# 查询表中指定的列，并计算，且排除为null的情况SELECT $columnA, $columnB, IFNULL($columnA,0) + IFNULL($columnB,0) FROM $table;# 查询表中指定的列，计算，排除为null的情况，给计算结果起名# AS可省略SELECT $columnA AS $nameA, $columnB AS $nameB, IFNULL($columnA,0)+IFNULL($columnB,0) AS $nameCFROM $table; 条件查询1234567891011121314151617181920# 大于、大于等于、等于、不等于、不等于WHERE $column &gt; $value;WHERE $column &gt;= $value;WHERE $column = $value;WHERE $column != $value;WHERE $column &lt;&gt; $value;# 范围WHERE $column&gt;=10 &amp;&amp; $column&lt;=100;WHERE $column&gt;=10 AND $column&lt;=100;WHERE $column BETWEEN 10 AND 1000;# 个例WHERE $column=10 OR $column=20;WHERE $column IN (10,20,30,40);#查询NULLWHERE $column IS NULL;WHERE $column IS NOT NULL; 模糊查询123456# “_” 单个任意字符WHERE $column = &apos;C_t&apos;;# “%” 多个任意字符WHERE $column = &apos;super%&apos;; 排序查询123456# 按照指定列的顺序，升序排序ORDER BY $column ASC;# 按照指定列的顺序，降序排序ORDER BY $column DESC; 聚合函数 聚合函数排除了NULL值123456789101112131415161718# 计算指定列的 字段个数SELECT COUNT($column) FROM $table;# 计算指定列的 字段个数，且不排除NULL值SELECT COUNT( IFNULL($column,0) ) FROM $table;# 计算指定列的 最大值SELECT MAX($column) FROM $table;# 计算指定列的 最小值SELECT MIN($column) FROM $table;# 计算指定列的和SELECT SUM($column) FROM $table;# 计算指定列的平均值SELECT AVG($column) FROM $table; 分组查询12 分页查询DCL Data Control Language 数据控制语言 12 约束]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS中的函数是否加括号的问题]]></title>
    <url>%2F2019%2F07%2F22%2FJS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数表达式的定位 本文相关的概念：函数，函数表达式，返回值。 函数：函数名为Fun的函数。函数表达式：Fun() 和 fun。返回值：即函数Fun的返回值。 首先，需要明确的概念是：函数表达式的定位。不同的定位决定了不同的功能，以下是我列出来的函数表达式及其定位。我会在详细表述表达式时，附上便于理解的代码。 函数表达式 定位 function() 调用函数、返回返回值 function 函数的副本 函数表达式 function()当按钮被点击，函数表达式Fun() 作为参数首先被执行。于是，第一步，函数Fun被调用，函数Fun执行 方法alert(111)，弹出“111”；第二步，函数fun 返回 返回值222。接着，按钮的点击事件执行 alert方法，并接收到了返回值222，弹出“222”。 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun()); &#125;&lt;/script&gt; 函数表达式 function我们在前面说到 函数表达式Fun 的定位是 函数Fun 的一个副本。为了印证这个观点，其余代码不变，将函数表达式Fun() 换成 函数表达式Fun。我得到的结果是，弹出： “ function Fun() { alert(1); return 222; } “ 12345678910111213141516&lt;body&gt; &lt;input type="button" id="btn"&gt;&lt;/body&gt;&lt;script&gt; // 获取按钮对象 var btn = document.getElementById("btn"); // 方法 function Fun() &#123; alert(111); return 222; &#125; // 点击按钮 弹出函数表达式 btn.onclick = function () &#123; alert(fun; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F07%2F21%2Fredis%2F</url>
    <content type="text"><![CDATA[NoSQL概念 NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web- 0网站的兴起，传统的关系数据库在应付web- 0网站，特别是超大规模和高并发的SNS类型的web- 0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 比较非关系型数据库优势 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 ## 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 ## 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis## 概念 Redis是一款高性能的NOSQL系列的非关系型数据库 Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s 。 Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedsetredis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离下载安装 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端数据结构 Redis存储：key，value格式的数据 key的数据类型：字符串 value的数据结构： 字符串类型 string 哈希类型 hash （map格式） 列表类型 list （ Linkedlist格式，允许重复） 集合类型 set （HashSet格式，不允许重复） 有序集合类型 sortedset （不允许重复，且有序）命令操作字符串类型 string 存储： set key value 获取： get key 删除： del key 哈希类型 hash 存储： hset key field value 获取指定的field对应的值：hget key field: 获取所有的field和value：hgetall key 删除： hdel key field 列表类型 list 将元素加入列表左边： lpush key value 将元素加入列表右边：rpush key value 范围获取：lrange key start end 获取所有元素：lrange key 0 -1 删除列表最左边的元素，并将元素返回：lpop key 删除列表最右边的元素，并将元素返回：rpop key 集合类型 set set 集合 （ 不允许重复） 存储：sadd key value 获取set集合中所有元素：smembers key 删除set集合中的某个元素：srem key value 有序集合类型 sortedset sortedset集合 不允许重复元素，且元素有顺序。 每个元素都会关联一个double类型的分数。 redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令 查询所有的键：keys * 获取键对应的value的类型：type key 删除指定的key value：del key 持久化机制 Redis持久化 Redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据丢失时，我们可以将redis内存中的数据持久化，将其保存到硬盘的文件中。RDB 默认持久化机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据。 修改 redis.windwos.conf 文件 save 900 1：after 900 sec (15 min) if at least 1 key changed save 300 10：after 300 sec (5 min) if at least 10 keys changed save 60 10000：after 60 sec if at least 10000 keys changed 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf AOF 日志记录机制 记录每一条命令的操作。每一次命令操作后，持久化数据。 编辑 redis.windwos.conf 文件 开启AOF appendonly no（关闭AOF） ppendonly yes （开启AOF） 取值 appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化（默认） appendfsync no： 不进行持久化 使用命令行，重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf Jedis（Java客户端） Jedis:是一款java操作redis数据库的工具.快速入门 下载jedis的jar包 使用123456// 获取连接 Jedis jedis = new Jedis("localhost",6379);// 操作 jedis.set("username","zhangsan");// 关闭连接 jedis.close(); 命令操作字符串类型 string set get1234567891011121314151617@Test/* 操作字符串String */public void test02() &#123; // 获取连接 Jedis jedis = new Jedis(); //空参构造，默认("localhost",6379) // 存储 jedis.set("cat","001"); // 获取 String cat = jedis.get("cat"); System.out.println(cat); // 存储有时限的数据 jedis.setex("dog",10,"002"); // 时间单位：秒 // 关闭连接 jedis.close();&#125; 哈希类型 hash （ map格式 ） hset hget hgetAll12345678910111213141516171819202122232425@Test /* 操作Hash */public void test03() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.hset("map","cat","111"); jedis.hset("map","dog","222"); jedis.hset("map","rat","333"); // 获取 String cat = jedis.hget("map", "cat"); System.out.println(cat); // 获取hash中的map中的所有数据 Map&lt;String, String&gt; map = jedis.hgetAll("map"); // 输出 Set&lt;String&gt; keySet = map.keySet(); for (String s : keySet) &#123; String value = map.get(s); System.out.println(s+":"+value); &#125; // 关闭连接 jedis.close();&#125; 列表类型 list （ LinkedList格式，允许重复） lpush / rpush lpop / rpop lrange start end 12345678910111213141516171819202122@Test /* 操作List(允许重复) */public void test04() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.lpush("list","A","B","C","D"); jedis.rpush("list","A","B","C","D"); // 打印 List&lt;String&gt; list = jedis.lrange("list", 0, -1); System.out.println(list); // 弹出 String element1 = jedis.lpop("list"); String element2 = jedis.lpop("list"); // 打印 System.out.println(element1); System.out.println(element2); List&lt;String&gt; list2 = jedis.lrange("list", 0, -1); System.out.println(list2); // 关闭连接 jedis.close();&#125; 集合类型 set （HashSet格式， 不允许重复） sadd smembers12345678910111213@Test /* 操作Set(不允许重复) */public void test05() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.sadd("set","A","B","C","D"); // 获取 Set&lt;String&gt; set = jedis.smembers("set"); // 打印 System.out.println(set); // 关闭连接 jedis.close();&#125; 有序集合类型 sortedset zadd zrange123456789101112131415@Test /* 操作SortedSet(不允许重复，有序) */public void test06() &#123; // 获取连接 Jedis jedis = new Jedis(); // 存储 jedis.zadd("sortedSet",1,"cat"); jedis.zadd("sortedSet",2,"dog"); jedis.zadd("sortedSet",3,"rat"); // 获取 Set&lt;String&gt; sortedSet = jedis.zrange("sortedSet", 0, -1); // 打印 System.out.println(sortedSet); // 关闭连接 jedis.close();&#125; JedisPool（jedis连接池） 快速入门 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接123456789101112131415// 创建连接池配置对象 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); // 设置配置 jedisPoolConfig.setMaxTotal(50); jedisPoolConfig.setMaxIdle(10); // 创建连接池对象，并传入连接池配置对象 JedisPool jedisPool = new JedisPool(jedisPoolConfig, "localhost", 6379); // 获取连接 Jedis resource = jedisPool.getResource(); // 使用 resource.set("name", "cat"); String s = resource.get("name"); System.out.println(s); // 关闭，归还到连接池中 resource.close(); JedisPoolUtil工具类 设置 JedisPoolUtil工具类 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 设置之后的操作，简化了很多 123456789101112131415161718192021222324252627282930public class JedisPoolUtil &#123; // 连接池对象 private static JedisPool jedisPool; static &#123; // 读取配置文件 Properties properties = new Properties(); // 创建properties对象 InputStream resourceAsStream = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties"); try &#123; // 加载文佳 properties.load(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建连接池配置文件对象 JedisPoolConfig config = new JedisPoolConfig(); // 设置 config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle"))); // 初始化连接池对象 jedisPool = new JedisPool(config,properties.getProperty("host"),Integer.parseInt(properties.getProperty("port"))); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; ​]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F07%2F20%2FJson%2F</url>
    <content type="text"><![CDATA[概念 JSON：JavaScript 对象表示法（JavaScript Object Notation） JSON现在多用于存储和交换文本信息的语法，进行数据的传输。 JSON 比 XML 更小、更快，更易解析。 注意：JSON 虽然使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。1234567&#123; "employees": [ &#123; "firstName":"Bill" , "lastName":"Gates" &#125;, &#123; "firstName":"George" , "lastName":"Bush" &#125;, &#123; "firstName":"Thomas" , "lastName":"Carter" &#125; ]&#125; 区别类似 XML JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字总结 对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 语法 JSON 语法是 JavaScript 语法的子集。语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组名称/值对JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：1"firstName" : "John" 值 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） { “firstName”:”John” , “lastName”:”Doe” } null文件 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” 使用获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 123456789101112131415161718192021222324252627282930313233 /* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; var name11 = person.name; var name12 = person["name"];/* 嵌套格式 */ // JSON &#123; JSON,JASON &#125; var persons = &#123; "personCat": &#123;"name":"cat","age":11&#125;, "personDog":&#123;"name":"dog","age":12&#125;, "personRat":&#123;"name":"rat","age":13&#125;&#125; var personCat = persons.personCat; var name2 = persons.personCat.name; // Array [JSON,JASON] var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] var name3 = array[0].name; // JSON &#123; Array[JSON,JASON], Array[JSON,JASON] &#125; var persons = &#123; "person1":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,], "person2":[ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;,] &#125; var name4 = persons.person1[0].name; 遍历12345678910111213141516171819202122/* 基本格式 */ var person = &#123;"name":"cat","age":11&#125; for (var key in person) &#123; // * key默认为字符串 alert(key); alert(person.key); // * person."name"; 无法获取 alert(person[key]); // * person["name"]; 无法获取 &#125; /* 嵌套格式 */ var array = [ &#123;"name":"cat","age":11&#125;, &#123;"name":"dog","age":12&#125;, &#123;"name":"rat","age":13&#125;] for (var i =0;i&lt;array.length;i++) &#123; var p = array[i]; for (var key in p) &#123; alert(key); alert(p[key]); &#125; &#125; 转换 转换 由于JSON对象的特性，在实际操作中，我们通过JSON对象代替Java对象在数据中的传输。所以，我们需要学习JSON对象和Java对象的相互转换。 JSON解析器 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class)Java对象转换JSON 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 writeValue(参数1，obj) File：将obj对象转换为JSON字符串，并保存到指定的文件中。 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中。 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中。 writeValueAsString(obj) 将对象转为json字符串 注解 @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern = “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致 格式问题 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。 在浏览器端设置$.ajax属性 $.get(type):将最后一个参数type指定为”json” 在服务器端设置MIME类型 response.setContentType(“application/json;charset=utf-8”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F07%2F20%2FAjax%2F</url>
    <content type="text"><![CDATA[基础知识AJAX AJAX 是与服务器交换数据的艺术，它在不重载全部页面的情况下，实现了对部分网页的更新。 AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 异步和同步 同步 客户端和服务器端相互通信的基础上，客户端必须等待服务器端的响应。 在等待的期间客户端不能做其他操作。 异步 客户端和服务器端相互通信的基础上，客户端不需要等待服务器端的响应。 在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式JS实现方式（了解） 如果没有 jQuery，AJAX 编程还是有些难度的。123456789101112131415161718192021222324252627282930313233/* 发送异步请求 */// 1.创建对象 var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125;// 2.建立连接// * 请求方式：GET/POST// * 请求的URL// * 同步或异步请求：true（异步）、false（同步） xmlhttp.open("GET","/ajaxServlet?fname=Henry&amp;lname=Ford",true);// 3.发送请求 xmlhttp.send(); // POST方式 // xmlhttp.open("POST","/ajaxServlet",true); // xmlhttp.send("fname=Henry&amp;lname=Ford");// 4.接受并处理来自服务器的相应结果// 判断服务器是否成功响应 xmlhttp.onreadystatechange=function()&#123; // readyState：就绪状态 // status：响应状态码 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; // responseText：响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQeury实现方式 通过 jQuery AJAX 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON 同时能够把这些外部数据直接载入网页的被选元素中。$.ajax() 12345678910111213141516171819$.ajax(&#123; // url：请求路径 url:"/ajaxServlet", // type：请求方式 type:"POST", // data：请求参数 // data:"fname=Henry&amp;lname=Ford", data:&#123;"fname":"Henry","lname":"Ford"&#125;, // Json方式// success：响应成功后的回调函数 success:function (responseData) &#123; alert(responseData);&#125;,// error：响应错误后的回调函数error:function () &#123; alert("出错了!"); &#125;, // dateType：设置接受到的响应数据的格式 dataType:"text"&#125;); $.get()123456789101112 $.get( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125; $.post()123456789101112$.post( // url：请求路径 "/ajaxServlet", // data：请求参数 &#123;"fname":"Henry","lname":"Ford"&#125;, // success：响应成功后的回调函数 function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;, // dateType：设置接受到的响应数据的格式 "text"&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F07%2F19%2FjQuery%2F</url>
    <content type="text"><![CDATA[基础知识简介 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。 jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 jQuery封装了JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery本质上就是一些js文件，封装了js的原生代码而已。 jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 安装 下载JQuery 目前jQuery有三个大版本 1.x 兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了。 2.x 不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x。 3.x 不兼容ie678，只支持最新的浏览器。 除非特殊要求，一般不会使用3.x版本的，因为很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。 每个大版本包括两个小版本 jquery.js Development version（开发版本） - 用于测试和开发。 给程序员看的，有良好的缩进和注释，体积大一些，程序加载较慢。 jquery.min.js Production version（生产版本）- 用于实际的网站中，已被精简和压缩。 在程序中使用，没有缩进，体积小一些，程序加载更快。 导入JQuery的js文件 引入Jquery资源 请注意，&lt;script&gt; 标签应该位于页面的 &lt;head&gt; 部分。123&lt;head&gt; &lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt; 基础语法 $(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作文档就绪函数 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 123456789/* 完全体 */$(document).ready(function()&#123;&#125;);/* 简化版 */$(function()&#123;&#125;); 转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用 两者相互转换 Jquery – &gt; JS Jquery对象[索引] Jquery对象.get(索引) JS – &gt; Jquery $(JS对象) 选择器 jQuery选择器允许您对元素组或单个元素进行操作。 jQuery 元素选择器和属性选择器允许您通过标签名、属性名或内容对 HTML 元素进行选择。 jQuery选择器允许您对 HTML 元素组或单个元素进行操作。 在 HTML DOM 术语中：jQuery选择器允许您对 DOM 元素组或单个 DOM 节点进行操作。 基本选择器 选择器 实例 描述 * $(“*”) 所有元素 this $(this) 当前 HTML 元素 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) 所有 class=”intro” 的元素 .class.class $(“.intro.demo”) 所有 class=”intro” 且 class=”demo” 的元素 element $(“p”) 所有 &lt;p&gt; 元素 element.class $(“p.intro”) 所有 class=”intro” 的 &lt;p&gt; 元素 element#id $(“p#demo”) 所有 id=”demo” 的 &lt;p&gt; 元素。 s1,s2,s3 $(“th,td,.intro”) 所有带有匹配选择的元素 层级选择器 选择器 实例 描述 super sub $(“table tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;元素（不仅是子元素） super &gt; sub $(“table &gt; tr”) 选择 &lt;table&gt;元素内部的所有 &lt;tr&gt;子元素 ## 属性选择器 - jQuery 使用 XPath 表达式来选择带有给定属性的元素。 选择器 实例 描述 :—: —– —– [atribute] $(“[href]”) 所有带有 href 属性的元素 [[attribute = value]] $(“[href=’#’]”) 所有 href 属性的值等于 “#” 的元素 [[attribute != value]] $(“[href!=’#’]”) 所有 href 属性的值不等于 “#” 的元素 [[attribute *$= *value]] $(“[href$=’.jpg’]”) 所有 href 属性的值包含以 “.jpg” 结尾的元素 过滤选择器 选择器 实例 描述 [:first] $(“p:first”) 第一个 &lt;p&gt; 元素 [:last] $(“p:last”) 最后一个 &lt;p&gt; 元素 [:even] $(“tr:even”) 所有偶数 &lt;tr&gt; 元素 [:odd] $(“tr:odd”) 所有奇数 &lt;tr&gt; 元素 [:eq(index)] $(“ul li:eq(3)”) 列表中的第四个元素（index 从 0 开始） [:gt(no)] $(“ul li:gt(3)”) 列出 index 大于 3 的元素 [:lt(no)] $(“ul li:lt(3)”) 列出 index 小于 3 的元素 [:empty] $(“:empty”) 无子（元素）节点的所有元素 :not(selector) $(“input:not(:empty)”) 所有不为空的 input 元素 [:header] $(“:header”) 所有标题元素 &lt;h1&gt; - &lt;h6&gt; [:contains(text)] $(“:contains(‘W3School’)”) 包含指定字符串的所有元素 :hidden $(“p:hidden”) 所有隐藏的 &lt;p&gt; 元素 [:visible] $(“table:visible”) 所有可见的表格 表单过滤选择器 选择器 实例 描述 [:input] $(“:input”) 所有 &lt;input&gt; 元素 [:text] $(“:text”) 所有 type=”text” 的 &lt;input&gt; 元素 [:password] $(“:password”) 所有 type=”password” 的 &lt;input&gt; 元素 [:radio] $(“:radio”) 所有 type=”radio” 的 &lt;input&gt; 元素 [:checkbox] $(“:checkbox”) 所有 type=”checkbox” 的 &lt;input&gt; 元素 [:submit] $(“:submit”) 所有 type=”submit” 的 &lt;input&gt; 元素 [:reset] $(“:reset”) 所有 type=”reset” 的 &lt;input&gt; 元素 [:button] $(“:button”) 所有 type=”button” 的 &lt;input&gt; 元素 [:image] $(“:image”) 所有 type=”image” 的 &lt;input&gt; 元素 [:file] $(“:file”) 所有 type=”file” 的 &lt;input&gt; 元素 [:enabled] $(“:enabled”) 所有激活的 input 元素 [:disabled] $(“:disabled”) 所有禁用的 input 元素 [:selected] $(“:selected”) 所有被选取的 input 元素 [:checked] $(“:checked”) 所有被选中的 input 元素 事件函数 jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 术语由事件“触发”（或“激发”）经常会被使用。 如果你的网站包含许多页面，为了让 jQuery 函数易于维护，需要将 jQuery 函数放到独立的 .js 文件中。123456&lt;head&gt;&lt;!-- 引入Jquery资源 --&gt;&lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt;&lt;!-- 引入独立的js文件 --&gt;&lt;script type="text/javascript" src="my_jquery_functions.js"&gt;&lt;/script&gt;&lt;/head&gt; 鼠标事件 事件 描述 click 当单击元素时 dbclick 当双击元素时 mouseenter 当鼠标指针穿过（进入）被选元素时 mouseleave 当鼠标指针离开被选元素时 hover 当鼠标指针悬停在被选元素上时 ## 键盘事件 事件 描述 —– :—: keydown 键按下的过程 keypress 键被按下 keyup 键被松开 ## 表单事件 事件 描述 —– :—: submit 当提交表单时 change 当元素的值改变时发生 change 事件（仅适用于表单字段） focus 当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时） blur 当元素失去焦点时 ## 窗口事件 事件 描述 —– :—: resize 当调整浏览器窗口大小时 scroll 当用户滚动指定的元素时 DOM操作 jQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 提示：DOM = Document Object Model（文档对象模型）内容操作方法 html() 获取/设置元素的标签体内容（包括 HTML 标记） text() 获取/设置元素的标签体纯文本内容 val() 获取/设置元素的value属性值123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("Dolly Duck");&#125;); 属性操作方法 通用属性操作 attr() 获取/设置元素的属性 如果操作的是元素自定义的属性，则建议使用attr removeAttr() 删除属性 prop() 获取/设置元素的属性 如果操作的是元素的固有属性，则建议使用prop removeProp() 删除属性123$("button").click(function()&#123; $("#w3s").attr("href","http://www.w3school.com.cn/jquery");&#125;); 对class属性操作 addClass() 添加class属性值 removeClass() 删除class属性值 toggleClass() 切换class属性 toggleClass(“one”): 如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加。 css() 设置/添加属性值 123456789101112131415$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;);$("button").click(function()&#123; $("h1,h2,p").removeClass("blue");&#125;);$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;);$("p").css("background-color","yellow");$("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); 文档操作方法 append() 父元素将子元素追加到末尾 A.append(B) 将B添加到A元素内部，并且在末尾。 prepend() 父元素将子元素追加到开头 A.prepend(B) 将B添加到A元素内部，并且在开头。 appendTo() 子元素将父元素追加到末尾 A.appendTo(B) 将A添加到B内部，并且在末尾。 prependTo() 子元素将父元素追加到开头 A.prependTo(B) 将A添加到B内部，并且在开头。 after() 添加元素2到元素1后边 A.after(B) 将B添加到A后边（兄弟关系） before() 添加元素2到元素1前边 A.before(B) 将B添加到A前边（兄弟关系） insertAfter() 添加元素1到元素2后边 A.insertAfter(B) 将A添加到B后边（兄弟关系） insertBefore() 添加元素1到元素2前边 A.insertBefore(B) 将A添加到B前边（兄弟关系） remove() 移除元素 A.remove() 将A删除掉 empty() 清空元素的所有后代元素。 A.empty() 将对象的后代元素全部清空，但是保留当前A以及其属性节点12345678$("p").append("Some appended text.");$("p").prepend("Some prepended text.");$("img").after("Some text after");$("img").before("Some text before");$("#div1").remove();// jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。$("p").remove(".italic");$("#div1").empty(); 动画显示/隐藏 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： show( speed，callback ) hide( speed，callback ) 通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。 toggle(speed,callback) speed：参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 callback：参数是隐藏或显示完成后所执行的函数名称。1234567891011$("#hide").click(function()&#123; $("p").hide();&#125;);$("#show").click(function()&#123; $("p").show();&#125;);$("button").click(function()&#123; $("p").toggle();&#125;); 淡入/淡出 通过 jQuery，您可以实现元素的淡入淡出效果。 fadeIn() 用于淡入已隐藏的元素。 fadeOut() 用于淡出可见元素。 fadeToggle() 在淡入淡出之间切换。1234567891011121314151617$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;);$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); 滑动 通过 jQuery，您可以在元素上创建滑动效果。 slideDown() 用于向下滑动元素。 slideUp() 用于向上滑动元素。 slideToggle() 在向下滑动向上滑动之间切换。1234567891011$("#flip").click(function()&#123; $("#panel").slideDown();&#125;);$("#flip").click(function()&#123; $("#panel").slideUp();&#125;);$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 遍历JS的遍历方式 for (初始化值;循环结束条件;步长)Jquery的遍历方式 Jquery对象.each(callback) jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 callback：回调函数返回值 true：如果当前function返回为false，则结束循环(break)。 false：如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of for(元素对象 of 容器对象) Jqueryuery 3.0 之后1234567891011121314151617181920212223242526272829303132333435363738 /* for循环 */var citys = $("#city li");for (var i = 0; i &lt; citys.length; i++) &#123; //获取内容 alert(i+":"+citys[i].innerHTML); if("上海" == citys[i].innerHTML)&#123; //break; 结束循环 //continue; //结束本次循环，继续下次循环 &#125;&#125;/* Jquery对象.each(callback) */var citys = $("#city li");citys.each(function (index,element) &#123; // 1.获取li对象 第一种方式 this alert(this.innerHTML);//JS对象调用 alert($(this).html());//Jquery对象调用 // 2.获取li对象 第二种方式 在回调函数中定义参数 index（索引） element（元素对象） alert(index+":"+element.innerHTML); alert(index+":"+$(element).html()); //判断如果是上海，则结束循环 if("上海" == $(element).html())&#123; //返回false，结束循环(break)。 //返回true，结束本次循环，继续下次循环(continue) return true; &#125;&#125;);/* $.each(object, [callback]) */$.each(citys,function (index,element) &#123; alert($(this).html());&#125;);/* for ... of (jquery 3.0 版本之后提供的方式) */for(li of citys)&#123; alert($(li).html());&#125; 事件绑定 Jquery标准的绑定方式 jq对象.事件方法(回调函数) 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 toggle事件切换 jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。1&lt;script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 插件 $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie&Session&JSP]]></title>
    <url>%2F2019%2F07%2F15%2FCookie%26Session%26JSP%2F</url>
    <content type="text"><![CDATA[会话技术 概念 一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。 功能 在一次会话的范围内的多次请求间，来共享数据。 方式 客户端会话技术：Cookie 服务器端会话技术：Session Cookie概念 客户端会话技术，将数据保存到客户端。 Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies）； 一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies） 快速入门 使用步骤： 服务器通过response，对浏览器发送cookie *new Cookie(String name, String value) * *response.addCookie(Cookie cookie) * 服务器通过request，接收浏览器发送的cookie *Cookie[] request.getCookies() * 实现原理 服务器通过response，对浏览器发送cookie 服务器将数据，保存在响应头的set-cookie中。 当服务器通过request，接收浏览器发送的cookie 浏览器将数据，保存在请求头的cookie中。 cookie的细节一次可不可以发送多个cookie? 一次可以发送多个cookie。 创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁。 设置Cookie生命周期，使其持久化存储 setMaxAge(int seconds) 正数：持久化存储，并指定cookie存活时间。 在时间内，关闭浏览器cookie仍然可访问。 负数：默认值 关闭浏览器后，无法访问。 零：删除cookie信息 一般是先设置持久化存储，然后删除。cookie能不能存储中文？ 在tomcat8 之前，cookie中不能直接存储中文数据。 需要将中文数据转码为一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。 特殊字符还是不支持，建议使用URL编码存储，URL解码解析cookie共享问题？ 在同一个tomcat服务器中的多个web项目的cookie能不能共享？ 默认情况下cookie不能共享 设置获取cookie范围（默认设置当前虚拟目录） setPath(String path) 如果要共享，则可以将path设置为”/“（根路径） 在不同的tomcat服务器间cookie能不能共享？ 设置获取cookie范围 setDomain(String path) 如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”) 那么tieba.baidu.com和news.baidu.com中cookie可以共享 特点和作用 特点 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 浏览器对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别（个性化设置） JSP概念 Java Server Pages（java服务器端页面） 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理 JSP本质上就是一个Servlet实现类 如果我们要编写一个正常的主页，那么我们在servlet实现类中既要写后端代码，也要写前端代码。但是在servlet实现类中写前端代码（response.write.write()）太麻烦了，所以出现了JSP。 JSP本质是一个servlet实现类，它会将所有的前端代码自动的包裹进输出代码（out.write()）。 脚本 JSP的脚本：JSP定义Java代码的方式 &lt;% %&gt; 定义的java代码，在service方法中。 &lt;%! %&gt; 定义的java代码，定义java类的成员。 &lt;%= %&gt; 定义的java代码，输出到页面上。 内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象 request response out 字符输出流对象。可以将数据输出到页面上。 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 Session概念 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 快速入门 获取HttpSession对象 HttpSession session = request.getSession() 使用HttpSession对象 Object getAttribute(String name) void setAttribute(String name, Object value) *void removeAttribute(String name) * 原理 Session的实现是依赖于Cookie的。 细节 当浏览器关闭后，服务器不关闭，两次获取的session是否相同？ 默认情况下，两次session不同。 浏览器关闭，意味着会话结束。 如果需要两次session相同 创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie cookie = new Cookie(“JSESSIONID”,session.getId()); cookie.setMaxAge(60*60); response.addCookie(c); 浏览器不关闭，服务器关闭后，两次获取的session是否相同？ 两次session不同，但是要确保数据不丢失。 tomcat自动完成，IDEA不能 自动完成。 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上。 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30 &lt;session-config&gt; ## 特点－ session用于存储一次会话的多次请求的数据，存在服务器端。－ session可以存储任意类型，任意大小的数据。 session与Cookie的区别 Session(会话） － session存储数据在服务器端 － session没有数据大小限制 － session数据安全 Cookie（甜点） －Cookie有数据大小限制 －Cookie存储数据在客户端 －Cookie相对于不安全]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2F2019%2F07%2F14%2Fresponse%2F</url>
    <content type="text"><![CDATA[功能设置响应行 设置状态码 *setStatus(int sc) * 设置响应头 设置响应头 *setHeader(String name, String value) * 设置响应体 获取输出流 字符输出流（字符数据） PrintWriter getWriter() 字节输出流（任意数据） ServletOutputStream getOutputStream() 其他功能重定向（redirect） 重定向是一种在互联网中的资源跳转方式。 方法一 通过response对象设置状态码 response.setStatus(302); 使用response对象设置响应头的location参数 *response.setHeader(“location”,”/response2”); * 方法二 通过response对象的重定向方法 response.sendRedirect(“/response2”); 重定向的特点 重定向 重定向 地址栏会发生变化 重定向 可以访问其他服务器的资源 重定向 是两次请求 转发的特点 转发 转发 地址栏不会发生变化 转发 不可以访问其他服务器的资源 转发 是一次请求 输出数据 设置 获取字符输出流 PrintWriter writer = response.getWriter(); 输出数据 writer.write(“&lt;h1&gt;在恭喜发财！&lt;/h1&gt;”); 中文乱码问题 在获取流之前，设置流编码为系统默认编码（可以不写） response.setCharacterEncoding(“utf-8”); 设置浏览器解码的编码 response.setHeader(“content-type”,”text/html;charset=utf-8”); 设置浏览器解码的编码（简化） response.setContentType(“text/html;charset=utf-8”); ServletContext对象概念 ServletContext对象代表整个web应用，可以和程序的容器(服务器)来通信。获取 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext();功能获取MIME类型 获取MIME类型 String getMimeType(String file) MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。ServletContext域：所有用户所有请求的数据 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 文件真实路径 获取文件的真实路径（tomcat服务器） String getRealPath(String path); web目录下资源访问 context.getRealPath(“/b.txt”); WEB-INF目录下的资源访问 context.getRealPath(“/WEB-INF/c.txt”); src目录下的资源访问 context.getRealPath(“/WEB-INF/classes/a.txt”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2F2019%2F07%2F13%2Frequest%2F</url>
    <content type="text"><![CDATA[原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 体系结构 ServletRequest 接口 HttpServletRequest 接口 （继承） org.apache.catalina.connector.RequestFacade 类（Tomcat实现） 功能获取请求消息数据获取请求行数据 请求行数据：GET /web/A?name=Cat HTTP/1.1 请求方式： GET String getMethod() 请求端的URI(统一资源标识符) 地址：/web/A String getRequestURI() 请求端的URL(统一资源定位符)地址： http: //localhost//web/A StringBuilder getRequestURL() 虚拟目录：/web String getContextPath() 服务器路径：/A String getServletPath() 请求参数：name=Cat String getQueryString() HTTP协议的版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr()123456789101112131415161718//请求方式： GET String method = request.getMethod();//请求端的URI地址：/web/A String requestURI = request.getRequestURI();//请求端的URI地址：/web/A StringBuffer requestURL = request.getRequestURL();//虚拟目录：/web String contextPath = request.getContextPath();//服务器路径：/A String servletPath = request.getServletPath();//请求参数：name=Cat String queryString = request.getQueryString();//HTTP协议的版本：HTTP/1.1 String protocol = request.getProtocol();//获取客户机的IP地址： String remoteAddr = request.getRemoteAddr();//获取客户机的端口号 int remotePort = request.getRemotePort(); 获取请求头数据 请求头数据 通过请求头的名称 获取请求头的值 String getHeader(String name) 获取 所有的请求头名称（判断浏览器） Enumeration&lt;String&gt; getHeaderNames():12345678//获取 所有的请求头名称 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements())&#123; //通过请求头的名称 获取请求头的值 String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name+" ===== "+value); &#125; 获取请求体数据 请求体（POST请求方式） 获取字符输入流（字符数据） BufferedReader getReader() 获取字节输入流（所有类型数据） ServletInputStream getInputStream()1234567&lt;form action="/request1" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;input type="checkbox" name="hobby" value="dance"&gt; &lt;input type="checkbox" name="hobby" value="sing"&gt; &lt;input type="checkbox" name="hobby" value="rap"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 1234567891011@WebServlet("/request1")public class Request1 extends HttpServlet &#123;//获取字符输入流（字符数据） BufferedReader reader = request.getReader(); String line; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; 其他功能获取动态目录 为了防止虚拟目录变更，建议使用动态虚拟目录 -getContextPath() 路径 相对路径 相对路径 无法确定唯一资源 ./index.html 当前资源和目标资源的相对位置关系 ./ 当前目录 ../ 后退一级目录 绝对路径 绝对路径 可以确定唯一资源 /web/index.html 获取请求参数(通用) 获取请求参数通用方式 不论get还是post请求方式都可以使用下列方法来获取请求参数 根据参数名称 获取参数值 ：(username) cat String getParameter(String name) 根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] getParameterValues(String name) 获取 所有请求的参数名称：username hobby Enumeration&lt;String&gt; getParameterNames() 获取 所有参数的map集合：username=cat hobby=sing,rap Map&lt;String,String[]&gt; getParameterMap()1234567891011121314151617181920212223242526272829303132333435//根据参数名称 获取参数值 ：(username)cat String username = request.getParameter("username"); System.out.println(username); //根据参数名称 获取参数值的数组：(hobby) dance sing rap String[] hobbies = request.getParameterValues("hobby"); for (String hobby : hobbies) &#123; System.out.println(hobby); &#125;//获取 所有请求的参数名称： username hobbyEnumeration&lt;String&gt; parameterNames = request.getParameterNames();while (parameterNames.hasMoreElements())&#123;String s = parameterNames.nextElement();System.out.println(s);&#125;//获取 所有参数的map集合 /* Map集合：获取所有参数 */ Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); /* Set集合：包含参数和参数的值们 */ Set&lt;String&gt; keyset = parameterMap.keySet(); /* 迭代器*/ Iterator&lt;String&gt; iterator = keyset.iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.print(key+": "); String[] values = parameterMap.get(key); for (String value : values) &#123; System.out.print(value+" "); &#125; System.out.println();&#125; 请求转发（forword） 请求转发是一种在服务器内部的资源跳转方式。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 *forward(ServletRequest request, ServletResponse response) * 特点 浏览器地址栏路径不发生变化。 只能转发到当前服务器内部资源中。 多个服务器资源使用一次请求。 Java文件一 1234567891011@WebServlet("/request111")public class Request1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("助理：我是处理部门的助理，你有什么问题？"); System.out.println("助理：你的问题我解决不了，我去叫经理，稍等。"); //找到“经理的位置” RequestDispatcher requestDispatcher = request.getRequestDispatcher("/request222"); //把“问题”告诉经理 requestDispatcher.forward(request,response); &#125;&#125; Java文件二 1234567@WebServlet("/request222")public class Request2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("经理：我是处理部门的经理，你有什么问题？"); System.out.println("经理：你的问题我已经解决了，你回去吧。"); &#125;&#125; 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。request域：代表一次请求的范围，一般用于让请求转发的多个资源共享数据。 方法 存储数据 void setAttribute(String name,Object obj) 通过键 获取值 Object getAttitude(String name) 通过键 移除键值对 void removeAttribute(String name) 中文乱码问题 get方式：tomcat 8 已经将get方式乱码问题解决了。 post方式：中文或非法数据会乱码。 解决：在获取参数前，设置request的编码 request.setCharacterEncoding(“utf-8”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter&Listener]]></title>
    <url>%2F2019%2F07%2F12%2FFilter%26Listener%2F</url>
    <content type="text"><![CDATA[Filter（过滤器）概念 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。作用 一般用于完成通用的操作。 如：登录验证、统一编码处理、敏感字符过滤… 快速入门 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 过滤器细节web.xml配置123456789&lt;filter&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;demo1&lt;/filter-name&gt;&lt;!-- 拦截路径 --&gt;&lt;url-pattern&gt;/-&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码过滤器生命周期方法 init 在服务器启动后，会创建Filter对象，然后调用init方法。 只执行一次。 用于加载资源。 doFilter 每一次请求被拦截资源时，会执行。 执行多次。 destroy 在服务器关闭后，Filter对象被销毁。 如果服务器是正常关闭，则会执行destroy方法。 只执行一次。 用于释放资源。过滤器配置详解拦截路径配置 具体资源路径 /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录 /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截 *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源 /* 访问所有资源时，过滤器都会被执行拦截方式配置 资源被访问的方式 注解配置 设置dispatcherTypes属性 REQUEST：默认值，浏览器直接请求资源。 FORWARD：转发访问资源 。 ERROR：错误跳转资源。 ASYNC：异步访问资源。 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置：&lt;filter-mapping&gt;谁定义在上边，谁先执行 Listener（监听器）概念 web的三大组件之一事件监听机制 事件：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码运用 监听ServletContext对象的创建和销毁 ServletContextListener 方法： ServletContext对象被销毁之前会调用该方法 void contextDestroyed(ServletContextEvent sce) ServletContext对象创建后会调用该方法 void contextInitialized(ServletContextEvent sce) 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置1234web.xml&lt;listener&gt;&lt;listener-class&gt;listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解 @WebListener]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F07%2F12%2Fservlet%2F</url>
    <content type="text"><![CDATA[概念 server applet：运行在服务器端的小程序 为了更好的理解servlet，我们先从B/S模式来示例 用户输入账号密码，请求登录 我们需要判断 用户A输入的账号和密码是否正确。 此处需要运用 Java逻辑来判断。 也就是，我们需要通过Java代码来确定。 具体就是，通过Java类来实现。 创建 Java类，判断账号密码 但是，并非所有的Java类都可以在服务器端运行，想要在服务器端运行就必须依赖于服务器端。 换句话说，想要在服务器端运行就要遵循服务器端的”规则“。 而具体来说，在Java中的规则，即是接口。 Servlet就是一个接口 Servlet接口中定义了能被浏览器访问到的，且能被tomcat服务器识别到的Java类的规则。 自定义一个类，实现Servlet接口，复写Servlet接口方法。 快速入门 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 配置web.xml文件，设置虚拟路径 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo 文字输出在服务器端 刷新一次页面，输出一次文字 java文件 123456789101112131415161718192021public class A_ServletDemo implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123;&#125; @Override public ServletConfig getServletConfig() &#123;return null;&#125; /* 提供服务的方法 */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("Hello Servlet!!!"); &#125; @Override public String getServletInfo() &#123;return null;&#125; @Override public void destroy() &#123;&#125; &#125; 在web/WEB-INF目录下，配置web.xml 123456789101112131415&lt;!--配置Servlet --&gt; &lt;!-- name --&gt; &lt;!-- 全类名 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet.A_ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--配置Servlet映射--&gt; &lt;!-- name --&gt; &lt;!-- 虚拟路径 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 执行原理客户端对服务器发出请求 用户通过浏览器对服务器发出请求（ *http: //localhost:8080/web/demo * ） Tomcat服务器接受请求，并开始解析URL路径 web.xml文件 首先，Tomcat服务器通过虚拟路径找到相对应的&lt;url-pattern&gt;标签。 其次，Tomcat服务器通过&lt;url-pattern&gt;标签，获取&lt;servlet-name&gt;标签，以及&lt;servlet-class&gt;标签。 最后，Tomcat服务器通过&lt;servlet-class&gt;标签，获取到Java文件的全类名。 Tomcat服务器将java文件加载进内存（classObj = Class.forName(全类名); ） Tomcat服务器创建Servlet对象（ classObj.instance(); ） Tomcat服务器创建request对象和response对象。 request对象中封装 请求消息数据 response对象中封装 响应消息数据 Tomcat服务器调用service方法，并传入request对象和response对象。 我们通过request对象获取请求消息数据 并通过response对象设置响应消息数据 Tomcat服务器在给浏览器做出响应之前，会从response对象中拿出设置好的响应消息数据。 不同的请求方式GET方式 如果我们要通过GET方式来对Tomcat服务器发送请求，那么我们可以直接访问Tomcat服务器中的GET实现类。 比如，我创建了一个HTTPServlet实现类，但是里面只重写了doGET方法。此时可打开Tomcat服务器，直接通过浏览器访问GET实现类，继而完成在Tomcat服务器中的操作。POST方式 如果我们要通过POST方式来对Tomcat客户端发送请求，那么我们就不可以直接访问Tomcat客户端中的POST实现类。 比如，创建一个HTTPServlet实现类，但是里面只重写了doPOST方法，此时打开Tomcat客户端，但是无法直接通过浏览器访问POST实现类。 不过，可以通过使用POST方法传递的表单来实现。定义一个这样的POST表单，打开Tomcat客户端，访问POST表单，继而完成在Tomcat服务器中的操作。 抽象方法 service 提供服务的方法 只要servlet服务器被访问，service方法就会执行。 *init 初始化的方法 * 无论servlet服务器被访问多少次，init方法只会执行一次。 *destroy 销毁的方法 * 当servlet服务器被正常关闭时，destroy方法会执行一次。 *getServletConfig 获取配置对象的方法 * *getServletInfo 获取servlet信息的方法 * java文件 123456789101112131415161718192021222324252627282930313233/* 初始化方法 */ // 只会执行一次 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println("===init()执行了"); &#125; /* 获取配置对象方法 */ //ServletConfig：配置对象 @Override public ServletConfig getServletConfig() &#123; return null; &#125; /* 提供服务的方法 */ // servlet被访问一次，就执行一次 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("===service()执行了"); &#125; /* 获取servlet信息方法*/ @Override public String getServletInfo() &#123; return null; &#125; /* 销毁方法 */ // servlet正常关闭时，执行一次。 @Override public void destroy() &#123; System.out.println("===destroy&#123;&#125;执行了"); &#125; 生命周期被创建 servlet被创建时会执行init方法，且只执行一次。 修改配置 默认情况下，在servlet服务器第一次被访问时，Servlet被创建。 web.xml文件中，可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 第一次被访问时 创建&lt;load-on-startup&gt;标签，值为负数 在服务器启动时 创建&lt;load-on-startup&gt;标签，值为0或正整数 安全问题 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 所以多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值。 提供服务 每次访问Servlet服务器时，Service方法都会被调用一次。 被销毁 Servlet服务器被销毁时执行一次。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 注解 上述情况下，我们发现一个问题，即每次新建文件都需要在web.xml文件中添加虚拟路径。 为了解决这个问题，官方在Servlet3.0版本支持了注解配置，从而代替web.xml文件了。 在web.xml文件，除了需要指定虚拟目录以外，还需要指定文件目录。 而对于注解来说，@WebServlet已经定义在文件中了，所以只需要指定虚拟目录即可。 步骤 创建JavaEE项目 定义一个实现了Servlet接口的类 实现Servlet接口中的抽象方法 重写抽象方法，输出文字 在类上使用@WebServlet注解，进行配置 @WebServlet(urlPatterns = “/demo3”) *@WebServlet(“/demo3”) * 此处填写的源代码应是”value=’’demo3” “， 如果注解后只写一个属性的话，value可以不写。 启动tomcat服务器 项目的访问路径 （虚拟目录）：localhost:8080/web/demo3 文字输出在服务器端 刷新一次页面，输出一次文字 体系结构 Servlet 接口 GenericServlet 抽象类 （继承） HttpServlet 抽象类（继承） GenericServlet 抽象类 GenericServlet抽象类 将Servlet接口中其他的抽象方法默认空实现，只将service()方法作为抽象方法。 上述情况下，我们仍可以发现一个问题，即创建的实现了servlet接口的Java类中，有许多我们不需要重写的抽象方法。但是大部分情况下我只用需要实现service方法，那我们为什么不能不实现其他方法呢？ 为了解决这个问题，我们可以通过GenericServlet抽象类来完成。 Java类不再是 实现servlet接口 Java类如今是 继承GenericServelet抽象类 HttpServlet 抽象类 HttpServlet抽象类在其父类GenericServlet 抽象类的功能上更进一步。为了可以获取正确的数据，HttpServlet抽象类对请求的方法（get、post）自动进行了判断。 Java类继承 HttpServlet抽象类 复写doGet/doPost方法 相关配置 urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： 目录结构：/xxx 多层目录结构：/xxx/xxx 文件名：*.do]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F07%2F11%2FHTTP%2F</url>
    <content type="text"><![CDATA[概念 HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 传输协议 传输协议定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型 ：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本 HTTP 1.0：每一次请求响应都会建立新的连接，浪费时间，消耗资源。 HTTP 1.1：复用连接。 请求消息数据格式 数据格式 请求消息数据格式 响应消息数据格式 请求消息数据格式请求方式 HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求行 Request method ：请求方式 Request URI ：请求端的URI地址 Http version ：HTTP协议的版本 GET方式 POST方式2 请求头 Accept：指浏览器或其他客户可以接爱的MIME文件格式。 Accept-Encoding：指出浏览器可以接受的编码方式。 Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。 connection：用来告诉服务器是否可以维持固定的HTTP连接。 Cookie：浏览器用这个属性向服务器发送Cookie。 Host：对应网址URL中的Web名称和端口号。 User-Agent：客户浏览器名称。 兼容性问题 Referer：表明产生请求的网页URL。 防盗链 统计工作 Content-Type：用来表名request的内容类型。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1。 GET方式 POST方式 请求空行 空行，用于分割请求头和请求体。请求体 封装POST请求消息的请求参数的 GET方式 POST方式 响应消息数据格式响应行 协议/版本 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1xx 指示信息：表示请求已接收，但没有完成，需要继续处理。 2xx 成功：表示请求已被成功接收、理解、接受。 3xx 重定向：要完成请求必须进行更进一步的操作。 302：重定向 304：访问缓存 4xx 客户端错误：请求有语法错误或请求无法实现。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx 服务器端错误：服务器未能实现合法的请求。 响应头 Content-Type：响应体数据格式以及编码格式 text/html;charset=UTF-8 Content-disposition：打开响应体数据的格式 in-line：在当前页面内打开（默认值） attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行响应体 传输的数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2019%2F07%2F11%2Ftomcat%2F</url>
    <content type="text"><![CDATA[web相关概念回顾软件架构 C/S 客户端/服务器端 B/S 浏览器/服务器端 资源分类 静态资源 所有用户访问后，得到的结果都是一样的。静态资源可以直接被浏览器解析。 如： html，css，JavaScript 动态资源 每个用户访问相同资源后，得到的结果可能不一样。动态资源被访问后，需要先转换为静态资源，再返回给浏览器。 如：servlet/jsp，php，asp 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议 TCP：安全协议，三次握手； 速度稍慢。 UDP：不安全协议；速度快。 web服务器软件 服务器 安装了服务器软件的计算机。 服务器软件 接收用户的请求，处理请求，做出响应。 web服务器软件 在web服务器软件中，部署web项目，让用户通过浏览器来访问项目。 同时，接收用户的请求，处理请求，做出响应。 动态资源依赖于web服务器软件，只能运行在web服务器中。 常见的java相关的web服务器软件 webLogic oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 webSphere IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 Tomcat Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat安装软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格。 卸载 删除目录就行了。 启动： bin/startup.bat 访问 http://localhost:8080 （本地） http://IP地址:8080 （外部） Tomcat目录结构 bin 可执行文件 conf 配置文件 lib 依赖jar包 logs 日志文件 temp 临时文件 webapps web项目 work 运行时的数据 启动软件问题一： 黑窗口一闪而过 解决办法：配置环境变量 假设Tomcat安装路径为：D:\Tomcat\apache-tomcat-8.0.47 打开 [控制面板]–[系统和安全]–[系统]–[计算机名、域和工作组设置]–[更改设置] 在打开的窗口 [系统属性]中，[高级]–[环境变量]–[用户变量]–[新建] 新建变量名：CATALINA_BASE，变量值：D:\Tomcat\apache-tomcat-8.0.47 新建变量名：CATALINA_HOME，变量值：D:\Tomcat\apache-tomcat-8.0.47 打开变量Path，添加变量值：%CATALINA_HOME%\lib 打开变量Path，添加变量值： %CATALINA_HOME%\bin 检验环境变量是否配置成功 第一步，打开命令提示符，输入startup，按回车键，启动tomcat 第二步，打开浏览器，输入http://localhost:8080 ，启动tomcat 问题一：启动报错 解决办法一：结束程序进程 打开命令提示符，输入netstat -ano，获得PID值（进程ID） 打开任务管理器，查看进程，选项显示PID，按照PID值结束程序进程 解决办法二：修改端口号 conf 目录下，找到 server.xml 修改其中的端口号，避免端口冲突。（慎用！） 关于端口号 &lt;Connector port=”8080” protocol=”HTTP/1.1”connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 一般会我们会将tomcat的默认端口号修改为80，端口号80是http协议的默认端口号。这样我们在访问时，就不用输入端口号了。 关闭 正常关闭： 在bin目录下，运行shutdown.bat 在启动的窗口中，按 ctrl+c 强制关闭： 直接关闭启动的窗口 部署web项目 放置项目目录下 直接将项目放置到webapps目录下 项目的访问路径 （虚拟目录）：localhost:8080/web/index.html 简化部署 将项目打成一个war包，再将war包放置到webapps目录下。 放置war包，自动解压缩出文件；删除war包，文件自动删除。 配置文件 在conf 目录下，找到 server.xml 在标签体中配置 &lt;Context docBase=”D:\web” path=”/w” /&gt; docBase:项目存放的路径 path：虚拟目录 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html 创建文件 在conf\Catalina\localhost目录下，创建任意名称的xml文件。 在xml文件中配置 w.xml &lt;Context docBase=”D:\hello” /&gt; 项目的访问路径 （虚拟目录）：localhost:8080/w/index.html web项目目录结构 java动态项目的目录结构 项目的根目录 WEB-INF目录 web.xml web项目的核心配置文件 classes目录 放置字节码文件的目录 lib目录 放置依赖的jar包]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2019%2F07%2F10%2FXML%2F</url>
    <content type="text"><![CDATA[概念 XML（ Extensible Markup Language），即 可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。 可扩展语言的精华在于其”Extensible”，即 在XML中的标签都是自定义的。 功能存储数据 配置文件 在网络中传输 xml与html的区别 HTML 标签预定义； 语法松散； 功能为展示数据。 XML 标签自定义； 语法严格； 功能为存储数据。 语法基本语法 后缀名 .xml 文档声明 必须在第一行 根标签 有且仅有一个 属性值 必须使用引号(单双都可)引起来 标签 必须正确关闭 标签名称 区分大小写 快速入门1234567891011121314&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分文档声明格式&lt;?xml 属性列表 ?&gt; 属性列表 version：版本号（必须的属性） 一般值：1.0 encoding：编码方式。 告知解析引擎当前文档使用的字符集 默认值：ISO-8859-1 （不支持中文） standalone：是否独立 yes：不依赖其他文件 no：依赖其他文件 指令（结合css） &lt;?xml-stylesheet type=”text/css” href=”a.css” ?&gt; 标签（自定义） 定义规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性属性值唯一 文本 CDATA区（原样展示数据） 格式： &lt;![CDATA[ 数据 ]]&gt; 约束 约束规定了ml文档的书写规则。 DTD约束技术DTD是一种简单的约束技术。我们可以通过dtd文件控制标签和标签的属性，但是对于标签内容的控制我们无能为力。而schema约束技术恰巧弥补了这一缺陷，关于schema约束技术在下一节会详细展开。 外部dtd引入 将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt; 外部dtd：dtd文件 1234567891011121314&lt;!-- ELEMENT元素（定义标签）--&gt; &lt;!-- students标签 （包含student标签 0个或者多个） --&gt;&lt;!ELEMENT students (student*) &gt; &lt;!-- student标签 （包含name标，age标签，sex标签 只能有一个） --&gt;&lt;!ELEMENT student (name,age,sex)&gt; &lt;!-- name标签 （字符串）--&gt;&lt;!ELEMENT name (#PCDATA)&gt; &lt;!-- age标签 （字符串）--&gt;&lt;!ELEMENT age (#PCDATA)&gt; &lt;!-- sex标签 （字符串）--&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!-- ATTLIST元素（定义属性）--&gt; &lt;!-- student标签 number属性 属性类型为ID #并且必需出现 --&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 外部dtd：xml文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 内部引入DTD文档 --&gt;&lt;!DOCTYPE students SYSTEM "student.dtd"&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 内部dtd 引入 将约束规则定义在xml文件中 内部dtd：xml文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 引入DTD文档 --&gt;&lt;!DOCTYPE students [ &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt;&lt;students&gt; &lt;student number="cat"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; Schema约束技术Schema是一种复杂的约束技术。它本身是一个xml文档，但文件后缀名以.xsd结尾。 引入实例 schema文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns="http://www.itcast.cn/xml" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.itcast.cn/xml" elementFormDefault="qualified"&gt; &lt;!-- element元素 &#123;自定义标签(1):students 自定义类型(1):studentsType&#125; --&gt; &lt;xsd:element name="students" type="studentsType"/&gt; &lt;!-- complexType元素 &#123;自定义类型(1):studentsType&#125; --&gt; &lt;!-- sequence元素（按顺序） --&gt; &lt;!-- element元素 &#123;自定义标签(1-1):student 自定义类型(1-1):studentType 最少出现:0次 最多出现:无限制&#125; --&gt; &lt;xsd:complexType name="studentsType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="student" type="studentType" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;!-- complexType元素 &#123;自定义类型(1-1):studentType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-1):name 基本类型:xsd:string&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-2):age 自定义类型(1-1-2):ageType&#125; --&gt; &lt;!-- element元素 &#123;自定义标签(1-1-3):sex 自定义类型(1-1-3):sexType&#125; --&gt; &lt;!-- attribute元素 &#123;定义属性:number 自定义类型(1-1-4):numberType #必需&#125; --&gt; &lt;xsd:complexType name="studentType"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name="name" type="xsd:string"/&gt; &lt;xsd:element name="age" type="ageType" /&gt; &lt;xsd:element name="sex" type="sexType" /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name="number" type="numberType" use="required"/&gt; &lt;/xsd:complexType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-2)：sexType &#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 可选值：male --&gt; &lt;!-- 可选值：female --&gt; &lt;xsd:simpleType name="sexType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:enumeration value="male"/&gt; &lt;xsd:enumeration value="female"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-3)：ageType&#125; --&gt; &lt;!-- 基本类型：integer --&gt; &lt;!-- 最小值：0 --&gt; &lt;!-- 最大值：256 --&gt; &lt;xsd:simpleType name="ageType"&gt; &lt;xsd:restriction base="xsd:integer"&gt; &lt;xsd:minInclusive value="0"/&gt; &lt;xsd:maxInclusive value="256"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;!-- simpleType元素 &#123;自定义类型(1-1-4):numberType&#125; --&gt; &lt;!-- 基本类型：string --&gt; &lt;!-- 格式化：Cat_后跟四个数字 --&gt; &lt;xsd:simpleType name="numberType"&gt; &lt;xsd:restriction base="xsd:string"&gt; &lt;xsd:pattern value="Cat_\d&#123;4&#125;"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt; xml文件 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. xsi:schemaLocation=”http://www.itcast.cn/xml student.xsd” 为每一个xsd约束声明一个前缀,作为标识 xmlns:xxx=”http://www.itcast.cn/xml&quot; 不写为默认前缀 xmlns=”http://www.itcast.cn/xml&quot; 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;students xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.itcast.cn/xml student.xsd" xmlns="http://www.itcast.cn/xml" &gt; &lt;student number="Cat_0001"&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 解析操作xml文档，将文档中的数据读取到内存中。 操作xml文档 解析(读取)：将文档中的数据读取到内存中。 写入：将内存中的数据保存到xml文档中。 解析xml文档DOM DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树。 优点：操作方便，能对文档进行CRUD的所有操作。 缺点：因为形成了DOM树，所以DOM比较占内存，不适用于内存较小的设备。 SAX SAX：基于事件驱动，逐行读取，读取一行释放一行。 优点：不占内存，适用于内存较小的设备。 缺点：只能读取，不能增删改。 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想。但是性能低，基本没有人使用。 DOM4J：一款非常优秀的解析器。 PULL：Android操作系统内置的解析器，支持sax思想。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoupjsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 步骤 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 快速入门1234567891011121314151617181920// 1.导入jar包// 2.根据xml文件，获取Document对象 // * 获取 DTD约束的student.xml文件路径 // * 解析 xml文档，获取DOM树（Document对象）,抛出异常 /* 通过本类的字节码文件，找到类加载器；再通过类加载器，找到文件路径；最后得到文件路径的字符串形式 */ String path = A_Jsoup.class.getClassLoader().getResource("DTD/student.xml").getPath(); Document ducument = Jsoup.parse(new File(path),"utf-8");// 3.获取Element元素对象 name Elements names = ducument.getElementsByTag("name");// 输出所有name元素 System.out.println(names);// 输出第一个name元素 Element name1 = names.get(0); String nameStr1 = name1.text(); System.out.println(nameStr1); 对象Jsoup工具类 获取Document对象 parse(File in, String charsetName)：解析xml、html文件 parse(String html)：解析xml、html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html、xml的文档对象 Java文件：解析html文件 123456789101112131415161718192021 /* 解析xml、html文件 */ String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/test.html").getPath(); Document document = Jsoup.parse(new File(path),"utf-8"); System.out.println(document);/* 解析xml、html字符串 */ Document document2 = Jsoup.parse("&lt;!DOCTYPE html&gt;\n" + "&lt;html lang=\"en\"&gt;\n" + "&lt;head&gt;\n" + " &lt;meta charset=\"UTF-8\"&gt;\n" + " &lt;title&gt;Title&lt;/title&gt;\n" + "&lt;/head&gt;\n" + "&lt;body&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"); System.out.println(document2);/* 通过网络路径获取指定的html、xml的文档对象 */ URL url = new URL("https://www.baidu.com/"); Document document3 = Jsoup.parse( url, 3000); System.out.println(document3); Document文档对象 获取Element对象（任意） getElementById(String id)：根据id属性值，获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称，获取元素对象集合 getElementsByAttribute(String key)：根据属性名称，获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值，获取元素对象集合 html文件 1234567&lt;body&gt; &lt;div id="div1"&gt; &lt;div class="div2" align="left"&gt;&lt;/div&gt; &lt;div class="div2" align="center"&gt;&lt;/div&gt; &lt;div class="div2" align="right"&gt;&lt;/div&gt; &lt;/div&gt; Java文件：解析html文件 123456789101112131415161718String path = A_Jsoup.class.getClassLoader().getResource("Jsoup/C_test.html").getPath();Document document = Jsoup.parse(new File(path),"utf-8");/*根据id属性值，获取唯一的element对象*/ Element id = document.getElementById("div1"); System.out.println(id);/*根据标签名称，获取元素对象集合*/ Elements tag = document.getElementsByTag("div"); System.out.println(tag);/*根据属性名称，获取元素对象集合*/ Elements attribute = document.getElementsByAttribute("align"); System.out.println(attribute);/*根据对应的属性名和属性值，获取元素对象集合*/ Elements attributeValue = document.getElementsByAttributeValue("align", "center"); System.out.println(attributeValue); Elements集合Elements是元素Element对象的集合，相当于一个 ArrayList&lt;Element&gt;。 Element：元素对象 获取Element对象（当前元素的子标签） getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) html文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="attributeValue"&gt; &lt;span&gt;文本内容&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; java文件 1234567891011121314151617181920//获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/D_test.html").getPath();//获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");//获取 Elements对象 Elements tags = document.getElementsByTag("div");//获取 Element对象 Element div = tags.get(0);/* 根据属性名称获取属性值 */ String att = div.attr("id"); System.out.println(att);/* 根据属性名称获取属性值 */ String text = div.text(); System.out.println(text);/* 获取标签体的所有内容(包括字标签的字符串内容) */ String html = div.html(); System.out.println(html); Node：节点对象 Node是Document和Element的父类。 查询快捷查询方式： selector：选择器 XPath：XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。selector 方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 html文件 123456 &lt;div&gt; &lt;div id="div"&gt; &lt;div class="div"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; java文件 1234567891011121314151617181920212223242526272829303132333435// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");/* 选择所有div标签 */ Elements selector1 = document.select("div"); for (Element element : selector1) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的标签*/ Elements selector3 = document.select("#div"); for (Element element : selector3) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择所有class属性值为div的标签*/ Elements selector2 = document.select(".div"); for (Element element : selector2) &#123; System.out.println(element); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ Elements elements = document.select("div[id='div'] &gt; div"); for (Element element : elements) &#123; System.out.println(element); System.out.println(); &#125; XPath 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 注意：在填写xpath时，引号内不允许有空格。 java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 获取 文件路径 String path = D_Element.class.getClassLoader().getResource("Jsoup/E_test.html").getPath();// 获取 Document对象 Document document = Jsoup.parse(new File(path), "utf-8");// 获取 JXDocument对象 JXDocument jxDocument = new JXDocument(document);/* 选择所有div标签 */ List&lt;JXNode&gt; jxNodes = jxDocument.selN("//div"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有id属性值为div的div标签 */ List&lt;JXNode&gt; jxNodes2 = jxDocument.selN("//div[@id='div']"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择id属性值的所有值*/ List&lt;JXNode&gt; jxNodes3 = jxDocument.selN("//@id"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的div标签 */ List&lt;JXNode&gt; jxNodes4 = jxDocument.selN("//div/div"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择所有div标签下的所有带class属性的div标签 */ List&lt;JXNode&gt; jxNodes5 = jxDocument.selN("//div/div[@class]"); for (JXNode jxNode : jxNodes5) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");/* 选择 父标签为div，且父标签id属性为div，的div子标签 */ List&lt;JXNode&gt; jxNodes6 = jxDocument.selN("//div[@id=div]/div"); for (JXNode jxNode : jxNodes6) &#123; System.out.println(jxNode); System.out.println(); &#125; System.out.println("------------------");]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>DTD</tag>
        <tag>Schame</tag>
        <tag>Jsoup</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2F2019%2F07%2F09%2FBootStrap%2F</url>
    <content type="text"><![CDATA[概念Bootstrap是一个前端开发的框架，来自 Twitter，是目前很受欢迎的前端框架。它基于 HTML、CSS、JavaScript ，具有简洁、直观、强悍的优点，使得 Web 开发更加快捷。 优势 响应式设计，能够自适应于台式机、平板电脑、手机，确保了适当的绘制和触屏缩放，同时可以设置禁止缩放功能，使网站看上去感觉更像原生应用。 包含了功能强大的内置组件（css样式和js插件），我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 快速入门 下载Bootstrap框架Bootstrap官网下载 将Bootstrap框架引入项目直接将解压后的文件复制进项目即可 HTML文件模板任何bootstrap页面都是基于这样的一个模板 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt;&lt;!-- 下面的3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;&lt;!-- Bootstrap --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 响应式布局 响应式布局就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。 响应式布局的实现，依赖于栅格系统。 栅格系统栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 栅格系统，简单来说，就是将页面一行平均分成12个格子，根据不同的终端对元素设定不同的格子。 在PC端每张图片设定占4个格子，那么PC端页面每一行显示3张图片 在平板电脑每张图片设定占6个格子，那么平板电脑端页面每一行只显示2张图片。 在手机端每张图片设定占12个格子，那么手机端页面每一行则只显示1张图片。 步骤 定义容器 container（固定宽度） container-fluid（100% 宽度） 定义行 row 定义元素 col-设备代号-格子数目 设备代号 xs 超小屏幕 手机 (&lt;768px) sm 小屏幕 平板 (≥768px) md 中等屏幕 桌面显示器 (≥992px) lg 大屏幕 大桌面显示器 (≥1200px) 注意 如果设定的格子数目超过12，超出部分自动换行。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 栅格类属性可以向上兼容。 只设定手机端图片占4个格子，那么手机端、平板端和PC端页面每行都显示3张图片。 案例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 定义了div的边框 --&gt; &lt;style&gt; .inner&#123; border: 1px solid #1c7430 ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义容器 --&gt; &lt;div class="container-fluid"&gt; &lt;!-- 定义行 --&gt; &lt;div class="row"&gt; &lt;!-- 定义元素 --&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-md-2 col-sm-4 col-xs-6 inner"&gt;栅格&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;CSS样式 按钮 预定样式 12345678910111213&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt;&lt;button type="button" class="btn btn-primary"&gt;（首选项）Primary&lt;/button&gt;&lt;button type="button" class="btn btn-success"&gt;（成功）Success&lt;/button&gt;&lt;button type="button" class="btn btn-info"&gt;（一般信息）Info&lt;/button&gt;&lt;button type="button" class="btn btn-warning"&gt;（警告）Warning&lt;/button&gt;&lt;button type="button" class="btn btn-danger"&gt;（危险）Danger&lt;/button&gt;&lt;button type="button" class="btn btn-link"&gt;（链接）Link&lt;/button&gt; 尺寸 12345678910111213141516&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-lg"&gt;（大按钮）Large button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-lg"&gt;（大按钮）Large button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary"&gt;（默认尺寸）Default button&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;（默认尺寸）Default button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-sm"&gt;（小按钮）Small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-sm"&gt;（小按钮）Small button&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;button type="button" class="btn btn-default btn-xs"&gt;（超小尺寸）Extra small button&lt;/button&gt;&lt;/p&gt; 图片 图片在任意尺寸都占100% 1&lt;img src="..." class="img-responsive" alt="Responsive image"&gt; 图片形状 ​ 123&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt; 表格 表格实例 123&lt;table class="table"&gt; ...&lt;/table&gt; 条纹状表格 123&lt;table class="table table-striped"&gt; ...&lt;/table&gt; 带边框的表格 123&lt;table class="table table-bordered"&gt; ...&lt;/table&gt; 鼠标悬停 123&lt;table class="table table-hover"&gt; ...&lt;/table&gt; 响应式表格12345&lt;div class="table-responsive"&gt;&lt;table class="table"&gt; ...&lt;/table&gt;&lt;/div&gt; 表单 表单实例 123456789101112131415161718192021&lt;form&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt;&lt;/div&gt;&lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt;&lt;/div&gt;&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt;&lt;/div&gt;&lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 水平排列的表单 12345678910111213141516171819202122232425262728 &lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 组件导航条 导航条实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 反色的导航条 123&lt;nav class=&quot;navbar navbar-inverse&quot;&gt; ...&lt;/nav&gt; 分页条 分页条实例 12345678910111213141516171819&lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 插件 Carousel（轮播图） 轮播图实例1234567891011121314151617181920212223242526272829303132333435&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TyparoMarkdown]]></title>
    <url>%2F2019%2F07%2F09%2FTyparoMarkdown%2F</url>
    <content type="text"><![CDATA[*语法手册* 功能 markdown语法 快捷键 转义字符 \ 分割线 -– 标题 # ## ### ctrl + 1~6 斜体 * ctrl + I 粗体 ** ctrl + B 下划线 ctrl + U 删除线 ~~ alt + shift +5 引用 &lt; ctrl + shift + Q 超链接 \ ctrl + K 代码片段 · ctrl + shift + ` 代码块 ··· ctrl + shift + K 图片 [ ]( “”) ctrl + shift + I 有序列表 1. 2. 3. ctrl + shift + [ 无序列表 - + * ctrl + shift + ] 表格 ctrl + T 清除样式 ctrl + \ 源代码模式 ctrl + / 目录 [toc] 脚注 [^ ]: 第1章 标题123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 第2章 字体12345*斜体* **粗体** ***粗斜体*** &lt;u&gt;下划线&lt;/u&gt; ~~删除线~~ 斜体粗体粗斜体下划线 删除线 第3章 引用123&gt;引用 &gt;&gt;引用&gt;&gt;&gt;引用 引用 引用 引用 第4章 超链接1[百度](http://baidu.com &quot;title&quot;) 百度 ​ * 默认在本页面打开 第5章 引用链接12345[百度][id][id]: http://baidu.com &quot;title&quot;[百度][][百度]: http://baidu.com &quot;title&quot; [百度][id][id]: http://baidu.com “title” 百度 第6章 分割线1234-------******** 第7章 代码12代码片段 代码块 代码片段 12&gt; 代码块&gt; 第8章 图片1![panda](http://pvpv3a462.bkt.clouddn.com/StudyNotes/BootStrap/pic01.jpg &apos;&apos;panda&apos;&apos;) 第9章 列表123456789101. 有序 2. 有序3. 有序- 无序- 无序+ 无序+ 无序* 无序* 无序 有序 有序 有序 无序 无序 无序 无序 无序 无序 第10章 任务列表123[] 洗衣服[] 吃饭[] 睡觉 洗衣服 吃饭 睡觉 第11章 表格1234567 姓名 | 技能 | 排行 -- | :--: | --: 刘备 | 哭 | 大哥 关羽 | 打 | 二哥 张飞 | 骂 | 三弟* 左对齐 -- 居中 :--: 右对齐 --: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 第12章 脚注123[^1]:a note at the bottom of the page in a book.This is a footnote[^1] [^1]:a note at the bottom of the page in a book.This is a footnote.[^1] 第13章 表情123:cat::dog::rat: :cat::dog::rat: 第148章 上标下标12H~2~OX^2^ H2OX^2^ 附录Typora官方文档* Markdown链接默认本窗口打开]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
